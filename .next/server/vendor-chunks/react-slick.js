"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-slick";
exports.ids = ["vendor-chunks/react-slick"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-slick/lib/arrows.js":
/*!************************************************!*\
  !*** ./node_modules/react-slick/lib/arrows.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PrevArrow = exports.NextArrow = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"(ssr)/./node_modules/classnames/index.js\"));\nvar _innerSliderUtils = __webpack_require__(/*! ./utils/innerSliderUtils */ \"(ssr)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nvar PrevArrow = /*#__PURE__*/ function(_React$PureComponent) {\n    _inherits(PrevArrow, _React$PureComponent);\n    var _super = _createSuper(PrevArrow);\n    function PrevArrow() {\n        _classCallCheck(this, PrevArrow);\n        return _super.apply(this, arguments);\n    }\n    _createClass(PrevArrow, [\n        {\n            key: \"clickHandler\",\n            value: function clickHandler(options, e) {\n                if (e) {\n                    e.preventDefault();\n                }\n                this.props.clickHandler(options, e);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var prevClasses = {\n                    \"slick-arrow\": true,\n                    \"slick-prev\": true\n                };\n                var prevHandler = this.clickHandler.bind(this, {\n                    message: \"previous\"\n                });\n                if (!this.props.infinite && (this.props.currentSlide === 0 || this.props.slideCount <= this.props.slidesToShow)) {\n                    prevClasses[\"slick-disabled\"] = true;\n                    prevHandler = null;\n                }\n                var prevArrowProps = {\n                    key: \"0\",\n                    \"data-role\": \"none\",\n                    className: (0, _classnames[\"default\"])(prevClasses),\n                    style: {\n                        display: \"block\"\n                    },\n                    onClick: prevHandler\n                };\n                var customProps = {\n                    currentSlide: this.props.currentSlide,\n                    slideCount: this.props.slideCount\n                };\n                var prevArrow;\n                if (this.props.prevArrow) {\n                    prevArrow = /*#__PURE__*/ _react[\"default\"].cloneElement(this.props.prevArrow, _objectSpread(_objectSpread({}, prevArrowProps), customProps));\n                } else {\n                    prevArrow = /*#__PURE__*/ _react[\"default\"].createElement(\"button\", _extends({\n                        key: \"0\",\n                        type: \"button\"\n                    }, prevArrowProps), \" \", \"Previous\");\n                }\n                return prevArrow;\n            }\n        }\n    ]);\n    return PrevArrow;\n}(_react[\"default\"].PureComponent);\nexports.PrevArrow = PrevArrow;\nvar NextArrow = /*#__PURE__*/ function(_React$PureComponent2) {\n    _inherits(NextArrow, _React$PureComponent2);\n    var _super2 = _createSuper(NextArrow);\n    function NextArrow() {\n        _classCallCheck(this, NextArrow);\n        return _super2.apply(this, arguments);\n    }\n    _createClass(NextArrow, [\n        {\n            key: \"clickHandler\",\n            value: function clickHandler(options, e) {\n                if (e) {\n                    e.preventDefault();\n                }\n                this.props.clickHandler(options, e);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var nextClasses = {\n                    \"slick-arrow\": true,\n                    \"slick-next\": true\n                };\n                var nextHandler = this.clickHandler.bind(this, {\n                    message: \"next\"\n                });\n                if (!(0, _innerSliderUtils.canGoNext)(this.props)) {\n                    nextClasses[\"slick-disabled\"] = true;\n                    nextHandler = null;\n                }\n                var nextArrowProps = {\n                    key: \"1\",\n                    \"data-role\": \"none\",\n                    className: (0, _classnames[\"default\"])(nextClasses),\n                    style: {\n                        display: \"block\"\n                    },\n                    onClick: nextHandler\n                };\n                var customProps = {\n                    currentSlide: this.props.currentSlide,\n                    slideCount: this.props.slideCount\n                };\n                var nextArrow;\n                if (this.props.nextArrow) {\n                    nextArrow = /*#__PURE__*/ _react[\"default\"].cloneElement(this.props.nextArrow, _objectSpread(_objectSpread({}, nextArrowProps), customProps));\n                } else {\n                    nextArrow = /*#__PURE__*/ _react[\"default\"].createElement(\"button\", _extends({\n                        key: \"1\",\n                        type: \"button\"\n                    }, nextArrowProps), \" \", \"Next\");\n                }\n                return nextArrow;\n            }\n        }\n    ]);\n    return NextArrow;\n}(_react[\"default\"].PureComponent);\nexports.NextArrow = NextArrow;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL2Fycm93cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLEdBQUc7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixHQUFHO1FBQUksT0FBTyxPQUFPQTtJQUFLLElBQUksU0FBVUEsR0FBRztRQUFJLE9BQU9BLE9BQU8sY0FBYyxPQUFPQyxVQUFVRCxJQUFJRyxXQUFXLEtBQUtGLFVBQVVELFFBQVFDLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUssR0FBR0QsUUFBUUM7QUFBTTtBQUUvVUssOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBRyxLQUFLO0FBRTdDLElBQUlJLFNBQVNDLHVCQUF1QkMsbUJBQU9BLENBQUMsd0dBQU87QUFFbkQsSUFBSUMsY0FBY0YsdUJBQXVCQyxtQkFBT0EsQ0FBQyw0REFBWTtBQUU3RCxJQUFJRSxvQkFBb0JGLG1CQUFPQSxDQUFDLGdHQUEwQjtBQUUxRCxTQUFTRCx1QkFBdUJaLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJZ0IsVUFBVSxHQUFHaEIsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUVoRyxTQUFTaUI7SUFBYUEsV0FBV1osT0FBT2EsTUFBTSxJQUFJLFNBQVVDLE1BQU07UUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQUUsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQUUsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUFFLElBQUlsQixPQUFPRCxTQUFTLENBQUNxQixjQUFjLENBQUNDLElBQUksQ0FBQ0gsUUFBUUMsTUFBTTtvQkFBRUwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtn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QzhDLFlBQVk7b0JBQ3JDQyxZQUFZLElBQUksQ0FBQy9DLEtBQUssQ0FBQytDLFVBQVU7Z0JBQ25DO2dCQUNBLElBQUltQjtnQkFFSixJQUFJLElBQUksQ0FBQ2xFLEtBQUssQ0FBQ2tFLFNBQVMsRUFBRTtvQkFDeEJBLFlBQVksV0FBVyxHQUFFMUcsTUFBTSxDQUFDLFVBQVUsQ0FBQ2dHLFlBQVksQ0FBQyxJQUFJLENBQUN4RCxLQUFLLENBQUNrRSxTQUFTLEVBQUU5RSxjQUFjQSxjQUFjLENBQUMsR0FBRzZFLGlCQUFpQlg7Z0JBQ2pJLE9BQU87b0JBQ0xZLFlBQVksV0FBVyxHQUFFMUcsTUFBTSxDQUFDLFVBQVUsQ0FBQ2lHLGFBQWEsQ0FBQyxVQUFVM0YsU0FBUzt3QkFDMUVPLEtBQUs7d0JBQ0xxRixNQUFNO29CQUNSLEdBQUdPLGlCQUFpQixLQUFLO2dCQUMzQjtnQkFFQSxPQUFPQztZQUNUO1FBQ0Y7S0FBRTtJQUVGLE9BQU8zRztBQUNULEVBQUVDLE1BQU0sQ0FBQyxVQUFVLENBQUNtRyxhQUFhO0FBRWpDdkcsaUJBQWlCLEdBQUdHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pdmVyc2FsLWRlbW8tYXBwLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNsaWNrL2xpYi9hcnJvd3MuanM/NjY4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5QcmV2QXJyb3cgPSBleHBvcnRzLk5leHRBcnJvdyA9IHZvaWQgMDtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9jbGFzc25hbWVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xhc3NuYW1lc1wiKSk7XG5cbnZhciBfaW5uZXJTbGlkZXJVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lubmVyU2xpZGVyVXRpbHNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIFByZXZBcnJvdyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFByZXZBcnJvdywgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUHJldkFycm93KTtcblxuICBmdW5jdGlvbiBQcmV2QXJyb3coKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByZXZBcnJvdyk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUHJldkFycm93LCBbe1xuICAgIGtleTogXCJjbGlja0hhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xpY2tIYW5kbGVyKG9wdGlvbnMsIGUpIHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcy5jbGlja0hhbmRsZXIob3B0aW9ucywgZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgcHJldkNsYXNzZXMgPSB7XG4gICAgICAgIFwic2xpY2stYXJyb3dcIjogdHJ1ZSxcbiAgICAgICAgXCJzbGljay1wcmV2XCI6IHRydWVcbiAgICAgIH07XG4gICAgICB2YXIgcHJldkhhbmRsZXIgPSB0aGlzLmNsaWNrSGFuZGxlci5iaW5kKHRoaXMsIHtcbiAgICAgICAgbWVzc2FnZTogXCJwcmV2aW91c1wiXG4gICAgICB9KTtcblxuICAgICAgaWYgKCF0aGlzLnByb3BzLmluZmluaXRlICYmICh0aGlzLnByb3BzLmN1cnJlbnRTbGlkZSA9PT0gMCB8fCB0aGlzLnByb3BzLnNsaWRlQ291bnQgPD0gdGhpcy5wcm9wcy5zbGlkZXNUb1Nob3cpKSB7XG4gICAgICAgIHByZXZDbGFzc2VzW1wic2xpY2stZGlzYWJsZWRcIl0gPSB0cnVlO1xuICAgICAgICBwcmV2SGFuZGxlciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2QXJyb3dQcm9wcyA9IHtcbiAgICAgICAga2V5OiBcIjBcIixcbiAgICAgICAgXCJkYXRhLXJvbGVcIjogXCJub25lXCIsXG4gICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzW1wiZGVmYXVsdFwiXSkocHJldkNsYXNzZXMpLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgICAgICB9LFxuICAgICAgICBvbkNsaWNrOiBwcmV2SGFuZGxlclxuICAgICAgfTtcbiAgICAgIHZhciBjdXN0b21Qcm9wcyA9IHtcbiAgICAgICAgY3VycmVudFNsaWRlOiB0aGlzLnByb3BzLmN1cnJlbnRTbGlkZSxcbiAgICAgICAgc2xpZGVDb3VudDogdGhpcy5wcm9wcy5zbGlkZUNvdW50XG4gICAgICB9O1xuICAgICAgdmFyIHByZXZBcnJvdztcblxuICAgICAgaWYgKHRoaXMucHJvcHMucHJldkFycm93KSB7XG4gICAgICAgIHByZXZBcnJvdyA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudCh0aGlzLnByb3BzLnByZXZBcnJvdywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcmV2QXJyb3dQcm9wcyksIGN1c3RvbVByb3BzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2QXJyb3cgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIF9leHRlbmRzKHtcbiAgICAgICAgICBrZXk6IFwiMFwiLFxuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCJcbiAgICAgICAgfSwgcHJldkFycm93UHJvcHMpLCBcIiBcIiwgXCJQcmV2aW91c1wiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZBcnJvdztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUHJldkFycm93O1xufShfcmVhY3RbXCJkZWZhdWx0XCJdLlB1cmVDb21wb25lbnQpO1xuXG5leHBvcnRzLlByZXZBcnJvdyA9IFByZXZBcnJvdztcblxudmFyIE5leHRBcnJvdyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQyKSB7XG4gIF9pbmhlcml0cyhOZXh0QXJyb3csIF9SZWFjdCRQdXJlQ29tcG9uZW50Mik7XG5cbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoTmV4dEFycm93KTtcblxuICBmdW5jdGlvbiBOZXh0QXJyb3coKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5leHRBcnJvdyk7XG5cbiAgICByZXR1cm4gX3N1cGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE5leHRBcnJvdywgW3tcbiAgICBrZXk6IFwiY2xpY2tIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsaWNrSGFuZGxlcihvcHRpb25zLCBlKSB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMuY2xpY2tIYW5kbGVyKG9wdGlvbnMsIGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIG5leHRDbGFzc2VzID0ge1xuICAgICAgICBcInNsaWNrLWFycm93XCI6IHRydWUsXG4gICAgICAgIFwic2xpY2stbmV4dFwiOiB0cnVlXG4gICAgICB9O1xuICAgICAgdmFyIG5leHRIYW5kbGVyID0gdGhpcy5jbGlja0hhbmRsZXIuYmluZCh0aGlzLCB7XG4gICAgICAgIG1lc3NhZ2U6IFwibmV4dFwiXG4gICAgICB9KTtcblxuICAgICAgaWYgKCEoMCwgX2lubmVyU2xpZGVyVXRpbHMuY2FuR29OZXh0KSh0aGlzLnByb3BzKSkge1xuICAgICAgICBuZXh0Q2xhc3Nlc1tcInNsaWNrLWRpc2FibGVkXCJdID0gdHJ1ZTtcbiAgICAgICAgbmV4dEhhbmRsZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dEFycm93UHJvcHMgPSB7XG4gICAgICAgIGtleTogXCIxXCIsXG4gICAgICAgIFwiZGF0YS1yb2xlXCI6IFwibm9uZVwiLFxuICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lc1tcImRlZmF1bHRcIl0pKG5leHRDbGFzc2VzKSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgICAgICAgfSxcbiAgICAgICAgb25DbGljazogbmV4dEhhbmRsZXJcbiAgICAgIH07XG4gICAgICB2YXIgY3VzdG9tUHJvcHMgPSB7XG4gICAgICAgIGN1cnJlbnRTbGlkZTogdGhpcy5wcm9wcy5jdXJyZW50U2xpZGUsXG4gICAgICAgIHNsaWRlQ291bnQ6IHRoaXMucHJvcHMuc2xpZGVDb3VudFxuICAgICAgfTtcbiAgICAgIHZhciBuZXh0QXJyb3c7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLm5leHRBcnJvdykge1xuICAgICAgICBuZXh0QXJyb3cgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jbG9uZUVsZW1lbnQodGhpcy5wcm9wcy5uZXh0QXJyb3csIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbmV4dEFycm93UHJvcHMpLCBjdXN0b21Qcm9wcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEFycm93ID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfZXh0ZW5kcyh7XG4gICAgICAgICAga2V5OiBcIjFcIixcbiAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiXG4gICAgICAgIH0sIG5leHRBcnJvd1Byb3BzKSwgXCIgXCIsIFwiTmV4dFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHRBcnJvdztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTmV4dEFycm93O1xufShfcmVhY3RbXCJkZWZhdWx0XCJdLlB1cmVDb21wb25lbnQpO1xuXG5leHBvcnRzLk5leHRBcnJvdyA9IE5leHRBcnJvdzsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlByZXZBcnJvdyIsIk5leHRBcnJvdyIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2NsYXNzbmFtZXMiLCJfaW5uZXJTbGlkZXJVdGlscyIsIl9fZXNNb2R1bGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJvIiwicCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2NyZWF0ZVN1cGVyIiwiRGVyaXZlZCIsImhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NyZWF0ZVN1cGVySW50ZXJuYWwiLCJTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsInJlc3VsdCIsIk5ld1RhcmdldCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwidmFsdWVPZiIsImUiLCJnZXRQcm90b3R5cGVPZiIsIl9SZWFjdCRQdXJlQ29tcG9uZW50IiwiX3N1cGVyIiwiY2xpY2tIYW5kbGVyIiwib3B0aW9ucyIsInByZXZlbnREZWZhdWx0IiwicmVuZGVyIiwicHJldkNsYXNzZXMiLCJwcmV2SGFuZGxlciIsImJpbmQiLCJtZXNzYWdlIiwiaW5maW5pdGUiLCJjdXJyZW50U2xpZGUiLCJzbGlkZUNvdW50Iiwic2xpZGVzVG9TaG93IiwicHJldkFycm93UHJvcHMiLCJjbGFzc05hbWUiLCJzdHlsZSIsImRpc3BsYXkiLCJvbkNsaWNrIiwiY3VzdG9tUHJvcHMiLCJwcmV2QXJyb3ciLCJjbG9uZUVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidHlwZSIsIlB1cmVDb21wb25lbnQiLCJfUmVhY3QkUHVyZUNvbXBvbmVudDIiLCJfc3VwZXIyIiwibmV4dENsYXNzZXMiLCJuZXh0SGFuZGxlciIsImNhbkdvTmV4dCIsIm5leHRBcnJvd1Byb3BzIiwibmV4dEFycm93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-slick/lib/arrows.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-slick/lib/default-props.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-slick/lib/default-props.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nvar defaultProps = {\n    accessibility: true,\n    adaptiveHeight: false,\n    afterChange: null,\n    appendDots: function appendDots(dots) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"ul\", {\n            style: {\n                display: \"block\"\n            }\n        }, dots);\n    },\n    arrows: true,\n    autoplay: false,\n    autoplaySpeed: 3000,\n    beforeChange: null,\n    centerMode: false,\n    centerPadding: \"50px\",\n    className: \"\",\n    cssEase: \"ease\",\n    customPaging: function customPaging(i) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(\"button\", null, i + 1);\n    },\n    dots: false,\n    dotsClass: \"slick-dots\",\n    draggable: true,\n    easing: \"linear\",\n    edgeFriction: 0.35,\n    fade: false,\n    focusOnSelect: false,\n    infinite: true,\n    initialSlide: 0,\n    lazyLoad: null,\n    nextArrow: null,\n    onEdge: null,\n    onInit: null,\n    onLazyLoadError: null,\n    onReInit: null,\n    pauseOnDotsHover: false,\n    pauseOnFocus: false,\n    pauseOnHover: true,\n    prevArrow: null,\n    responsive: null,\n    rows: 1,\n    rtl: false,\n    slide: \"div\",\n    slidesPerRow: 1,\n    slidesToScroll: 1,\n    slidesToShow: 1,\n    speed: 500,\n    swipe: true,\n    swipeEvent: null,\n    swipeToSlide: false,\n    touchMove: true,\n    touchThreshold: 5,\n    useCSS: true,\n    useTransform: true,\n    variableWidth: false,\n    vertical: false,\n    waitForAnimate: true\n};\nvar _default = defaultProps;\nexports[\"default\"] = _default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL2RlZmF1bHQtcHJvcHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFrQixHQUFHLEtBQUs7QUFFMUIsSUFBSUUsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyx3R0FBTztBQUVuRCxTQUFTRCx1QkFBdUJFLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFFaEcsSUFBSUUsZUFBZTtJQUNqQkMsZUFBZTtJQUNmQyxnQkFBZ0I7SUFDaEJDLGFBQWE7SUFDYkMsWUFBWSxTQUFTQSxXQUFXQyxJQUFJO1FBQ2xDLE9BQU8sV0FBVyxHQUFFVixNQUFNLENBQUMsVUFBVSxDQUFDVyxhQUFhLENBQUMsTUFBTTtZQUN4REMsT0FBTztnQkFDTEMsU0FBUztZQUNYO1FBQ0YsR0FBR0g7SUFDTDtJQUNBSSxRQUFRO0lBQ1JDLFVBQVU7SUFDVkMsZUFBZTtJQUNmQyxjQUFjO0lBQ2RDLFlBQVk7SUFDWkMsZUFBZTtJQUNmQyxXQUFXO0lBQ1hDLFNBQVM7SUFDVEMsY0FBYyxTQUFTQSxhQUFhQyxDQUFDO1FBQ25DLE9BQU8sV0FBVyxHQUFFdkIsTUFBTSxDQUFDLFVBQVUsQ0FBQ1csYUFBYSxDQUFDLFVBQVUsTUFBTVksSUFBSTtJQUMxRTtJQUNBYixNQUFNO0lBQ05jLFdBQVc7SUFDWEMsV0FBVztJQUNYQyxRQUFRO0lBQ1JDLGNBQWM7SUFDZEMsTUFBTTtJQUNOQyxlQUFlO0lBQ2ZDLFVBQVU7SUFDVkMsY0FBYztJQUNkQyxVQUFVO0lBQ1ZDLFdBQVc7SUFDWEMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLGlCQUFpQjtJQUNqQkMsVUFBVTtJQUNWQyxrQkFBa0I7SUFDbEJDLGNBQWM7SUFDZEMsY0FBYztJQUNkQyxXQUFXO0lBQ1hDLFlBQVk7SUFDWkMsTUFBTTtJQUNOQyxLQUFLO0lBQ0xDLE9BQU87SUFDUEMsY0FBYztJQUNkQyxnQkFBZ0I7SUFDaEJDLGNBQWM7SUFDZEMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLFlBQVk7SUFDWkMsY0FBYztJQUNkQyxXQUFXO0lBQ1hDLGdCQUFnQjtJQUNoQkMsUUFBUTtJQUNSQyxjQUFjO0lBQ2RDLGVBQWU7SUFDZkMsVUFBVTtJQUNWQyxnQkFBZ0I7QUFDbEI7QUFDQSxJQUFJQyxXQUFXdkQ7QUFDZlAsa0JBQWtCLEdBQUc4RCIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXZlcnNhbC1kZW1vLWFwcC8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvZGVmYXVsdC1wcm9wcy5qcz9jOTU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBhY2Nlc3NpYmlsaXR5OiB0cnVlLFxuICBhZGFwdGl2ZUhlaWdodDogZmFsc2UsXG4gIGFmdGVyQ2hhbmdlOiBudWxsLFxuICBhcHBlbmREb3RzOiBmdW5jdGlvbiBhcHBlbmREb3RzKGRvdHMpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInVsXCIsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgICAgfVxuICAgIH0sIGRvdHMpO1xuICB9LFxuICBhcnJvd3M6IHRydWUsXG4gIGF1dG9wbGF5OiBmYWxzZSxcbiAgYXV0b3BsYXlTcGVlZDogMzAwMCxcbiAgYmVmb3JlQ2hhbmdlOiBudWxsLFxuICBjZW50ZXJNb2RlOiBmYWxzZSxcbiAgY2VudGVyUGFkZGluZzogXCI1MHB4XCIsXG4gIGNsYXNzTmFtZTogXCJcIixcbiAgY3NzRWFzZTogXCJlYXNlXCIsXG4gIGN1c3RvbVBhZ2luZzogZnVuY3Rpb24gY3VzdG9tUGFnaW5nKGkpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBudWxsLCBpICsgMSk7XG4gIH0sXG4gIGRvdHM6IGZhbHNlLFxuICBkb3RzQ2xhc3M6IFwic2xpY2stZG90c1wiLFxuICBkcmFnZ2FibGU6IHRydWUsXG4gIGVhc2luZzogXCJsaW5lYXJcIixcbiAgZWRnZUZyaWN0aW9uOiAwLjM1LFxuICBmYWRlOiBmYWxzZSxcbiAgZm9jdXNPblNlbGVjdDogZmFsc2UsXG4gIGluZmluaXRlOiB0cnVlLFxuICBpbml0aWFsU2xpZGU6IDAsXG4gIGxhenlMb2FkOiBudWxsLFxuICBuZXh0QXJyb3c6IG51bGwsXG4gIG9uRWRnZTogbnVsbCxcbiAgb25Jbml0OiBudWxsLFxuICBvbkxhenlMb2FkRXJyb3I6IG51bGwsXG4gIG9uUmVJbml0OiBudWxsLFxuICBwYXVzZU9uRG90c0hvdmVyOiBmYWxzZSxcbiAgcGF1c2VPbkZvY3VzOiBmYWxzZSxcbiAgcGF1c2VPbkhvdmVyOiB0cnVlLFxuICBwcmV2QXJyb3c6IG51bGwsXG4gIHJlc3BvbnNpdmU6IG51bGwsXG4gIHJvd3M6IDEsXG4gIHJ0bDogZmFsc2UsXG4gIHNsaWRlOiBcImRpdlwiLFxuICBzbGlkZXNQZXJSb3c6IDEsXG4gIHNsaWRlc1RvU2Nyb2xsOiAxLFxuICBzbGlkZXNUb1Nob3c6IDEsXG4gIHNwZWVkOiA1MDAsXG4gIHN3aXBlOiB0cnVlLFxuICBzd2lwZUV2ZW50OiBudWxsLFxuICBzd2lwZVRvU2xpZGU6IGZhbHNlLFxuICB0b3VjaE1vdmU6IHRydWUsXG4gIHRvdWNoVGhyZXNob2xkOiA1LFxuICB1c2VDU1M6IHRydWUsXG4gIHVzZVRyYW5zZm9ybTogdHJ1ZSxcbiAgdmFyaWFibGVXaWR0aDogZmFsc2UsXG4gIHZlcnRpY2FsOiBmYWxzZSxcbiAgd2FpdEZvckFuaW1hdGU6IHRydWVcbn07XG52YXIgX2RlZmF1bHQgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHRQcm9wcyIsImFjY2Vzc2liaWxpdHkiLCJhZGFwdGl2ZUhlaWdodCIsImFmdGVyQ2hhbmdlIiwiYXBwZW5kRG90cyIsImRvdHMiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJkaXNwbGF5IiwiYXJyb3dzIiwiYXV0b3BsYXkiLCJhdXRvcGxheVNwZWVkIiwiYmVmb3JlQ2hhbmdlIiwiY2VudGVyTW9kZSIsImNlbnRlclBhZGRpbmciLCJjbGFzc05hbWUiLCJjc3NFYXNlIiwiY3VzdG9tUGFnaW5nIiwiaSIsImRvdHNDbGFzcyIsImRyYWdnYWJsZSIsImVhc2luZyIsImVkZ2VGcmljdGlvbiIsImZhZGUiLCJmb2N1c09uU2VsZWN0IiwiaW5maW5pdGUiLCJpbml0aWFsU2xpZGUiLCJsYXp5TG9hZCIsIm5leHRBcnJvdyIsIm9uRWRnZSIsIm9uSW5pdCIsIm9uTGF6eUxvYWRFcnJvciIsIm9uUmVJbml0IiwicGF1c2VPbkRvdHNIb3ZlciIsInBhdXNlT25Gb2N1cyIsInBhdXNlT25Ib3ZlciIsInByZXZBcnJvdyIsInJlc3BvbnNpdmUiLCJyb3dzIiwicnRsIiwic2xpZGUiLCJzbGlkZXNQZXJSb3ciLCJzbGlkZXNUb1Njcm9sbCIsInNsaWRlc1RvU2hvdyIsInNwZWVkIiwic3dpcGUiLCJzd2lwZUV2ZW50Iiwic3dpcGVUb1NsaWRlIiwidG91Y2hNb3ZlIiwidG91Y2hUaHJlc2hvbGQiLCJ1c2VDU1MiLCJ1c2VUcmFuc2Zvcm0iLCJ2YXJpYWJsZVdpZHRoIiwidmVydGljYWwiLCJ3YWl0Rm9yQW5pbWF0ZSIsIl9kZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-slick/lib/default-props.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-slick/lib/dots.js":
/*!**********************************************!*\
  !*** ./node_modules/react-slick/lib/dots.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Dots = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"(ssr)/./node_modules/classnames/index.js\"));\nvar _innerSliderUtils = __webpack_require__(/*! ./utils/innerSliderUtils */ \"(ssr)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nvar getDotCount = function getDotCount(spec) {\n    var dots;\n    if (spec.infinite) {\n        dots = Math.ceil(spec.slideCount / spec.slidesToScroll);\n    } else {\n        dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;\n    }\n    return dots;\n};\nvar Dots = /*#__PURE__*/ function(_React$PureComponent) {\n    _inherits(Dots, _React$PureComponent);\n    var _super = _createSuper(Dots);\n    function Dots() {\n        _classCallCheck(this, Dots);\n        return _super.apply(this, arguments);\n    }\n    _createClass(Dots, [\n        {\n            key: \"clickHandler\",\n            value: function clickHandler(options, e) {\n                // In Autoplay the focus stays on clicked button even after transition\n                // to next slide. That only goes away by click somewhere outside\n                e.preventDefault();\n                this.props.clickHandler(options);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave, infinite = _this$props.infinite, slidesToScroll = _this$props.slidesToScroll, slidesToShow = _this$props.slidesToShow, slideCount = _this$props.slideCount, currentSlide = _this$props.currentSlide;\n                var dotCount = getDotCount({\n                    slideCount: slideCount,\n                    slidesToScroll: slidesToScroll,\n                    slidesToShow: slidesToShow,\n                    infinite: infinite\n                });\n                var mouseEvents = {\n                    onMouseEnter: onMouseEnter,\n                    onMouseOver: onMouseOver,\n                    onMouseLeave: onMouseLeave\n                };\n                var dots = [];\n                for(var i = 0; i < dotCount; i++){\n                    var _rightBound = (i + 1) * slidesToScroll - 1;\n                    var rightBound = infinite ? _rightBound : (0, _innerSliderUtils.clamp)(_rightBound, 0, slideCount - 1);\n                    var _leftBound = rightBound - (slidesToScroll - 1);\n                    var leftBound = infinite ? _leftBound : (0, _innerSliderUtils.clamp)(_leftBound, 0, slideCount - 1);\n                    var className = (0, _classnames[\"default\"])({\n                        \"slick-active\": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound\n                    });\n                    var dotOptions = {\n                        message: \"dots\",\n                        index: i,\n                        slidesToScroll: slidesToScroll,\n                        currentSlide: currentSlide\n                    };\n                    var onClick = this.clickHandler.bind(this, dotOptions);\n                    dots = dots.concat(/*#__PURE__*/ _react[\"default\"].createElement(\"li\", {\n                        key: i,\n                        className: className\n                    }, /*#__PURE__*/ _react[\"default\"].cloneElement(this.props.customPaging(i), {\n                        onClick: onClick\n                    })));\n                }\n                return /*#__PURE__*/ _react[\"default\"].cloneElement(this.props.appendDots(dots), _objectSpread({\n                    className: this.props.dotsClass\n                }, mouseEvents));\n            }\n        }\n    ]);\n    return Dots;\n}(_react[\"default\"].PureComponent);\nexports.Dots = Dots;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL2RvdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxHQUFHO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsR0FBRztRQUFJLE9BQU8sT0FBT0E7SUFBSyxJQUFJLFNBQVVBLEdBQUc7UUFBSSxPQUFPQSxPQUFPLGNBQWMsT0FBT0MsVUFBVUQsSUFBSUcsV0FBVyxLQUFLRixVQUFVRCxRQUFRQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFLLEdBQUdELFFBQVFDO0FBQU07QUFFL1VLLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxZQUFZLEdBQUcsS0FBSztBQUVwQixJQUFJRyxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLHdHQUFPO0FBRW5ELElBQUlDLGNBQWNGLHVCQUF1QkMsbUJBQU9BLENBQUMsNERBQVk7QUFFN0QsSUFBSUUsb0JBQW9CRixtQkFBT0EsQ0FBQyxnR0FBMEI7QUFFMUQsU0FBU0QsdUJBQXVCWCxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSWUsVUFBVSxHQUFHZixNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBRWhHLFNBQVNnQixRQUFRQyxNQUFNLEVBQUVDLGNBQWM7SUFBSSxJQUFJQyxPQUFPZCxPQUFPYyxJQUFJLENBQUNGO0lBQVMsSUFBSVosT0FBT2UscUJBQXFCLEVBQUU7UUFBRSxJQUFJQyxVQUFVaEIsT0FBT2UscUJBQXFCLENBQUNIO1FBQVNDLGtCQUFtQkcsQ0FBQUEsVUFBVUEsUUFBUUMsTUFBTSxDQUFDLFNBQVVDLEdBQUc7WUFBSSxPQUFPbEIsT0FBT21CLHdCQUF3QixDQUFDUCxRQUFRTSxLQUFLRSxVQUFVO1FBQUUsRUFBQyxHQUFJTixLQUFLTyxJQUFJLENBQUNDLEtBQUssQ0FBQ1IsTUFBTUU7SUFBVTtJQUFF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Q0wrRSxXQUFXQTtvQkFDYixHQUFHLFdBQVcsR0FBRW5HLE1BQU0sQ0FBQyxVQUFVLENBQUMyRyxZQUFZLENBQUMsSUFBSSxDQUFDdkUsS0FBSyxDQUFDd0UsWUFBWSxDQUFDeEYsSUFBSTt3QkFDekVtRixTQUFTQTtvQkFDWDtnQkFDRjtnQkFFQSxPQUFPLFdBQVcsR0FBRXZHLE1BQU0sQ0FBQyxVQUFVLENBQUMyRyxZQUFZLENBQUMsSUFBSSxDQUFDdkUsS0FBSyxDQUFDeUUsVUFBVSxDQUFDbkMsT0FBT3hELGNBQWM7b0JBQzVGaUYsV0FBVyxJQUFJLENBQUMvRCxLQUFLLENBQUMwRSxTQUFTO2dCQUNqQyxHQUFHakI7WUFDTDtRQUNGO0tBQUU7SUFFRixPQUFPOUY7QUFDVCxFQUFFQyxNQUFNLENBQUMsVUFBVSxDQUFDK0csYUFBYTtBQUVqQ2xILFlBQVksR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bml2ZXJzYWwtZGVtby1hcHAvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL2RvdHMuanM/ZWZiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Eb3RzID0gdm9pZCAwO1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX2NsYXNzbmFtZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpKTtcblxudmFyIF9pbm5lclNsaWRlclV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMvaW5uZXJTbGlkZXJVdGlsc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG52YXIgZ2V0RG90Q291bnQgPSBmdW5jdGlvbiBnZXREb3RDb3VudChzcGVjKSB7XG4gIHZhciBkb3RzO1xuXG4gIGlmIChzcGVjLmluZmluaXRlKSB7XG4gICAgZG90cyA9IE1hdGguY2VpbChzcGVjLnNsaWRlQ291bnQgLyBzcGVjLnNsaWRlc1RvU2Nyb2xsKTtcbiAgfSBlbHNlIHtcbiAgICBkb3RzID0gTWF0aC5jZWlsKChzcGVjLnNsaWRlQ291bnQgLSBzcGVjLnNsaWRlc1RvU2hvdykgLyBzcGVjLnNsaWRlc1RvU2Nyb2xsKSArIDE7XG4gIH1cblxuICByZXR1cm4gZG90cztcbn07XG5cbnZhciBEb3RzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoRG90cywgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRG90cyk7XG5cbiAgZnVuY3Rpb24gRG90cygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG90cyk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRG90cywgW3tcbiAgICBrZXk6IFwiY2xpY2tIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsaWNrSGFuZGxlcihvcHRpb25zLCBlKSB7XG4gICAgICAvLyBJbiBBdXRvcGxheSB0aGUgZm9jdXMgc3RheXMgb24gY2xpY2tlZCBidXR0b24gZXZlbiBhZnRlciB0cmFuc2l0aW9uXG4gICAgICAvLyB0byBuZXh0IHNsaWRlLiBUaGF0IG9ubHkgZ29lcyBhd2F5IGJ5IGNsaWNrIHNvbWV3aGVyZSBvdXRzaWRlXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnByb3BzLmNsaWNrSGFuZGxlcihvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgb25Nb3VzZUVudGVyID0gX3RoaXMkcHJvcHMub25Nb3VzZUVudGVyLFxuICAgICAgICAgIG9uTW91c2VPdmVyID0gX3RoaXMkcHJvcHMub25Nb3VzZU92ZXIsXG4gICAgICAgICAgb25Nb3VzZUxlYXZlID0gX3RoaXMkcHJvcHMub25Nb3VzZUxlYXZlLFxuICAgICAgICAgIGluZmluaXRlID0gX3RoaXMkcHJvcHMuaW5maW5pdGUsXG4gICAgICAgICAgc2xpZGVzVG9TY3JvbGwgPSBfdGhpcyRwcm9wcy5zbGlkZXNUb1Njcm9sbCxcbiAgICAgICAgICBzbGlkZXNUb1Nob3cgPSBfdGhpcyRwcm9wcy5zbGlkZXNUb1Nob3csXG4gICAgICAgICAgc2xpZGVDb3VudCA9IF90aGlzJHByb3BzLnNsaWRlQ291bnQsXG4gICAgICAgICAgY3VycmVudFNsaWRlID0gX3RoaXMkcHJvcHMuY3VycmVudFNsaWRlO1xuICAgICAgdmFyIGRvdENvdW50ID0gZ2V0RG90Q291bnQoe1xuICAgICAgICBzbGlkZUNvdW50OiBzbGlkZUNvdW50LFxuICAgICAgICBzbGlkZXNUb1Njcm9sbDogc2xpZGVzVG9TY3JvbGwsXG4gICAgICAgIHNsaWRlc1RvU2hvdzogc2xpZGVzVG9TaG93LFxuICAgICAgICBpbmZpbml0ZTogaW5maW5pdGVcbiAgICAgIH0pO1xuICAgICAgdmFyIG1vdXNlRXZlbnRzID0ge1xuICAgICAgICBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlcixcbiAgICAgICAgb25Nb3VzZU92ZXI6IG9uTW91c2VPdmVyLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IG9uTW91c2VMZWF2ZVxuICAgICAgfTtcbiAgICAgIHZhciBkb3RzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG90Q291bnQ7IGkrKykge1xuICAgICAgICB2YXIgX3JpZ2h0Qm91bmQgPSAoaSArIDEpICogc2xpZGVzVG9TY3JvbGwgLSAxO1xuXG4gICAgICAgIHZhciByaWdodEJvdW5kID0gaW5maW5pdGUgPyBfcmlnaHRCb3VuZCA6ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5jbGFtcCkoX3JpZ2h0Qm91bmQsIDAsIHNsaWRlQ291bnQgLSAxKTtcblxuICAgICAgICB2YXIgX2xlZnRCb3VuZCA9IHJpZ2h0Qm91bmQgLSAoc2xpZGVzVG9TY3JvbGwgLSAxKTtcblxuICAgICAgICB2YXIgbGVmdEJvdW5kID0gaW5maW5pdGUgPyBfbGVmdEJvdW5kIDogKDAsIF9pbm5lclNsaWRlclV0aWxzLmNsYW1wKShfbGVmdEJvdW5kLCAwLCBzbGlkZUNvdW50IC0gMSk7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAoMCwgX2NsYXNzbmFtZXNbXCJkZWZhdWx0XCJdKSh7XG4gICAgICAgICAgXCJzbGljay1hY3RpdmVcIjogaW5maW5pdGUgPyBjdXJyZW50U2xpZGUgPj0gbGVmdEJvdW5kICYmIGN1cnJlbnRTbGlkZSA8PSByaWdodEJvdW5kIDogY3VycmVudFNsaWRlID09PSBsZWZ0Qm91bmRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkb3RPcHRpb25zID0ge1xuICAgICAgICAgIG1lc3NhZ2U6IFwiZG90c1wiLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiBzbGlkZXNUb1Njcm9sbCxcbiAgICAgICAgICBjdXJyZW50U2xpZGU6IGN1cnJlbnRTbGlkZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgb25DbGljayA9IHRoaXMuY2xpY2tIYW5kbGVyLmJpbmQodGhpcywgZG90T3B0aW9ucyk7XG4gICAgICAgIGRvdHMgPSBkb3RzLmNvbmNhdCggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImxpXCIsIHtcbiAgICAgICAgICBrZXk6IGksXG4gICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KHRoaXMucHJvcHMuY3VzdG9tUGFnaW5nKGkpLCB7XG4gICAgICAgICAgb25DbGljazogb25DbGlja1xuICAgICAgICB9KSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KHRoaXMucHJvcHMuYXBwZW5kRG90cyhkb3RzKSwgX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5kb3RzQ2xhc3NcbiAgICAgIH0sIG1vdXNlRXZlbnRzKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERvdHM7XG59KF9yZWFjdFtcImRlZmF1bHRcIl0uUHVyZUNvbXBvbmVudCk7XG5cbmV4cG9ydHMuRG90cyA9IERvdHM7Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJEb3RzIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfY2xhc3NuYW1lcyIsIl9pbm5lclNsaWRlclV0aWxzIiwiX19lc01vZHVsZSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwiZm9yRWFjaCIsImtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJvIiwicCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2NyZWF0ZVN1cGVyIiwiRGVyaXZlZCIsImhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NyZWF0ZVN1cGVySW50ZXJuYWwiLCJTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsInJlc3VsdCIsIk5ld1RhcmdldCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJjYWxsIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInZhbHVlT2YiLCJlIiwiZ2V0UHJvdG90eXBlT2YiLCJnZXREb3RDb3VudCIsInNwZWMiLCJkb3RzIiwiaW5maW5pdGUiLCJNYXRoIiwiY2VpbCIsInNsaWRlQ291bnQiLCJzbGlkZXNUb1Njcm9sbCIsInNsaWRlc1RvU2hvdyIsIl9SZWFjdCRQdXJlQ29tcG9uZW50IiwiX3N1cGVyIiwiY2xpY2tIYW5kbGVyIiwib3B0aW9ucyIsInByZXZlbnREZWZhdWx0IiwicmVuZGVyIiwiX3RoaXMkcHJvcHMiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlT3ZlciIsIm9uTW91c2VMZWF2ZSIsImN1cnJlbnRTbGlkZSIsImRvdENvdW50IiwibW91c2VFdmVudHMiLCJfcmlnaHRCb3VuZCIsInJpZ2h0Qm91bmQiLCJjbGFtcCIsIl9sZWZ0Qm91bmQiLCJsZWZ0Qm91bmQiLCJjbGFzc05hbWUiLCJkb3RPcHRpb25zIiwibWVzc2FnZSIsImluZGV4Iiwib25DbGljayIsImJpbmQiLCJjb25jYXQiLCJjcmVhdGVFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiY3VzdG9tUGFnaW5nIiwiYXBwZW5kRG90cyIsImRvdHNDbGFzcyIsIlB1cmVDb21wb25lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-slick/lib/dots.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-slick/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/react-slick/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _slider = _interopRequireDefault(__webpack_require__(/*! ./slider */ \"(ssr)/./node_modules/react-slick/lib/slider.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nvar _default = _slider[\"default\"];\nexports[\"default\"] = _default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxrQkFBa0IsR0FBRyxLQUFLO0FBRTFCLElBQUlFLFVBQVVDLHVCQUF1QkMsbUJBQU9BLENBQUMsZ0VBQVU7QUFFdkQsU0FBU0QsdUJBQXVCRSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBRWhHLElBQUlFLFdBQVdMLE9BQU8sQ0FBQyxVQUFVO0FBQ2pDRixrQkFBa0IsR0FBR08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bml2ZXJzYWwtZGVtby1hcHAvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL2luZGV4LmpzP2EwNzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9zbGlkZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3NsaWRlclwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG52YXIgX2RlZmF1bHQgPSBfc2xpZGVyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX3NsaWRlciIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwib2JqIiwiX19lc01vZHVsZSIsIl9kZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-slick/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-slick/lib/initial-state.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-slick/lib/initial-state.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar initialState = {\n    animating: false,\n    autoplaying: null,\n    currentDirection: 0,\n    currentLeft: null,\n    currentSlide: 0,\n    direction: 1,\n    dragging: false,\n    edgeDragged: false,\n    initialized: false,\n    lazyLoadedList: [],\n    listHeight: null,\n    listWidth: null,\n    scrolling: false,\n    slideCount: null,\n    slideHeight: null,\n    slideWidth: null,\n    swipeLeft: null,\n    swiped: false,\n    // used by swipeEvent. differentites between touch and swipe.\n    swiping: false,\n    touchObject: {\n        startX: 0,\n        startY: 0,\n        curX: 0,\n        curY: 0\n    },\n    trackStyle: {},\n    trackWidth: 0,\n    targetSlide: 0\n};\nvar _default = initialState;\nexports[\"default\"] = _default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL2luaXRpYWwtc3RhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFrQixHQUFHLEtBQUs7QUFDMUIsSUFBSUUsZUFBZTtJQUNqQkMsV0FBVztJQUNYQyxhQUFhO0lBQ2JDLGtCQUFrQjtJQUNsQkMsYUFBYTtJQUNiQyxjQUFjO0lBQ2RDLFdBQVc7SUFDWEMsVUFBVTtJQUNWQyxhQUFhO0lBQ2JDLGFBQWE7SUFDYkMsZ0JBQWdCLEVBQUU7SUFDbEJDLFlBQVk7SUFDWkMsV0FBVztJQUNYQyxXQUFXO0lBQ1hDLFlBQVk7SUFDWkMsYUFBYTtJQUNiQyxZQUFZO0lBQ1pDLFdBQVc7SUFDWEMsUUFBUTtJQUNSLDZEQUE2RDtJQUM3REMsU0FBUztJQUNUQyxhQUFhO1FBQ1hDLFFBQVE7UUFDUkMsUUFBUTtRQUNSQyxNQUFNO1FBQ05DLE1BQU07SUFDUjtJQUNBQyxZQUFZLENBQUM7SUFDYkMsWUFBWTtJQUNaQyxhQUFhO0FBQ2Y7QUFDQSxJQUFJQyxXQUFXNUI7QUFDZkYsa0JBQWtCLEdBQUc4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXZlcnNhbC1kZW1vLWFwcC8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvaW5pdGlhbC1zdGF0ZS5qcz82MzU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG52YXIgaW5pdGlhbFN0YXRlID0ge1xuICBhbmltYXRpbmc6IGZhbHNlLFxuICBhdXRvcGxheWluZzogbnVsbCxcbiAgY3VycmVudERpcmVjdGlvbjogMCxcbiAgY3VycmVudExlZnQ6IG51bGwsXG4gIGN1cnJlbnRTbGlkZTogMCxcbiAgZGlyZWN0aW9uOiAxLFxuICBkcmFnZ2luZzogZmFsc2UsXG4gIGVkZ2VEcmFnZ2VkOiBmYWxzZSxcbiAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICBsYXp5TG9hZGVkTGlzdDogW10sXG4gIGxpc3RIZWlnaHQ6IG51bGwsXG4gIGxpc3RXaWR0aDogbnVsbCxcbiAgc2Nyb2xsaW5nOiBmYWxzZSxcbiAgc2xpZGVDb3VudDogbnVsbCxcbiAgc2xpZGVIZWlnaHQ6IG51bGwsXG4gIHNsaWRlV2lkdGg6IG51bGwsXG4gIHN3aXBlTGVmdDogbnVsbCxcbiAgc3dpcGVkOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBzd2lwZUV2ZW50LiBkaWZmZXJlbnRpdGVzIGJldHdlZW4gdG91Y2ggYW5kIHN3aXBlLlxuICBzd2lwaW5nOiBmYWxzZSxcbiAgdG91Y2hPYmplY3Q6IHtcbiAgICBzdGFydFg6IDAsXG4gICAgc3RhcnRZOiAwLFxuICAgIGN1clg6IDAsXG4gICAgY3VyWTogMFxuICB9LFxuICB0cmFja1N0eWxlOiB7fSxcbiAgdHJhY2tXaWR0aDogMCxcbiAgdGFyZ2V0U2xpZGU6IDBcbn07XG52YXIgX2RlZmF1bHQgPSBpbml0aWFsU3RhdGU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImluaXRpYWxTdGF0ZSIsImFuaW1hdGluZyIsImF1dG9wbGF5aW5nIiwiY3VycmVudERpcmVjdGlvbiIsImN1cnJlbnRMZWZ0IiwiY3VycmVudFNsaWRlIiwiZGlyZWN0aW9uIiwiZHJhZ2dpbmciLCJlZGdlRHJhZ2dlZCIsImluaXRpYWxpemVkIiwibGF6eUxvYWRlZExpc3QiLCJsaXN0SGVpZ2h0IiwibGlzdFdpZHRoIiwic2Nyb2xsaW5nIiwic2xpZGVDb3VudCIsInNsaWRlSGVpZ2h0Iiwic2xpZGVXaWR0aCIsInN3aXBlTGVmdCIsInN3aXBlZCIsInN3aXBpbmciLCJ0b3VjaE9iamVjdCIsInN0YXJ0WCIsInN0YXJ0WSIsImN1clgiLCJjdXJZIiwidHJhY2tTdHlsZSIsInRyYWNrV2lkdGgiLCJ0YXJnZXRTbGlkZSIsIl9kZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-slick/lib/initial-state.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-slick/lib/inner-slider.js":
/*!******************************************************!*\
  !*** ./node_modules/react-slick/lib/inner-slider.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InnerSlider = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _initialState = _interopRequireDefault(__webpack_require__(/*! ./initial-state */ \"(ssr)/./node_modules/react-slick/lib/initial-state.js\"));\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash.debounce */ \"(ssr)/./node_modules/lodash.debounce/index.js\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"(ssr)/./node_modules/classnames/index.js\"));\nvar _innerSliderUtils = __webpack_require__(/*! ./utils/innerSliderUtils */ \"(ssr)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\");\nvar _track = __webpack_require__(/*! ./track */ \"(ssr)/./node_modules/react-slick/lib/track.js\");\nvar _dots = __webpack_require__(/*! ./dots */ \"(ssr)/./node_modules/react-slick/lib/dots.js\");\nvar _arrows = __webpack_require__(/*! ./arrows */ \"(ssr)/./node_modules/react-slick/lib/arrows.js\");\nvar _resizeObserverPolyfill = _interopRequireDefault(__webpack_require__(/*! resize-observer-polyfill */ \"(ssr)/./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nvar InnerSlider = /*#__PURE__*/ function(_React$Component) {\n    _inherits(InnerSlider, _React$Component);\n    var _super = _createSuper(InnerSlider);\n    function InnerSlider(props) {\n        var _this;\n        _classCallCheck(this, InnerSlider);\n        _this = _super.call(this, props);\n        _defineProperty(_assertThisInitialized(_this), \"listRefHandler\", function(ref) {\n            return _this.list = ref;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"trackRefHandler\", function(ref) {\n            return _this.track = ref;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"adaptHeight\", function() {\n            if (_this.props.adaptiveHeight && _this.list) {\n                var elem = _this.list.querySelector('[data-index=\"'.concat(_this.state.currentSlide, '\"]'));\n                _this.list.style.height = (0, _innerSliderUtils.getHeight)(elem) + \"px\";\n            }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"componentDidMount\", function() {\n            _this.props.onInit && _this.props.onInit();\n            if (_this.props.lazyLoad) {\n                var slidesToLoad = (0, _innerSliderUtils.getOnDemandLazySlides)(_objectSpread(_objectSpread({}, _this.props), _this.state));\n                if (slidesToLoad.length > 0) {\n                    _this.setState(function(prevState) {\n                        return {\n                            lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)\n                        };\n                    });\n                    if (_this.props.onLazyLoad) {\n                        _this.props.onLazyLoad(slidesToLoad);\n                    }\n                }\n            }\n            var spec = _objectSpread({\n                listRef: _this.list,\n                trackRef: _this.track\n            }, _this.props);\n            _this.updateState(spec, true, function() {\n                _this.adaptHeight();\n                _this.props.autoplay && _this.autoPlay(\"update\");\n            });\n            if (_this.props.lazyLoad === \"progressive\") {\n                _this.lazyLoadTimer = setInterval(_this.progressiveLazyLoad, 1000);\n            }\n            _this.ro = new _resizeObserverPolyfill[\"default\"](function() {\n                if (_this.state.animating) {\n                    _this.onWindowResized(false); // don't set trackStyle hence don't break animation\n                    _this.callbackTimers.push(setTimeout(function() {\n                        return _this.onWindowResized();\n                    }, _this.props.speed));\n                } else {\n                    _this.onWindowResized();\n                }\n            });\n            _this.ro.observe(_this.list);\n            document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(\".slick-slide\"), function(slide) {\n                slide.onfocus = _this.props.pauseOnFocus ? _this.onSlideFocus : null;\n                slide.onblur = _this.props.pauseOnFocus ? _this.onSlideBlur : null;\n            });\n            if (window.addEventListener) {\n                window.addEventListener(\"resize\", _this.onWindowResized);\n            } else {\n                window.attachEvent(\"onresize\", _this.onWindowResized);\n            }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"componentWillUnmount\", function() {\n            if (_this.animationEndCallback) {\n                clearTimeout(_this.animationEndCallback);\n            }\n            if (_this.lazyLoadTimer) {\n                clearInterval(_this.lazyLoadTimer);\n            }\n            if (_this.callbackTimers.length) {\n                _this.callbackTimers.forEach(function(timer) {\n                    return clearTimeout(timer);\n                });\n                _this.callbackTimers = [];\n            }\n            if (window.addEventListener) {\n                window.removeEventListener(\"resize\", _this.onWindowResized);\n            } else {\n                window.detachEvent(\"onresize\", _this.onWindowResized);\n            }\n            if (_this.autoplayTimer) {\n                clearInterval(_this.autoplayTimer);\n            }\n            _this.ro.disconnect();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"componentDidUpdate\", function(prevProps) {\n            _this.checkImagesLoad();\n            _this.props.onReInit && _this.props.onReInit();\n            if (_this.props.lazyLoad) {\n                var slidesToLoad = (0, _innerSliderUtils.getOnDemandLazySlides)(_objectSpread(_objectSpread({}, _this.props), _this.state));\n                if (slidesToLoad.length > 0) {\n                    _this.setState(function(prevState) {\n                        return {\n                            lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)\n                        };\n                    });\n                    if (_this.props.onLazyLoad) {\n                        _this.props.onLazyLoad(slidesToLoad);\n                    }\n                }\n            } // if (this.props.onLazyLoad) {\n            //   this.props.onLazyLoad([leftMostSlide])\n            // }\n            _this.adaptHeight();\n            var spec = _objectSpread(_objectSpread({\n                listRef: _this.list,\n                trackRef: _this.track\n            }, _this.props), _this.state);\n            var setTrackStyle = _this.didPropsChange(prevProps);\n            setTrackStyle && _this.updateState(spec, setTrackStyle, function() {\n                if (_this.state.currentSlide >= _react[\"default\"].Children.count(_this.props.children)) {\n                    _this.changeSlide({\n                        message: \"index\",\n                        index: _react[\"default\"].Children.count(_this.props.children) - _this.props.slidesToShow,\n                        currentSlide: _this.state.currentSlide\n                    });\n                }\n                if (_this.props.autoplay) {\n                    _this.autoPlay(\"update\");\n                } else {\n                    _this.pause(\"paused\");\n                }\n            });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onWindowResized\", function(setTrackStyle) {\n            if (_this.debouncedResize) _this.debouncedResize.cancel();\n            _this.debouncedResize = (0, _lodash[\"default\"])(function() {\n                return _this.resizeWindow(setTrackStyle);\n            }, 50);\n            _this.debouncedResize();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"resizeWindow\", function() {\n            var setTrackStyle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            var isTrackMounted = Boolean(_this.track && _this.track.node); // prevent warning: setting state on unmounted component (server side rendering)\n            if (!isTrackMounted) return;\n            var spec = _objectSpread(_objectSpread({\n                listRef: _this.list,\n                trackRef: _this.track\n            }, _this.props), _this.state);\n            _this.updateState(spec, setTrackStyle, function() {\n                if (_this.props.autoplay) _this.autoPlay(\"update\");\n                else _this.pause(\"paused\");\n            }); // animating state should be cleared while resizing, otherwise autoplay stops working\n            _this.setState({\n                animating: false\n            });\n            clearTimeout(_this.animationEndCallback);\n            delete _this.animationEndCallback;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"updateState\", function(spec, setTrackStyle, callback) {\n            var updatedState = (0, _innerSliderUtils.initializedState)(spec);\n            spec = _objectSpread(_objectSpread(_objectSpread({}, spec), updatedState), {}, {\n                slideIndex: updatedState.currentSlide\n            });\n            var targetLeft = (0, _innerSliderUtils.getTrackLeft)(spec);\n            spec = _objectSpread(_objectSpread({}, spec), {}, {\n                left: targetLeft\n            });\n            var trackStyle = (0, _innerSliderUtils.getTrackCSS)(spec);\n            if (setTrackStyle || _react[\"default\"].Children.count(_this.props.children) !== _react[\"default\"].Children.count(spec.children)) {\n                updatedState[\"trackStyle\"] = trackStyle;\n            }\n            _this.setState(updatedState, callback);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"ssrInit\", function() {\n            if (_this.props.variableWidth) {\n                var _trackWidth = 0, _trackLeft = 0;\n                var childrenWidths = [];\n                var preClones = (0, _innerSliderUtils.getPreClones)(_objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n                    slideCount: _this.props.children.length\n                }));\n                var postClones = (0, _innerSliderUtils.getPostClones)(_objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n                    slideCount: _this.props.children.length\n                }));\n                _this.props.children.forEach(function(child) {\n                    childrenWidths.push(child.props.style.width);\n                    _trackWidth += child.props.style.width;\n                });\n                for(var i = 0; i < preClones; i++){\n                    _trackLeft += childrenWidths[childrenWidths.length - 1 - i];\n                    _trackWidth += childrenWidths[childrenWidths.length - 1 - i];\n                }\n                for(var _i = 0; _i < postClones; _i++){\n                    _trackWidth += childrenWidths[_i];\n                }\n                for(var _i2 = 0; _i2 < _this.state.currentSlide; _i2++){\n                    _trackLeft += childrenWidths[_i2];\n                }\n                var _trackStyle = {\n                    width: _trackWidth + \"px\",\n                    left: -_trackLeft + \"px\"\n                };\n                if (_this.props.centerMode) {\n                    var currentWidth = \"\".concat(childrenWidths[_this.state.currentSlide], \"px\");\n                    _trackStyle.left = \"calc(\".concat(_trackStyle.left, \" + (100% - \").concat(currentWidth, \") / 2 ) \");\n                }\n                return {\n                    trackStyle: _trackStyle\n                };\n            }\n            var childrenCount = _react[\"default\"].Children.count(_this.props.children);\n            var spec = _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n                slideCount: childrenCount\n            });\n            var slideCount = (0, _innerSliderUtils.getPreClones)(spec) + (0, _innerSliderUtils.getPostClones)(spec) + childrenCount;\n            var trackWidth = 100 / _this.props.slidesToShow * slideCount;\n            var slideWidth = 100 / slideCount;\n            var trackLeft = -slideWidth * ((0, _innerSliderUtils.getPreClones)(spec) + _this.state.currentSlide) * trackWidth / 100;\n            if (_this.props.centerMode) {\n                trackLeft += (100 - slideWidth * trackWidth / 100) / 2;\n            }\n            var trackStyle = {\n                width: trackWidth + \"%\",\n                left: trackLeft + \"%\"\n            };\n            return {\n                slideWidth: slideWidth + \"%\",\n                trackStyle: trackStyle\n            };\n        });\n        _defineProperty(_assertThisInitialized(_this), \"checkImagesLoad\", function() {\n            var images = _this.list && _this.list.querySelectorAll && _this.list.querySelectorAll(\".slick-slide img\") || [];\n            var imagesCount = images.length, loadedCount = 0;\n            Array.prototype.forEach.call(images, function(image) {\n                var handler = function handler() {\n                    return ++loadedCount && loadedCount >= imagesCount && _this.onWindowResized();\n                };\n                if (!image.onclick) {\n                    image.onclick = function() {\n                        return image.parentNode.focus();\n                    };\n                } else {\n                    var prevClickHandler = image.onclick;\n                    image.onclick = function() {\n                        prevClickHandler();\n                        image.parentNode.focus();\n                    };\n                }\n                if (!image.onload) {\n                    if (_this.props.lazyLoad) {\n                        image.onload = function() {\n                            _this.adaptHeight();\n                            _this.callbackTimers.push(setTimeout(_this.onWindowResized, _this.props.speed));\n                        };\n                    } else {\n                        image.onload = handler;\n                        image.onerror = function() {\n                            handler();\n                            _this.props.onLazyLoadError && _this.props.onLazyLoadError();\n                        };\n                    }\n                }\n            });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"progressiveLazyLoad\", function() {\n            var slidesToLoad = [];\n            var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);\n            for(var index = _this.state.currentSlide; index < _this.state.slideCount + (0, _innerSliderUtils.getPostClones)(spec); index++){\n                if (_this.state.lazyLoadedList.indexOf(index) < 0) {\n                    slidesToLoad.push(index);\n                    break;\n                }\n            }\n            for(var _index = _this.state.currentSlide - 1; _index >= -(0, _innerSliderUtils.getPreClones)(spec); _index--){\n                if (_this.state.lazyLoadedList.indexOf(_index) < 0) {\n                    slidesToLoad.push(_index);\n                    break;\n                }\n            }\n            if (slidesToLoad.length > 0) {\n                _this.setState(function(state) {\n                    return {\n                        lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad)\n                    };\n                });\n                if (_this.props.onLazyLoad) {\n                    _this.props.onLazyLoad(slidesToLoad);\n                }\n            } else {\n                if (_this.lazyLoadTimer) {\n                    clearInterval(_this.lazyLoadTimer);\n                    delete _this.lazyLoadTimer;\n                }\n            }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slideHandler\", function(index) {\n            var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n            var _this$props = _this.props, asNavFor = _this$props.asNavFor, beforeChange = _this$props.beforeChange, onLazyLoad = _this$props.onLazyLoad, speed = _this$props.speed, afterChange = _this$props.afterChange; // capture currentslide before state is updated\n            var currentSlide = _this.state.currentSlide;\n            var _slideHandler = (0, _innerSliderUtils.slideHandler)(_objectSpread(_objectSpread(_objectSpread({\n                index: index\n            }, _this.props), _this.state), {}, {\n                trackRef: _this.track,\n                useCSS: _this.props.useCSS && !dontAnimate\n            })), state = _slideHandler.state, nextState = _slideHandler.nextState;\n            if (!state) return;\n            beforeChange && beforeChange(currentSlide, state.currentSlide);\n            var slidesToLoad = state.lazyLoadedList.filter(function(value) {\n                return _this.state.lazyLoadedList.indexOf(value) < 0;\n            });\n            onLazyLoad && slidesToLoad.length > 0 && onLazyLoad(slidesToLoad);\n            if (!_this.props.waitForAnimate && _this.animationEndCallback) {\n                clearTimeout(_this.animationEndCallback);\n                afterChange && afterChange(currentSlide);\n                delete _this.animationEndCallback;\n            }\n            _this.setState(state, function() {\n                // asNavForIndex check is to avoid recursive calls of slideHandler in waitForAnimate=false mode\n                if (asNavFor && _this.asNavForIndex !== index) {\n                    _this.asNavForIndex = index;\n                    asNavFor.innerSlider.slideHandler(index);\n                }\n                if (!nextState) return;\n                _this.animationEndCallback = setTimeout(function() {\n                    var animating = nextState.animating, firstBatch = _objectWithoutProperties(nextState, [\n                        \"animating\"\n                    ]);\n                    _this.setState(firstBatch, function() {\n                        _this.callbackTimers.push(setTimeout(function() {\n                            return _this.setState({\n                                animating: animating\n                            });\n                        }, 10));\n                        afterChange && afterChange(state.currentSlide);\n                        delete _this.animationEndCallback;\n                    });\n                }, speed);\n            });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"changeSlide\", function(options) {\n            var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n            var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);\n            var targetSlide = (0, _innerSliderUtils.changeSlide)(spec, options);\n            if (targetSlide !== 0 && !targetSlide) return;\n            if (dontAnimate === true) {\n                _this.slideHandler(targetSlide, dontAnimate);\n            } else {\n                _this.slideHandler(targetSlide);\n            }\n            _this.props.autoplay && _this.autoPlay(\"update\");\n            if (_this.props.focusOnSelect) {\n                var nodes = _this.list.querySelectorAll(\".slick-current\");\n                nodes[0] && nodes[0].focus();\n            }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"clickHandler\", function(e) {\n            if (_this.clickable === false) {\n                e.stopPropagation();\n                e.preventDefault();\n            }\n            _this.clickable = true;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"keyHandler\", function(e) {\n            var dir = (0, _innerSliderUtils.keyHandler)(e, _this.props.accessibility, _this.props.rtl);\n            dir !== \"\" && _this.changeSlide({\n                message: dir\n            });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"selectHandler\", function(options) {\n            _this.changeSlide(options);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"disableBodyScroll\", function() {\n            var preventDefault = function preventDefault(e) {\n                e = e || window.event;\n                if (e.preventDefault) e.preventDefault();\n                e.returnValue = false;\n            };\n            window.ontouchmove = preventDefault;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"enableBodyScroll\", function() {\n            window.ontouchmove = null;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"swipeStart\", function(e) {\n            if (_this.props.verticalSwiping) {\n                _this.disableBodyScroll();\n            }\n            var state = (0, _innerSliderUtils.swipeStart)(e, _this.props.swipe, _this.props.draggable);\n            state !== \"\" && _this.setState(state);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"swipeMove\", function(e) {\n            var state = (0, _innerSliderUtils.swipeMove)(e, _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n                trackRef: _this.track,\n                listRef: _this.list,\n                slideIndex: _this.state.currentSlide\n            }));\n            if (!state) return;\n            if (state[\"swiping\"]) {\n                _this.clickable = false;\n            }\n            _this.setState(state);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"swipeEnd\", function(e) {\n            var state = (0, _innerSliderUtils.swipeEnd)(e, _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n                trackRef: _this.track,\n                listRef: _this.list,\n                slideIndex: _this.state.currentSlide\n            }));\n            if (!state) return;\n            var triggerSlideHandler = state[\"triggerSlideHandler\"];\n            delete state[\"triggerSlideHandler\"];\n            _this.setState(state);\n            if (triggerSlideHandler === undefined) return;\n            _this.slideHandler(triggerSlideHandler);\n            if (_this.props.verticalSwiping) {\n                _this.enableBodyScroll();\n            }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"touchEnd\", function(e) {\n            _this.swipeEnd(e);\n            _this.clickable = true;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickPrev\", function() {\n            // this and fellow methods are wrapped in setTimeout\n            // to make sure initialize setState has happened before\n            // any of such methods are called\n            _this.callbackTimers.push(setTimeout(function() {\n                return _this.changeSlide({\n                    message: \"previous\"\n                });\n            }, 0));\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickNext\", function() {\n            _this.callbackTimers.push(setTimeout(function() {\n                return _this.changeSlide({\n                    message: \"next\"\n                });\n            }, 0));\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickGoTo\", function(slide) {\n            var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n            slide = Number(slide);\n            if (isNaN(slide)) return \"\";\n            _this.callbackTimers.push(setTimeout(function() {\n                return _this.changeSlide({\n                    message: \"index\",\n                    index: slide,\n                    currentSlide: _this.state.currentSlide\n                }, dontAnimate);\n            }, 0));\n        });\n        _defineProperty(_assertThisInitialized(_this), \"play\", function() {\n            var nextIndex;\n            if (_this.props.rtl) {\n                nextIndex = _this.state.currentSlide - _this.props.slidesToScroll;\n            } else {\n                if ((0, _innerSliderUtils.canGoNext)(_objectSpread(_objectSpread({}, _this.props), _this.state))) {\n                    nextIndex = _this.state.currentSlide + _this.props.slidesToScroll;\n                } else {\n                    return false;\n                }\n            }\n            _this.slideHandler(nextIndex);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"autoPlay\", function(playType) {\n            if (_this.autoplayTimer) {\n                clearInterval(_this.autoplayTimer);\n            }\n            var autoplaying = _this.state.autoplaying;\n            if (playType === \"update\") {\n                if (autoplaying === \"hovered\" || autoplaying === \"focused\" || autoplaying === \"paused\") {\n                    return;\n                }\n            } else if (playType === \"leave\") {\n                if (autoplaying === \"paused\" || autoplaying === \"focused\") {\n                    return;\n                }\n            } else if (playType === \"blur\") {\n                if (autoplaying === \"paused\" || autoplaying === \"hovered\") {\n                    return;\n                }\n            }\n            _this.autoplayTimer = setInterval(_this.play, _this.props.autoplaySpeed + 50);\n            _this.setState({\n                autoplaying: \"playing\"\n            });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"pause\", function(pauseType) {\n            if (_this.autoplayTimer) {\n                clearInterval(_this.autoplayTimer);\n                _this.autoplayTimer = null;\n            }\n            var autoplaying = _this.state.autoplaying;\n            if (pauseType === \"paused\") {\n                _this.setState({\n                    autoplaying: \"paused\"\n                });\n            } else if (pauseType === \"focused\") {\n                if (autoplaying === \"hovered\" || autoplaying === \"playing\") {\n                    _this.setState({\n                        autoplaying: \"focused\"\n                    });\n                }\n            } else {\n                // pauseType  is 'hovered'\n                if (autoplaying === \"playing\") {\n                    _this.setState({\n                        autoplaying: \"hovered\"\n                    });\n                }\n            }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDotsOver\", function() {\n            return _this.props.autoplay && _this.pause(\"hovered\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDotsLeave\", function() {\n            return _this.props.autoplay && _this.state.autoplaying === \"hovered\" && _this.autoPlay(\"leave\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onTrackOver\", function() {\n            return _this.props.autoplay && _this.pause(\"hovered\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onTrackLeave\", function() {\n            return _this.props.autoplay && _this.state.autoplaying === \"hovered\" && _this.autoPlay(\"leave\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onSlideFocus\", function() {\n            return _this.props.autoplay && _this.pause(\"focused\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onSlideBlur\", function() {\n            return _this.props.autoplay && _this.state.autoplaying === \"focused\" && _this.autoPlay(\"blur\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"render\", function() {\n            var className = (0, _classnames[\"default\"])(\"slick-slider\", _this.props.className, {\n                \"slick-vertical\": _this.props.vertical,\n                \"slick-initialized\": true\n            });\n            var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);\n            var trackProps = (0, _innerSliderUtils.extractObject)(spec, [\n                \"fade\",\n                \"cssEase\",\n                \"speed\",\n                \"infinite\",\n                \"centerMode\",\n                \"focusOnSelect\",\n                \"currentSlide\",\n                \"lazyLoad\",\n                \"lazyLoadedList\",\n                \"rtl\",\n                \"slideWidth\",\n                \"slideHeight\",\n                \"listHeight\",\n                \"vertical\",\n                \"slidesToShow\",\n                \"slidesToScroll\",\n                \"slideCount\",\n                \"trackStyle\",\n                \"variableWidth\",\n                \"unslick\",\n                \"centerPadding\",\n                \"targetSlide\",\n                \"useCSS\"\n            ]);\n            var pauseOnHover = _this.props.pauseOnHover;\n            trackProps = _objectSpread(_objectSpread({}, trackProps), {}, {\n                onMouseEnter: pauseOnHover ? _this.onTrackOver : null,\n                onMouseLeave: pauseOnHover ? _this.onTrackLeave : null,\n                onMouseOver: pauseOnHover ? _this.onTrackOver : null,\n                focusOnSelect: _this.props.focusOnSelect && _this.clickable ? _this.selectHandler : null\n            });\n            var dots;\n            if (_this.props.dots === true && _this.state.slideCount >= _this.props.slidesToShow) {\n                var dotProps = (0, _innerSliderUtils.extractObject)(spec, [\n                    \"dotsClass\",\n                    \"slideCount\",\n                    \"slidesToShow\",\n                    \"currentSlide\",\n                    \"slidesToScroll\",\n                    \"clickHandler\",\n                    \"children\",\n                    \"customPaging\",\n                    \"infinite\",\n                    \"appendDots\"\n                ]);\n                var pauseOnDotsHover = _this.props.pauseOnDotsHover;\n                dotProps = _objectSpread(_objectSpread({}, dotProps), {}, {\n                    clickHandler: _this.changeSlide,\n                    onMouseEnter: pauseOnDotsHover ? _this.onDotsLeave : null,\n                    onMouseOver: pauseOnDotsHover ? _this.onDotsOver : null,\n                    onMouseLeave: pauseOnDotsHover ? _this.onDotsLeave : null\n                });\n                dots = /*#__PURE__*/ _react[\"default\"].createElement(_dots.Dots, dotProps);\n            }\n            var prevArrow, nextArrow;\n            var arrowProps = (0, _innerSliderUtils.extractObject)(spec, [\n                \"infinite\",\n                \"centerMode\",\n                \"currentSlide\",\n                \"slideCount\",\n                \"slidesToShow\",\n                \"prevArrow\",\n                \"nextArrow\"\n            ]);\n            arrowProps.clickHandler = _this.changeSlide;\n            if (_this.props.arrows) {\n                prevArrow = /*#__PURE__*/ _react[\"default\"].createElement(_arrows.PrevArrow, arrowProps);\n                nextArrow = /*#__PURE__*/ _react[\"default\"].createElement(_arrows.NextArrow, arrowProps);\n            }\n            var verticalHeightStyle = null;\n            if (_this.props.vertical) {\n                verticalHeightStyle = {\n                    height: _this.state.listHeight\n                };\n            }\n            var centerPaddingStyle = null;\n            if (_this.props.vertical === false) {\n                if (_this.props.centerMode === true) {\n                    centerPaddingStyle = {\n                        padding: \"0px \" + _this.props.centerPadding\n                    };\n                }\n            } else {\n                if (_this.props.centerMode === true) {\n                    centerPaddingStyle = {\n                        padding: _this.props.centerPadding + \" 0px\"\n                    };\n                }\n            }\n            var listStyle = _objectSpread(_objectSpread({}, verticalHeightStyle), centerPaddingStyle);\n            var touchMove = _this.props.touchMove;\n            var listProps = {\n                className: \"slick-list\",\n                style: listStyle,\n                onClick: _this.clickHandler,\n                onMouseDown: touchMove ? _this.swipeStart : null,\n                onMouseMove: _this.state.dragging && touchMove ? _this.swipeMove : null,\n                onMouseUp: touchMove ? _this.swipeEnd : null,\n                onMouseLeave: _this.state.dragging && touchMove ? _this.swipeEnd : null,\n                onTouchStart: touchMove ? _this.swipeStart : null,\n                onTouchMove: _this.state.dragging && touchMove ? _this.swipeMove : null,\n                onTouchEnd: touchMove ? _this.touchEnd : null,\n                onTouchCancel: _this.state.dragging && touchMove ? _this.swipeEnd : null,\n                onKeyDown: _this.props.accessibility ? _this.keyHandler : null\n            };\n            var innerSliderProps = {\n                className: className,\n                dir: \"ltr\",\n                style: _this.props.style\n            };\n            if (_this.props.unslick) {\n                listProps = {\n                    className: \"slick-list\"\n                };\n                innerSliderProps = {\n                    className: className\n                };\n            }\n            return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", innerSliderProps, !_this.props.unslick ? prevArrow : \"\", /*#__PURE__*/ _react[\"default\"].createElement(\"div\", _extends({\n                ref: _this.listRefHandler\n            }, listProps), /*#__PURE__*/ _react[\"default\"].createElement(_track.Track, _extends({\n                ref: _this.trackRefHandler\n            }, trackProps), _this.props.children)), !_this.props.unslick ? nextArrow : \"\", !_this.props.unslick ? dots : \"\");\n        });\n        _this.list = null;\n        _this.track = null;\n        _this.state = _objectSpread(_objectSpread({}, _initialState[\"default\"]), {}, {\n            currentSlide: _this.props.initialSlide,\n            slideCount: _react[\"default\"].Children.count(_this.props.children)\n        });\n        _this.callbackTimers = [];\n        _this.clickable = true;\n        _this.debouncedResize = null;\n        var ssrState = _this.ssrInit();\n        _this.state = _objectSpread(_objectSpread({}, _this.state), ssrState);\n        return _this;\n    }\n    _createClass(InnerSlider, [\n        {\n            key: \"didPropsChange\",\n            value: function didPropsChange(prevProps) {\n                var setTrackStyle = false;\n                for(var _i3 = 0, _Object$keys = Object.keys(this.props); _i3 < _Object$keys.length; _i3++){\n                    var key = _Object$keys[_i3];\n                    if (!prevProps.hasOwnProperty(key)) {\n                        setTrackStyle = true;\n                        break;\n                    }\n                    if (_typeof(prevProps[key]) === \"object\" || typeof prevProps[key] === \"function\") {\n                        continue;\n                    }\n                    if (prevProps[key] !== this.props[key]) {\n                        setTrackStyle = true;\n                        break;\n                    }\n                }\n                return setTrackStyle || _react[\"default\"].Children.count(this.props.children) !== _react[\"default\"].Children.count(prevProps.children);\n            }\n        }\n    ]);\n    return InnerSlider;\n}(_react[\"default\"].Component);\nexports.InnerSlider = InnerSlider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL2lubmVyLXNsaWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsbUJBQW1CLEdBQUcsS0FBSztBQUUzQixJQUFJRyxTQUFTQyx1QkFBdUJDLG1CQUFPQSxDQUFDLHdHQUFPO0FBRW5ELElBQUlDLGdCQUFnQkYsdUJBQXVCQyxtQkFBT0EsQ0FBQyw4RUFBaUI7QUFFcEUsSUFBSUUsVUFBVUgsdUJBQXVCQyxtQkFBT0EsQ0FBQyxzRUFBaUI7QUFFOUQsSUFBSUcsY0FBY0osdUJBQXVCQyxtQkFBT0EsQ0FBQyw0REFBWTtBQUU3RCxJQUFJSSxvQkFBb0JKLG1CQUFPQSxDQUFDLGdHQUEwQjtBQUUxRCxJQUFJSyxTQUFTTCxtQkFBT0EsQ0FBQyw4REFBUztBQUU5QixJQUFJTSxRQUFRTixtQkFBT0EsQ0FBQyw0REFBUTtBQUU1QixJQUFJTyxVQUFVUCxtQkFBT0EsQ0FBQyxnRUFBVTtBQUVoQyxJQUFJUSwwQkFBMEJULHVCQUF1QkMsbUJBQU9BLENBQUMseUdBQTBCO0FBRXZGLFNBQVNELHVCQUF1QlUsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUVoRyxTQUFTRSxRQUFRRixHQUFHO0lBQUk7SUFBMkIsT0FBT0UsVUFBVSxjQUFjLE9BQU9DLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUosR0FBRztRQUFJLE9BQU8sT0FBT0E7SUFBSyxJQUFJLFNBQVVBLEdBQUc7UUFBSSxPQUFPQSxPQUFPLGNBQWMsT0FBT0csVUFBVUgsSUFBSUssV0FBVyxLQUFLRixVQUFVSCxRQUFRRyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPTjtJQUFLLEdBQUdFLFFBQVFGO0FBQU07QUFFL1UsU0FBU087SUFBYUEsV0FBV3ZCLE9BQU93QixNQUFNLElBQUksU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFBRSxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFBRSxJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQUUsSUFBSTdCLE9BQU9zQixTQUFTLENBQUNTLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSCxRQUFRQyxNQUFNO29CQUFFTCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUFFO1lBQUU7UUFBRTtRQUFFLE9BQU9MO0lBQVE7SUFBRyxPQUFPRixTQUFTVSxLQUFLLENBQUMsSUFBSSxFQUFFTjtBQUFZO0FBRTVULFNBQVNPLHlCQUF5QkwsTUFBTSxFQUFFTSxRQUFRO0lBQUksSUFBSU4sVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUFHLElBQUlKLFNBQVNXLDhCQUE4QlAsUUFBUU07SUFBVyxJQUFJTCxLQUFLSjtJQUFHLElBQUkxQixPQUFPcUMscUJBQXFCLEVBQUU7UUFBRSxJQUFJQyxtQkFBbUJ0QyxPQUFPcUMscUJBQXFCLENBQUNSO1FBQVMsSUFBS0gsSUFBSSxHQUFHQSxJQUFJWSxpQkFBaUJWLE1BQU0sRUFBRUYsSUFBSztZQUFFSSxNQUFNUSxnQkFBZ0IsQ0FBQ1osRUFBRTtZQUFFLElBQUlTLFNBQVNJLE9BQU8sQ0FBQ1QsUUFBUSxHQUFHO1lBQVUsSUFBSSxDQUFDOUIsT0FBT3NCLFNBQVMsQ0FBQ2tCLG9CQUFvQixDQUFDUixJQUFJLENBQUNILFFBQVFDLE1BQU07WUFBVUwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtRQUFFO0lBQUU7SUFBRSxPQUFPTDtBQUFRO0FBRTNlLFNBQVNXLDhCQUE4QlAsTUFBTSxFQUFFTSxRQUFRO0lBQUksSUFBSU4sVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUFHLElBQUlKLFNBQVMsQ0FBQztJQUFHLElBQUlnQixhQUFhekMsT0FBTzBDLElBQUksQ0FBQ2I7SUFBUyxJQUFJQyxLQUFLSjtJQUFHLElBQUtBLElBQUksR0FBR0EsSUFBSWUsV0FBV2IsTUFBTSxFQUFFRixJQUFLO1FBQUVJLE1BQU1XLFVBQVUsQ0FBQ2YsRUFBRTtRQUFFLElBQUlTLFNBQVNJLE9BQU8sQ0FBQ1QsUUFBUSxHQUFHO1FBQVVMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7SUFBRTtJQUFFLE9BQU9MO0FBQVE7QUFFbFQsU0FBU2tCLFFBQVFDLE1BQU0sRUFBRUMsY0FBYztJQUFJLElBQUlILE9BQU8xQyxPQUFPMEMsSUFBSSxDQUFDRTtJQUFTLElBQUk1QyxPQUFPcUMscUJBQXFCLEVBQUU7UUFBRSxJQUFJUyxVQUFVOUMsT0FBT3FDLHFCQUFxQixDQUFDTztRQUFTQyxrQkFBbUJDLENBQUFBLFVBQVVBLFFBQVFDLE1BQU0sQ0FBQyxTQUFVQyxHQUFHO1lBQUksT0FBT2hELE9BQU9pRCx3QkFBd0IsQ0FBQ0wsUUFBUUksS0FBS0UsVUFBVTtRQUFFLEVBQUMsR0FBSVIsS0FBS1MsSUFBSSxDQUFDbEIsS0FBSyxDQUFDUyxNQUFNSTtJQUFVO0lBQUUsT0FBT0o7QUFBTTtBQUVwVixTQUFTVSxjQUFjM0IsTUFBTTtJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7UUFBRSxJQUFJRyxTQUFTLFFBQVFGLFNBQVMsQ0FBQ0QsRUFBRSxHQUFHQyxTQUFTLENBQUNELEVBQUUsR0FBRyxDQUFDO1FBQUdBLElBQUksSUFBSWlCLFFBQVEzQyxPQUFPNkIsU0FBUyxDQUFDLEdBQUd3QixPQUFPLENBQUMsU0FBVXZCLEdBQUc7WUFBSXdCLGdCQUFnQjdCLFFBQVFLLEtBQUtELE1BQU0sQ0FBQ0MsSUFBSTtRQUFHLEtBQUs5QixPQUFPdUQseUJBQXlCLEdBQUd2RCxPQUFPd0QsZ0JBQWdCLENBQUMvQixRQUFRekIsT0FBT3VELHlCQUF5QixDQUFDMUIsV0FBV2MsUUFBUTNDLE9BQU82QixTQUFTd0IsT0FBTyxDQUFDLFNBQVV2QixHQUFHO1lBQUk5QixPQUFPQyxjQUFjLENBQUN3QixRQUFRSyxLQUFLOUIsT0FBT2lELHdCQUF3QixDQUFDcEIsUUFBUUM7UUFBTztJQUFJO0lBQUUsT0FBT0w7QUFBUTtBQUV6ZixTQUFTZ0MsZ0JBQWdCQyxRQUFRLEVBQUVDLFdBQVc7SUFBSSxJQUFJLENBQUVELENBQUFBLG9CQUFvQkMsV0FBVSxHQUFJO1FBQUUsTUFBTSxJQUFJQyxVQUFVO0lBQXNDO0FBQUU7QUFFeEosU0FBU0Msa0JBQWtCcEMsTUFBTSxFQUFFcUMsS0FBSztJQUFJLElBQUssSUFBSXBDLElBQUksR0FBR0EsSUFBSW9DLE1BQU1sQyxNQUFNLEVBQUVGLElBQUs7UUFBRSxJQUFJcUMsYUFBYUQsS0FBSyxDQUFDcEMsRUFBRTtRQUFFcUMsV0FBV2IsVUFBVSxHQUFHYSxXQUFXYixVQUFVLElBQUk7UUFBT2EsV0FBV0MsWUFBWSxHQUFHO1FBQU0sSUFBSSxXQUFXRCxZQUFZQSxXQUFXRSxRQUFRLEdBQUc7UUFBTWpFLE9BQU9DLGNBQWMsQ0FBQ3dCLFFBQVFzQyxXQUFXakMsR0FBRyxFQUFFaUM7SUFBYTtBQUFFO0FBRTVULFNBQVNHLGFBQWFQLFdBQVcsRUFBRVEsVUFBVSxFQUFFQyxXQUFXO0lBQUksSUFBSUQsWUFBWU4sa0JBQWtCRixZQUFZckMsU0FBUyxFQUFFNkM7SUFBYSxJQUFJQyxhQUFhUCxrQkFBa0JGLGFBQWFTO0lBQWNwRSxPQUFPQyxjQUFjLENBQUMwRCxhQUFhLGFBQWE7UUFBRU0sVUFBVTtJQUFNO0lBQUksT0FBT047QUFBYTtBQUU1UixTQUFTVSxVQUFVQyxRQUFRLEVBQUVDLFVBQVU7SUFBSSxJQUFJLE9BQU9BLGVBQWUsY0FBY0EsZUFBZSxNQUFNO1FBQUUsTUFBTSxJQUFJWCxVQUFVO0lBQXVEO0lBQUVVLFNBQVNoRCxTQUFTLEdBQUd0QixPQUFPd0UsTUFBTSxDQUFDRCxjQUFjQSxXQUFXakQsU0FBUyxFQUFFO1FBQUVELGFBQWE7WUFBRWxCLE9BQU9tRTtZQUFVTCxVQUFVO1lBQU1ELGNBQWM7UUFBSztJQUFFO0lBQUloRSxPQUFPQyxjQUFjLENBQUNxRSxVQUFVLGFBQWE7UUFBRUwsVUFBVTtJQUFNO0lBQUksSUFBSU0sWUFBWUUsZ0JBQWdCSCxVQUFVQztBQUFhO0FBRW5jLFNBQVNFLGdCQUFnQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQUlGLGtCQUFrQnpFLE9BQU80RSxjQUFjLElBQUksU0FBU0gsZ0JBQWdCQyxDQUFDLEVBQUVDLENBQUM7UUFBSUQsRUFBRUcsU0FBUyxHQUFHRjtRQUFHLE9BQU9EO0lBQUc7SUFBRyxPQUFPRCxnQkFBZ0JDLEdBQUdDO0FBQUk7QUFFekssU0FBU0csYUFBYUMsT0FBTztJQUFJLElBQUlDLDRCQUE0QkM7SUFBNkIsT0FBTyxTQUFTQztRQUF5QixJQUFJQyxRQUFRQyxnQkFBZ0JMLFVBQVVNO1FBQVEsSUFBSUwsMkJBQTJCO1lBQUUsSUFBSU0sWUFBWUYsZ0JBQWdCLElBQUksRUFBRS9ELFdBQVc7WUFBRWdFLFNBQVNFLFFBQVFDLFNBQVMsQ0FBQ0wsT0FBT3hELFdBQVcyRDtRQUFZLE9BQU87WUFBRUQsU0FBU0YsTUFBTWxELEtBQUssQ0FBQyxJQUFJLEVBQUVOO1FBQVk7UUFBRSxPQUFPOEQsMkJBQTJCLElBQUksRUFBRUo7SUFBUztBQUFHO0FBRXhhLFNBQVNJLDJCQUEyQkMsSUFBSSxFQUFFMUQsSUFBSTtJQUFJLElBQUlBLFFBQVNkLENBQUFBLFFBQVFjLFVBQVUsWUFBWSxPQUFPQSxTQUFTLFVBQVMsR0FBSTtRQUFFLE9BQU9BO0lBQU0sT0FBTyxJQUFJQSxTQUFTLEtBQUssR0FBRztRQUFFLE1BQU0sSUFBSTRCLFVBQVU7SUFBNkQ7SUFBRSxPQUFPK0IsdUJBQXVCRDtBQUFPO0FBRS9SLFNBQVNDLHVCQUF1QkQsSUFBSTtJQUFJLElBQUlBLFNBQVMsS0FBSyxHQUFHO1FBQUUsTUFBTSxJQUFJRSxlQUFlO0lBQThEO0lBQUUsT0FBT0Y7QUFBTTtBQUVySyxTQUFTVDtJQUE4QixJQUFJLE9BQU9NLFlBQVksZUFBZSxDQUFDQSxRQUFRQyxTQUFTLEVBQUUsT0FBTztJQUFPLElBQUlELFFBQVFDLFNBQVMsQ0FBQ0ssSUFBSSxFQUFFLE9BQU87SUFBTyxJQUFJLE9BQU9DLFVBQVUsWUFBWSxPQUFPO0lBQU0sSUFBSTtRQUFFQyxRQUFRekUsU0FBUyxDQUFDMEUsT0FBTyxDQUFDaEUsSUFBSSxDQUFDdUQsUUFBUUMsU0FBUyxDQUFDTyxTQUFTLEVBQUUsRUFBRSxZQUFhO1FBQUssT0FBTztJQUFNLEVBQUUsT0FBT0UsR0FBRztRQUFFLE9BQU87SUFBTztBQUFFO0FBRXhVLFNBQVNiLGdCQUFnQlYsQ0FBQztJQUFJVSxrQkFBa0JwRixPQUFPNEUsY0FBYyxHQUFHNUUsT0FBT2tHLGNBQWMsR0FBRyxTQUFTZCxnQkFBZ0JWLENBQUM7UUFBSSxPQUFPQSxFQUFFRyxTQUFTLElBQUk3RSxPQUFPa0csY0FBYyxDQUFDeEI7SUFBSTtJQUFHLE9BQU9VLGdCQUFnQlY7QUFBSTtBQUU1TSxTQUFTcEIsZ0JBQWdCdEMsR0FBRyxFQUFFYyxHQUFHLEVBQUUzQixLQUFLO0lBQUksSUFBSTJCLE9BQU9kLEtBQUs7UUFBRWhCLE9BQU9DLGNBQWMsQ0FBQ2UsS0FBS2MsS0FBSztZQUFFM0IsT0FBT0E7WUFBTytDLFlBQVk7WUFBTWMsY0FBYztZQUFNQyxVQUFVO1FBQUs7SUFBSSxPQUFPO1FBQUVqRCxHQUFHLENBQUNjLElBQUksR0FBRzNCO0lBQU87SUFBRSxPQUFPYTtBQUFLO0FBRWhOLElBQUlaLGNBQWMsV0FBVyxHQUFFLFNBQVUrRixnQkFBZ0I7SUFDdkQ5QixVQUFVakUsYUFBYStGO0lBRXZCLElBQUlDLFNBQVN0QixhQUFhMUU7SUFFMUIsU0FBU0EsWUFBWTBELEtBQUs7UUFDeEIsSUFBSXVDO1FBRUo1QyxnQkFBZ0IsSUFBSSxFQUFFckQ7UUFFdEJpRyxRQUFRRCxPQUFPcEUsSUFBSSxDQUFDLElBQUksRUFBRThCO1FBRTFCUixnQkFBZ0JxQyx1QkFBdUJVLFFBQVEsa0JBQWtCLFNBQVVDLEdBQUc7WUFDNUUsT0FBT0QsTUFBTUUsSUFBSSxHQUFHRDtRQUN0QjtRQUVBaEQsZ0JBQWdCcUMsdUJBQXVCVSxRQUFRLG1CQUFtQixTQUFVQyxHQUFHO1lBQzdFLE9BQU9ELE1BQU1HLEtBQUssR0FBR0Y7UUFDdkI7UUFFQWhELGdCQUFnQnFDLHVCQUF1QlUsUUFBUSxlQUFlO1lBQzVELElBQUlBLE1BQU12QyxLQUFLLENBQUMyQyxjQUFjLElBQUlKLE1BQU1FLElBQUksRUFBRTtnQkFDNUMsSUFBSUcsT0FBT0wsTUFBTUUsSUFBSSxDQUFDSSxhQUFhLENBQUMsZ0JBQWlCQyxNQUFNLENBQUNQLE1BQU1RLEtBQUssQ0FBQ0MsWUFBWSxFQUFFO2dCQUV0RlQsTUFBTUUsSUFBSSxDQUFDUSxLQUFLLENBQUNDLE1BQU0sR0FBRyxDQUFDLEdBQUdyRyxrQkFBa0JzRyxTQUFTLEVBQUVQLFFBQVE7WUFDckU7UUFDRjtRQUVBcEQsZ0JBQWdCcUMsdUJBQXVCVSxRQUFRLHFCQUFxQjtZQUNsRUEsTUFBTXZDLEtBQUssQ0FBQ29ELE1BQU0sSUFBSWIsTUFBTXZDLEtBQUssQ0FBQ29ELE1BQU07WUFFeEMsSUFBSWIsTUFBTXZDLEtBQUssQ0FBQ3FELFFBQVEsRUFBRTtnQkFDeEIsSUFBSUMsZUFBZSxDQUFDLEdBQUd6RyxrQkFBa0IwRyxxQkFBcUIsRUFBRWpFLGNBQWNBLGNBQWMsQ0FBQyxHQUFHaUQsTUFBTXZDLEtBQUssR0FBR3VDLE1BQU1RLEtBQUs7Z0JBRXpILElBQUlPLGFBQWF4RixNQUFNLEdBQUcsR0FBRztvQkFDM0J5RSxNQUFNaUIsUUFBUSxDQUFDLFNBQVVDLFNBQVM7d0JBQ2hDLE9BQU87NEJBQ0xDLGdCQUFnQkQsVUFBVUMsY0FBYyxDQUFDWixNQUFNLENBQUNRO3dCQUNsRDtvQkFDRjtvQkFFQSxJQUFJZixNQUFNdkMsS0FBSyxDQUFDMkQsVUFBVSxFQUFFO3dCQUMxQnBCLE1BQU12QyxLQUFLLENBQUMyRCxVQUFVLENBQUNMO29CQUN6QjtnQkFDRjtZQUNGO1lBRUEsSUFBSU0sT0FBT3RFLGNBQWM7Z0JBQ3ZCdUUsU0FBU3RCLE1BQU1FLElBQUk7Z0JBQ25CcUIsVUFBVXZCLE1BQU1HLEtBQUs7WUFDdkIsR0FBR0gsTUFBTXZDLEtBQUs7WUFFZHVDLE1BQU13QixXQUFXLENBQUNILE1BQU0sTUFBTTtnQkFDNUJyQixNQUFNeUIsV0FBVztnQkFFakJ6QixNQUFNdkMsS0FBSyxDQUFDaUUsUUFBUSxJQUFJMUIsTUFBTTJCLFFBQVEsQ0FBQztZQUN6QztZQUVBLElBQUkzQixNQUFNdkMsS0FBSyxDQUFDcUQsUUFBUSxLQUFLLGVBQWU7Z0JBQzFDZCxNQUFNNEIsYUFBYSxHQUFHQyxZQUFZN0IsTUFBTThCLG1CQUFtQixFQUFFO1lBQy9EO1lBRUE5QixNQUFNK0IsRUFBRSxHQUFHLElBQUlySCx1QkFBdUIsQ0FBQyxVQUFVLENBQUM7Z0JBQ2hELElBQUlzRixNQUFNUSxLQUFLLENBQUN3QixTQUFTLEVBQUU7b0JBQ3pCaEMsTUFBTWlDLGVBQWUsQ0FBQyxRQUFRLG1EQUFtRDtvQkFHakZqQyxNQUFNa0MsY0FBYyxDQUFDcEYsSUFBSSxDQUFDcUYsV0FBVzt3QkFDbkMsT0FBT25DLE1BQU1pQyxlQUFlO29CQUM5QixHQUFHakMsTUFBTXZDLEtBQUssQ0FBQzJFLEtBQUs7Z0JBQ3RCLE9BQU87b0JBQ0xwQyxNQUFNaUMsZUFBZTtnQkFDdkI7WUFDRjtZQUVBakMsTUFBTStCLEVBQUUsQ0FBQ00sT0FBTyxDQUFDckMsTUFBTUUsSUFBSTtZQUUzQm9DLFNBQVNDLGdCQUFnQixJQUFJQyxNQUFNdkgsU0FBUyxDQUFDK0IsT0FBTyxDQUFDckIsSUFBSSxDQUFDMkcsU0FBU0MsZ0JBQWdCLENBQUMsaUJBQWlCLFNBQVVFLEtBQUs7Z0JBQ2xIQSxNQUFNQyxPQUFPLEdBQUcxQyxNQUFNdkMsS0FBSyxDQUFDa0YsWUFBWSxHQUFHM0MsTUFBTTRDLFlBQVksR0FBRztnQkFDaEVILE1BQU1JLE1BQU0sR0FBRzdDLE1BQU12QyxLQUFLLENBQUNrRixZQUFZLEdBQUczQyxNQUFNOEMsV0FBVyxHQUFHO1lBQ2hFO1lBRUEsSUFBSUMsT0FBT0MsZ0JBQWdCLEVBQUU7Z0JBQzNCRCxPQUFPQyxnQkFBZ0IsQ0FBQyxVQUFVaEQsTUFBTWlDLGVBQWU7WUFDekQsT0FBTztnQkFDTGMsT0FBT0UsV0FBVyxDQUFDLFlBQVlqRCxNQUFNaUMsZUFBZTtZQUN0RDtRQUNGO1FBRUFoRixnQkFBZ0JxQyx1QkFBdUJVLFFBQVEsd0JBQXdCO1lBQ3JFLElBQUlBLE1BQU1rRCxvQkFBb0IsRUFBRTtnQkFDOUJDLGFBQWFuRCxNQUFNa0Qsb0JBQW9CO1lBQ3pDO1lBRUEsSUFBSWxELE1BQU00QixhQUFhLEVBQUU7Z0JBQ3ZCd0IsY0FBY3BELE1BQU00QixhQUFhO1lBQ25DO1lBRUEsSUFBSTVCLE1BQU1rQyxjQUFjLENBQUMzRyxNQUFNLEVBQUU7Z0JBQy9CeUUsTUFBTWtDLGNBQWMsQ0FBQ2xGLE9BQU8sQ0FBQyxTQUFVcUcsS0FBSztvQkFDMUMsT0FBT0YsYUFBYUU7Z0JBQ3RCO2dCQUVBckQsTUFBTWtDLGNBQWMsR0FBRyxFQUFFO1lBQzNCO1lBRUEsSUFBSWEsT0FBT0MsZ0JBQWdCLEVBQUU7Z0JBQzNCRCxPQUFPTyxtQkFBbUIsQ0FBQyxVQUFVdEQsTUFBTWlDLGVBQWU7WUFDNUQsT0FBTztnQkFDTGMsT0FBT1EsV0FBVyxDQUFDLFlBQVl2RCxNQUFNaUMsZUFBZTtZQUN0RDtZQUVBLElBQUlqQyxNQUFNd0QsYUFBYSxFQUFFO2dCQUN2QkosY0FBY3BELE1BQU13RCxhQUFhO1lBQ25DO1lBRUF4RCxNQUFNK0IsRUFBRSxDQUFDMEIsVUFBVTtRQUNyQjtRQUVBeEcsZ0JBQWdCcUMsdUJBQXVCVSxRQUFRLHNCQUFzQixTQUFVMEQsU0FBUztZQUN0RjFELE1BQU0yRCxlQUFlO1lBRXJCM0QsTUFBTXZDLEtBQUssQ0FBQ21HLFFBQVEsSUFBSTVELE1BQU12QyxLQUFLLENBQUNtRyxRQUFRO1lBRTVDLElBQUk1RCxNQUFNdkMsS0FBSyxDQUFDcUQsUUFBUSxFQUFFO2dCQUN4QixJQUFJQyxlQUFlLENBQUMsR0FBR3pHLGtCQUFrQjBHLHFCQUFxQixFQUFFakUsY0FBY0EsY0FBYyxDQUFDLEdBQUdpRCxNQUFNdkMsS0FBSyxHQUFHdUMsTUFBTVEsS0FBSztnQkFFekgsSUFBSU8sYUFBYXhGLE1BQU0sR0FBRyxHQUFHO29CQUMzQnlFLE1BQU1pQixRQUFRLENBQUMsU0FBVUMsU0FBUzt3QkFDaEMsT0FBTzs0QkFDTEMsZ0JBQWdCRCxVQUFVQyxjQUFjLENBQUNaLE1BQU0sQ0FBQ1E7d0JBQ2xEO29CQUNGO29CQUVBLElBQUlmLE1BQU12QyxLQUFLLENBQUMyRCxVQUFVLEVBQUU7d0JBQzFCcEIsTUFBTXZDLEtBQUssQ0FBQzJELFVBQVUsQ0FBQ0w7b0JBQ3pCO2dCQUNGO1lBQ0YsRUFBRSwrQkFBK0I7WUFDakMsMkNBQTJDO1lBQzNDLElBQUk7WUFHSmYsTUFBTXlCLFdBQVc7WUFFakIsSUFBSUosT0FBT3RFLGNBQWNBLGNBQWM7Z0JBQ3JDdUUsU0FBU3RCLE1BQU1FLElBQUk7Z0JBQ25CcUIsVUFBVXZCLE1BQU1HLEtBQUs7WUFDdkIsR0FBR0gsTUFBTXZDLEtBQUssR0FBR3VDLE1BQU1RLEtBQUs7WUFFNUIsSUFBSXFELGdCQUFnQjdELE1BQU04RCxjQUFjLENBQUNKO1lBRXpDRyxpQkFBaUI3RCxNQUFNd0IsV0FBVyxDQUFDSCxNQUFNd0MsZUFBZTtnQkFDdEQsSUFBSTdELE1BQU1RLEtBQUssQ0FBQ0MsWUFBWSxJQUFJekcsTUFBTSxDQUFDLFVBQVUsQ0FBQytKLFFBQVEsQ0FBQ0MsS0FBSyxDQUFDaEUsTUFBTXZDLEtBQUssQ0FBQ3dHLFFBQVEsR0FBRztvQkFDdEZqRSxNQUFNa0UsV0FBVyxDQUFDO3dCQUNoQkMsU0FBUzt3QkFDVEMsT0FBT3BLLE1BQU0sQ0FBQyxVQUFVLENBQUMrSixRQUFRLENBQUNDLEtBQUssQ0FBQ2hFLE1BQU12QyxLQUFLLENBQUN3RyxRQUFRLElBQUlqRSxNQUFNdkMsS0FBSyxDQUFDNEcsWUFBWTt3QkFDeEY1RCxjQUFjVCxNQUFNUSxLQUFLLENBQUNDLFlBQVk7b0JBQ3hDO2dCQUNGO2dCQUVBLElBQUlULE1BQU12QyxLQUFLLENBQUNpRSxRQUFRLEVBQUU7b0JBQ3hCMUIsTUFBTTJCLFFBQVEsQ0FBQztnQkFDakIsT0FBTztvQkFDTDNCLE1BQU1zRSxLQUFLLENBQUM7Z0JBQ2Q7WUFDRjtRQUNGO1FBRUFySCxnQkFBZ0JxQyx1QkFBdUJVLFFBQVEsbUJBQW1CLFNBQVU2RCxhQUFhO1lBQ3ZGLElBQUk3RCxNQUFNdUUsZUFBZSxFQUFFdkUsTUFBTXVFLGVBQWUsQ0FBQ0MsTUFBTTtZQUN2RHhFLE1BQU11RSxlQUFlLEdBQUcsQ0FBQyxHQUFHbkssT0FBTyxDQUFDLFVBQVUsRUFBRTtnQkFDOUMsT0FBTzRGLE1BQU15RSxZQUFZLENBQUNaO1lBQzVCLEdBQUc7WUFFSDdELE1BQU11RSxlQUFlO1FBQ3ZCO1FBRUF0SCxnQkFBZ0JxQyx1QkFBdUJVLFFBQVEsZ0JBQWdCO1lBQzdELElBQUk2RCxnQkFBZ0J2SSxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS29KLFlBQVlwSixTQUFTLENBQUMsRUFBRSxHQUFHO1lBQ3hGLElBQUlxSixpQkFBaUJqRixRQUFRTSxNQUFNRyxLQUFLLElBQUlILE1BQU1HLEtBQUssQ0FBQ3lFLElBQUksR0FBRyxnRkFBZ0Y7WUFFL0ksSUFBSSxDQUFDRCxnQkFBZ0I7WUFFckIsSUFBSXRELE9BQU90RSxjQUFjQSxjQUFjO2dCQUNyQ3VFLFNBQVN0QixNQUFNRSxJQUFJO2dCQUNuQnFCLFVBQVV2QixNQUFNRyxLQUFLO1lBQ3ZCLEdBQUdILE1BQU12QyxLQUFLLEdBQUd1QyxNQUFNUSxLQUFLO1lBRTVCUixNQUFNd0IsV0FBVyxDQUFDSCxNQUFNd0MsZUFBZTtnQkFDckMsSUFBSTdELE1BQU12QyxLQUFLLENBQUNpRSxRQUFRLEVBQUUxQixNQUFNMkIsUUFBUSxDQUFDO3FCQUFlM0IsTUFBTXNFLEtBQUssQ0FBQztZQUN0RSxJQUFJLHFGQUFxRjtZQUd6RnRFLE1BQU1pQixRQUFRLENBQUM7Z0JBQ2JlLFdBQVc7WUFDYjtZQUVBbUIsYUFBYW5ELE1BQU1rRCxvQkFBb0I7WUFDdkMsT0FBT2xELE1BQU1rRCxvQkFBb0I7UUFDbkM7UUFFQWpHLGdCQUFnQnFDLHVCQUF1QlUsUUFBUSxlQUFlLFNBQVVxQixJQUFJLEVBQUV3QyxhQUFhLEVBQUVnQixRQUFRO1lBQ25HLElBQUlDLGVBQWUsQ0FBQyxHQUFHeEssa0JBQWtCeUssZ0JBQWdCLEVBQUUxRDtZQUMzREEsT0FBT3RFLGNBQWNBLGNBQWNBLGNBQWMsQ0FBQyxHQUFHc0UsT0FBT3lELGVBQWUsQ0FBQyxHQUFHO2dCQUM3RUUsWUFBWUYsYUFBYXJFLFlBQVk7WUFDdkM7WUFDQSxJQUFJd0UsYUFBYSxDQUFDLEdBQUczSyxrQkFBa0I0SyxZQUFZLEVBQUU3RDtZQUNyREEsT0FBT3RFLGNBQWNBLGNBQWMsQ0FBQyxHQUFHc0UsT0FBTyxDQUFDLEdBQUc7Z0JBQ2hEOEQsTUFBTUY7WUFDUjtZQUNBLElBQUlHLGFBQWEsQ0FBQyxHQUFHOUssa0JBQWtCK0ssV0FBVyxFQUFFaEU7WUFFcEQsSUFBSXdDLGlCQUFpQjdKLE1BQU0sQ0FBQyxVQUFVLENBQUMrSixRQUFRLENBQUNDLEtBQUssQ0FBQ2hFLE1BQU12QyxLQUFLLENBQUN3RyxRQUFRLE1BQU1qSyxNQUFNLENBQUMsVUFBVSxDQUFDK0osUUFBUSxDQUFDQyxLQUFLLENBQUMzQyxLQUFLNEMsUUFBUSxHQUFHO2dCQUMvSGEsWUFBWSxDQUFDLGFBQWEsR0FBR007WUFDL0I7WUFFQXBGLE1BQU1pQixRQUFRLENBQUM2RCxjQUFjRDtRQUMvQjtRQUVBNUgsZ0JBQWdCcUMsdUJBQXVCVSxRQUFRLFdBQVc7WUFDeEQsSUFBSUEsTUFBTXZDLEtBQUssQ0FBQzZILGFBQWEsRUFBRTtnQkFDN0IsSUFBSUMsY0FBYyxHQUNkQyxhQUFhO2dCQUNqQixJQUFJQyxpQkFBaUIsRUFBRTtnQkFDdkIsSUFBSUMsWUFBWSxDQUFDLEdBQUdwTCxrQkFBa0JxTCxZQUFZLEVBQUU1SSxjQUFjQSxjQUFjQSxjQUFjLENBQUMsR0FBR2lELE1BQU12QyxLQUFLLEdBQUd1QyxNQUFNUSxLQUFLLEdBQUcsQ0FBQyxHQUFHO29CQUNoSW9GLFlBQVk1RixNQUFNdkMsS0FBSyxDQUFDd0csUUFBUSxDQUFDMUksTUFBTTtnQkFDekM7Z0JBQ0EsSUFBSXNLLGFBQWEsQ0FBQyxHQUFHdkwsa0JBQWtCd0wsYUFBYSxFQUFFL0ksY0FBY0EsY0FBY0EsY0FBYyxDQUFDLEdBQUdpRCxNQUFNdkMsS0FBSyxHQUFHdUMsTUFBTVEsS0FBSyxHQUFHLENBQUMsR0FBRztvQkFDbElvRixZQUFZNUYsTUFBTXZDLEtBQUssQ0FBQ3dHLFFBQVEsQ0FBQzFJLE1BQU07Z0JBQ3pDO2dCQUVBeUUsTUFBTXZDLEtBQUssQ0FBQ3dHLFFBQVEsQ0FBQ2pILE9BQU8sQ0FBQyxTQUFVK0ksS0FBSztvQkFDMUNOLGVBQWUzSSxJQUFJLENBQUNpSixNQUFNdEksS0FBSyxDQUFDaUQsS0FBSyxDQUFDc0YsS0FBSztvQkFDM0NULGVBQWVRLE1BQU10SSxLQUFLLENBQUNpRCxLQUFLLENBQUNzRixLQUFLO2dCQUN4QztnQkFFQSxJQUFLLElBQUkzSyxJQUFJLEdBQUdBLElBQUlxSyxXQUFXckssSUFBSztvQkFDbENtSyxjQUFjQyxjQUFjLENBQUNBLGVBQWVsSyxNQUFNLEdBQUcsSUFBSUYsRUFBRTtvQkFDM0RrSyxlQUFlRSxjQUFjLENBQUNBLGVBQWVsSyxNQUFNLEdBQUcsSUFBSUYsRUFBRTtnQkFDOUQ7Z0JBRUEsSUFBSyxJQUFJNEssS0FBSyxHQUFHQSxLQUFLSixZQUFZSSxLQUFNO29CQUN0Q1YsZUFBZUUsY0FBYyxDQUFDUSxHQUFHO2dCQUNuQztnQkFFQSxJQUFLLElBQUlDLE1BQU0sR0FBR0EsTUFBTWxHLE1BQU1RLEtBQUssQ0FBQ0MsWUFBWSxFQUFFeUYsTUFBTztvQkFDdkRWLGNBQWNDLGNBQWMsQ0FBQ1MsSUFBSTtnQkFDbkM7Z0JBRUEsSUFBSUMsY0FBYztvQkFDaEJILE9BQU9ULGNBQWM7b0JBQ3JCSixNQUFNLENBQUNLLGFBQWE7Z0JBQ3RCO2dCQUVBLElBQUl4RixNQUFNdkMsS0FBSyxDQUFDMkksVUFBVSxFQUFFO29CQUMxQixJQUFJQyxlQUFlLEdBQUc5RixNQUFNLENBQUNrRixjQUFjLENBQUN6RixNQUFNUSxLQUFLLENBQUNDLFlBQVksQ0FBQyxFQUFFO29CQUN2RTBGLFlBQVloQixJQUFJLEdBQUcsUUFBUTVFLE1BQU0sQ0FBQzRGLFlBQVloQixJQUFJLEVBQUUsZUFBZTVFLE1BQU0sQ0FBQzhGLGNBQWM7Z0JBQzFGO2dCQUVBLE9BQU87b0JBQ0xqQixZQUFZZTtnQkFDZDtZQUNGO1lBRUEsSUFBSUcsZ0JBQWdCdE0sTUFBTSxDQUFDLFVBQVUsQ0FBQytKLFFBQVEsQ0FBQ0MsS0FBSyxDQUFDaEUsTUFBTXZDLEtBQUssQ0FBQ3dHLFFBQVE7WUFFekUsSUFBSTVDLE9BQU90RSxjQUFjQSxjQUFjQSxjQUFjLENBQUMsR0FBR2lELE1BQU12QyxLQUFLLEdBQUd1QyxNQUFNUSxLQUFLLEdBQUcsQ0FBQyxHQUFHO2dCQUN2Rm9GLFlBQVlVO1lBQ2Q7WUFFQSxJQUFJVixhQUFhLENBQUMsR0FBR3RMLGtCQUFrQnFMLFlBQVksRUFBRXRFLFFBQVEsQ0FBQyxHQUFHL0csa0JBQWtCd0wsYUFBYSxFQUFFekUsUUFBUWlGO1lBQzFHLElBQUlDLGFBQWEsTUFBTXZHLE1BQU12QyxLQUFLLENBQUM0RyxZQUFZLEdBQUd1QjtZQUNsRCxJQUFJWSxhQUFhLE1BQU1aO1lBQ3ZCLElBQUlhLFlBQVksQ0FBQ0QsYUFBYyxFQUFDLEdBQUdsTSxrQkFBa0JxTCxZQUFZLEVBQUV0RSxRQUFRckIsTUFBTVEsS0FBSyxDQUFDQyxZQUFZLElBQUk4RixhQUFhO1lBRXBILElBQUl2RyxNQUFNdkMsS0FBSyxDQUFDMkksVUFBVSxFQUFFO2dCQUMxQkssYUFBYSxDQUFDLE1BQU1ELGFBQWFELGFBQWEsR0FBRSxJQUFLO1lBQ3ZEO1lBRUEsSUFBSW5CLGFBQWE7Z0JBQ2ZZLE9BQU9PLGFBQWE7Z0JBQ3BCcEIsTUFBTXNCLFlBQVk7WUFDcEI7WUFDQSxPQUFPO2dCQUNMRCxZQUFZQSxhQUFhO2dCQUN6QnBCLFlBQVlBO1lBQ2Q7UUFDRjtRQUVBbkksZ0JBQWdCcUMsdUJBQXVCVSxRQUFRLG1CQUFtQjtZQUNoRSxJQUFJMEcsU0FBUzFHLE1BQU1FLElBQUksSUFBSUYsTUFBTUUsSUFBSSxDQUFDcUMsZ0JBQWdCLElBQUl2QyxNQUFNRSxJQUFJLENBQUNxQyxnQkFBZ0IsQ0FBQyx1QkFBdUIsRUFBRTtZQUMvRyxJQUFJb0UsY0FBY0QsT0FBT25MLE1BQU0sRUFDM0JxTCxjQUFjO1lBQ2xCcEUsTUFBTXZILFNBQVMsQ0FBQytCLE9BQU8sQ0FBQ3JCLElBQUksQ0FBQytLLFFBQVEsU0FBVUcsS0FBSztnQkFDbEQsSUFBSUMsVUFBVSxTQUFTQTtvQkFDckIsT0FBTyxFQUFFRixlQUFlQSxlQUFlRCxlQUFlM0csTUFBTWlDLGVBQWU7Z0JBQzdFO2dCQUVBLElBQUksQ0FBQzRFLE1BQU1FLE9BQU8sRUFBRTtvQkFDbEJGLE1BQU1FLE9BQU8sR0FBRzt3QkFDZCxPQUFPRixNQUFNRyxVQUFVLENBQUNDLEtBQUs7b0JBQy9CO2dCQUNGLE9BQU87b0JBQ0wsSUFBSUMsbUJBQW1CTCxNQUFNRSxPQUFPO29CQUVwQ0YsTUFBTUUsT0FBTyxHQUFHO3dCQUNkRzt3QkFDQUwsTUFBTUcsVUFBVSxDQUFDQyxLQUFLO29CQUN4QjtnQkFDRjtnQkFFQSxJQUFJLENBQUNKLE1BQU1NLE1BQU0sRUFBRTtvQkFDakIsSUFBSW5ILE1BQU12QyxLQUFLLENBQUNxRCxRQUFRLEVBQUU7d0JBQ3hCK0YsTUFBTU0sTUFBTSxHQUFHOzRCQUNibkgsTUFBTXlCLFdBQVc7NEJBRWpCekIsTUFBTWtDLGNBQWMsQ0FBQ3BGLElBQUksQ0FBQ3FGLFdBQVduQyxNQUFNaUMsZUFBZSxFQUFFakMsTUFBTXZDLEtBQUssQ0FBQzJFLEtBQUs7d0JBQy9FO29CQUNGLE9BQU87d0JBQ0x5RSxNQUFNTSxNQUFNLEdBQUdMO3dCQUVmRCxNQUFNTyxPQUFPLEdBQUc7NEJBQ2ROOzRCQUNBOUcsTUFBTXZDLEtBQUssQ0FBQzRKLGVBQWUsSUFBSXJILE1BQU12QyxLQUFLLENBQUM0SixlQUFlO3dCQUM1RDtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQXBLLGdCQUFnQnFDLHVCQUF1QlUsUUFBUSx1QkFBdUI7WUFDcEUsSUFBSWUsZUFBZSxFQUFFO1lBRXJCLElBQUlNLE9BQU90RSxjQUFjQSxjQUFjLENBQUMsR0FBR2lELE1BQU12QyxLQUFLLEdBQUd1QyxNQUFNUSxLQUFLO1lBRXBFLElBQUssSUFBSTRELFFBQVFwRSxNQUFNUSxLQUFLLENBQUNDLFlBQVksRUFBRTJELFFBQVFwRSxNQUFNUSxLQUFLLENBQUNvRixVQUFVLEdBQUcsQ0FBQyxHQUFHdEwsa0JBQWtCd0wsYUFBYSxFQUFFekUsT0FBTytDLFFBQVM7Z0JBQy9ILElBQUlwRSxNQUFNUSxLQUFLLENBQUNXLGNBQWMsQ0FBQ2pGLE9BQU8sQ0FBQ2tJLFNBQVMsR0FBRztvQkFDakRyRCxhQUFhakUsSUFBSSxDQUFDc0g7b0JBQ2xCO2dCQUNGO1lBQ0Y7WUFFQSxJQUFLLElBQUlrRCxTQUFTdEgsTUFBTVEsS0FBSyxDQUFDQyxZQUFZLEdBQUcsR0FBRzZHLFVBQVUsQ0FBQyxDQUFDLEdBQUdoTixrQkFBa0JxTCxZQUFZLEVBQUV0RSxPQUFPaUcsU0FBVTtnQkFDOUcsSUFBSXRILE1BQU1RLEtBQUssQ0FBQ1csY0FBYyxDQUFDakYsT0FBTyxDQUFDb0wsVUFBVSxHQUFHO29CQUNsRHZHLGFBQWFqRSxJQUFJLENBQUN3SztvQkFDbEI7Z0JBQ0Y7WUFDRjtZQUVBLElBQUl2RyxhQUFheEYsTUFBTSxHQUFHLEdBQUc7Z0JBQzNCeUUsTUFBTWlCLFFBQVEsQ0FBQyxTQUFVVCxLQUFLO29CQUM1QixPQUFPO3dCQUNMVyxnQkFBZ0JYLE1BQU1XLGNBQWMsQ0FBQ1osTUFBTSxDQUFDUTtvQkFDOUM7Z0JBQ0Y7Z0JBRUEsSUFBSWYsTUFBTXZDLEtBQUssQ0FBQzJELFVBQVUsRUFBRTtvQkFDMUJwQixNQUFNdkMsS0FBSyxDQUFDMkQsVUFBVSxDQUFDTDtnQkFDekI7WUFDRixPQUFPO2dCQUNMLElBQUlmLE1BQU00QixhQUFhLEVBQUU7b0JBQ3ZCd0IsY0FBY3BELE1BQU00QixhQUFhO29CQUNqQyxPQUFPNUIsTUFBTTRCLGFBQWE7Z0JBQzVCO1lBQ0Y7UUFDRjtRQUVBM0UsZ0JBQWdCcUMsdUJBQXVCVSxRQUFRLGdCQUFnQixTQUFVb0UsS0FBSztZQUM1RSxJQUFJbUQsY0FBY2pNLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLb0osWUFBWXBKLFNBQVMsQ0FBQyxFQUFFLEdBQUc7WUFDdEYsSUFBSWtNLGNBQWN4SCxNQUFNdkMsS0FBSyxFQUN6QmdLLFdBQVdELFlBQVlDLFFBQVEsRUFDL0JDLGVBQWVGLFlBQVlFLFlBQVksRUFDdkN0RyxhQUFhb0csWUFBWXBHLFVBQVUsRUFDbkNnQixRQUFRb0YsWUFBWXBGLEtBQUssRUFDekJ1RixjQUFjSCxZQUFZRyxXQUFXLEVBQUUsK0NBQStDO1lBRTFGLElBQUlsSCxlQUFlVCxNQUFNUSxLQUFLLENBQUNDLFlBQVk7WUFFM0MsSUFBSW1ILGdCQUFnQixDQUFDLEdBQUd0TixrQkFBa0J1TixZQUFZLEVBQUU5SyxjQUFjQSxjQUFjQSxjQUFjO2dCQUNoR3FILE9BQU9BO1lBQ1QsR0FBR3BFLE1BQU12QyxLQUFLLEdBQUd1QyxNQUFNUSxLQUFLLEdBQUcsQ0FBQyxHQUFHO2dCQUNqQ2UsVUFBVXZCLE1BQU1HLEtBQUs7Z0JBQ3JCMkgsUUFBUTlILE1BQU12QyxLQUFLLENBQUNxSyxNQUFNLElBQUksQ0FBQ1A7WUFDakMsS0FDSS9HLFFBQVFvSCxjQUFjcEgsS0FBSyxFQUMzQnVILFlBQVlILGNBQWNHLFNBQVM7WUFFdkMsSUFBSSxDQUFDdkgsT0FBTztZQUNaa0gsZ0JBQWdCQSxhQUFhakgsY0FBY0QsTUFBTUMsWUFBWTtZQUM3RCxJQUFJTSxlQUFlUCxNQUFNVyxjQUFjLENBQUN6RSxNQUFNLENBQUMsU0FBVTVDLEtBQUs7Z0JBQzVELE9BQU9rRyxNQUFNUSxLQUFLLENBQUNXLGNBQWMsQ0FBQ2pGLE9BQU8sQ0FBQ3BDLFNBQVM7WUFDckQ7WUFDQXNILGNBQWNMLGFBQWF4RixNQUFNLEdBQUcsS0FBSzZGLFdBQVdMO1lBRXBELElBQUksQ0FBQ2YsTUFBTXZDLEtBQUssQ0FBQ3VLLGNBQWMsSUFBSWhJLE1BQU1rRCxvQkFBb0IsRUFBRTtnQkFDN0RDLGFBQWFuRCxNQUFNa0Qsb0JBQW9CO2dCQUN2Q3lFLGVBQWVBLFlBQVlsSDtnQkFDM0IsT0FBT1QsTUFBTWtELG9CQUFvQjtZQUNuQztZQUVBbEQsTUFBTWlCLFFBQVEsQ0FBQ1QsT0FBTztnQkFDcEIsK0ZBQStGO2dCQUMvRixJQUFJaUgsWUFBWXpILE1BQU1pSSxhQUFhLEtBQUs3RCxPQUFPO29CQUM3Q3BFLE1BQU1pSSxhQUFhLEdBQUc3RDtvQkFDdEJxRCxTQUFTUyxXQUFXLENBQUNMLFlBQVksQ0FBQ3pEO2dCQUNwQztnQkFFQSxJQUFJLENBQUMyRCxXQUFXO2dCQUNoQi9ILE1BQU1rRCxvQkFBb0IsR0FBR2YsV0FBVztvQkFDdEMsSUFBSUgsWUFBWStGLFVBQVUvRixTQUFTLEVBQy9CbUcsYUFBYXRNLHlCQUF5QmtNLFdBQVc7d0JBQUM7cUJBQVk7b0JBRWxFL0gsTUFBTWlCLFFBQVEsQ0FBQ2tILFlBQVk7d0JBQ3pCbkksTUFBTWtDLGNBQWMsQ0FBQ3BGLElBQUksQ0FBQ3FGLFdBQVc7NEJBQ25DLE9BQU9uQyxNQUFNaUIsUUFBUSxDQUFDO2dDQUNwQmUsV0FBV0E7NEJBQ2I7d0JBQ0YsR0FBRzt3QkFFSDJGLGVBQWVBLFlBQVluSCxNQUFNQyxZQUFZO3dCQUM3QyxPQUFPVCxNQUFNa0Qsb0JBQW9CO29CQUNuQztnQkFDRixHQUFHZDtZQUNMO1FBQ0Y7UUFFQW5GLGdCQUFnQnFDLHVCQUF1QlUsUUFBUSxlQUFlLFNBQVVvSSxPQUFPO1lBQzdFLElBQUliLGNBQWNqTSxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS29KLFlBQVlwSixTQUFTLENBQUMsRUFBRSxHQUFHO1lBRXRGLElBQUkrRixPQUFPdEUsY0FBY0EsY0FBYyxDQUFDLEdBQUdpRCxNQUFNdkMsS0FBSyxHQUFHdUMsTUFBTVEsS0FBSztZQUVwRSxJQUFJNkgsY0FBYyxDQUFDLEdBQUcvTixrQkFBa0I0SixXQUFXLEVBQUU3QyxNQUFNK0c7WUFDM0QsSUFBSUMsZ0JBQWdCLEtBQUssQ0FBQ0EsYUFBYTtZQUV2QyxJQUFJZCxnQkFBZ0IsTUFBTTtnQkFDeEJ2SCxNQUFNNkgsWUFBWSxDQUFDUSxhQUFhZDtZQUNsQyxPQUFPO2dCQUNMdkgsTUFBTTZILFlBQVksQ0FBQ1E7WUFDckI7WUFFQXJJLE1BQU12QyxLQUFLLENBQUNpRSxRQUFRLElBQUkxQixNQUFNMkIsUUFBUSxDQUFDO1lBRXZDLElBQUkzQixNQUFNdkMsS0FBSyxDQUFDNkssYUFBYSxFQUFFO2dCQUM3QixJQUFJQyxRQUFRdkksTUFBTUUsSUFBSSxDQUFDcUMsZ0JBQWdCLENBQUM7Z0JBRXhDZ0csS0FBSyxDQUFDLEVBQUUsSUFBSUEsS0FBSyxDQUFDLEVBQUUsQ0FBQ3RCLEtBQUs7WUFDNUI7UUFDRjtRQUVBaEssZ0JBQWdCcUMsdUJBQXVCVSxRQUFRLGdCQUFnQixTQUFVSixDQUFDO1lBQ3hFLElBQUlJLE1BQU13SSxTQUFTLEtBQUssT0FBTztnQkFDN0I1SSxFQUFFNkksZUFBZTtnQkFDakI3SSxFQUFFOEksY0FBYztZQUNsQjtZQUVBMUksTUFBTXdJLFNBQVMsR0FBRztRQUNwQjtRQUVBdkwsZ0JBQWdCcUMsdUJBQXVCVSxRQUFRLGNBQWMsU0FBVUosQ0FBQztZQUN0RSxJQUFJK0ksTUFBTSxDQUFDLEdBQUdyTyxrQkFBa0JzTyxVQUFVLEVBQUVoSixHQUFHSSxNQUFNdkMsS0FBSyxDQUFDb0wsYUFBYSxFQUFFN0ksTUFBTXZDLEtBQUssQ0FBQ3FMLEdBQUc7WUFDekZILFFBQVEsTUFBTTNJLE1BQU1rRSxXQUFXLENBQUM7Z0JBQzlCQyxTQUFTd0U7WUFDWDtRQUNGO1FBRUExTCxnQkFBZ0JxQyx1QkFBdUJVLFFBQVEsaUJBQWlCLFNBQVVvSSxPQUFPO1lBQy9FcEksTUFBTWtFLFdBQVcsQ0FBQ2tFO1FBQ3BCO1FBRUFuTCxnQkFBZ0JxQyx1QkFBdUJVLFFBQVEscUJBQXFCO1lBQ2xFLElBQUkwSSxpQkFBaUIsU0FBU0EsZUFBZTlJLENBQUM7Z0JBQzVDQSxJQUFJQSxLQUFLbUQsT0FBT2dHLEtBQUs7Z0JBQ3JCLElBQUluSixFQUFFOEksY0FBYyxFQUFFOUksRUFBRThJLGNBQWM7Z0JBQ3RDOUksRUFBRW9KLFdBQVcsR0FBRztZQUNsQjtZQUVBakcsT0FBT2tHLFdBQVcsR0FBR1A7UUFDdkI7UUFFQXpMLGdCQUFnQnFDLHVCQUF1QlUsUUFBUSxvQkFBb0I7WUFDakUrQyxPQUFPa0csV0FBVyxHQUFHO1FBQ3ZCO1FBRUFoTSxnQkFBZ0JxQyx1QkFBdUJVLFFBQVEsY0FBYyxTQUFVSixDQUFDO1lBQ3RFLElBQUlJLE1BQU12QyxLQUFLLENBQUN5TCxlQUFlLEVBQUU7Z0JBQy9CbEosTUFBTW1KLGlCQUFpQjtZQUN6QjtZQUVBLElBQUkzSSxRQUFRLENBQUMsR0FBR2xHLGtCQUFrQjhPLFVBQVUsRUFBRXhKLEdBQUdJLE1BQU12QyxLQUFLLENBQUM0TCxLQUFLLEVBQUVySixNQUFNdkMsS0FBSyxDQUFDNkwsU0FBUztZQUN6RjlJLFVBQVUsTUFBTVIsTUFBTWlCLFFBQVEsQ0FBQ1Q7UUFDakM7UUFFQXZELGdCQUFnQnFDLHVCQUF1QlUsUUFBUSxhQUFhLFNBQVVKLENBQUM7WUFDckUsSUFBSVksUUFBUSxDQUFDLEdBQUdsRyxrQkFBa0JpUCxTQUFTLEVBQUUzSixHQUFHN0MsY0FBY0EsY0FBY0EsY0FBYyxDQUFDLEdBQUdpRCxNQUFNdkMsS0FBSyxHQUFHdUMsTUFBTVEsS0FBSyxHQUFHLENBQUMsR0FBRztnQkFDNUhlLFVBQVV2QixNQUFNRyxLQUFLO2dCQUNyQm1CLFNBQVN0QixNQUFNRSxJQUFJO2dCQUNuQjhFLFlBQVloRixNQUFNUSxLQUFLLENBQUNDLFlBQVk7WUFDdEM7WUFDQSxJQUFJLENBQUNELE9BQU87WUFFWixJQUFJQSxLQUFLLENBQUMsVUFBVSxFQUFFO2dCQUNwQlIsTUFBTXdJLFNBQVMsR0FBRztZQUNwQjtZQUVBeEksTUFBTWlCLFFBQVEsQ0FBQ1Q7UUFDakI7UUFFQXZELGdCQUFnQnFDLHVCQUF1QlUsUUFBUSxZQUFZLFNBQVVKLENBQUM7WUFDcEUsSUFBSVksUUFBUSxDQUFDLEdBQUdsRyxrQkFBa0JrUCxRQUFRLEVBQUU1SixHQUFHN0MsY0FBY0EsY0FBY0EsY0FBYyxDQUFDLEdBQUdpRCxNQUFNdkMsS0FBSyxHQUFHdUMsTUFBTVEsS0FBSyxHQUFHLENBQUMsR0FBRztnQkFDM0hlLFVBQVV2QixNQUFNRyxLQUFLO2dCQUNyQm1CLFNBQVN0QixNQUFNRSxJQUFJO2dCQUNuQjhFLFlBQVloRixNQUFNUSxLQUFLLENBQUNDLFlBQVk7WUFDdEM7WUFDQSxJQUFJLENBQUNELE9BQU87WUFDWixJQUFJaUosc0JBQXNCakosS0FBSyxDQUFDLHNCQUFzQjtZQUN0RCxPQUFPQSxLQUFLLENBQUMsc0JBQXNCO1lBRW5DUixNQUFNaUIsUUFBUSxDQUFDVDtZQUVmLElBQUlpSix3QkFBd0IvRSxXQUFXO1lBRXZDMUUsTUFBTTZILFlBQVksQ0FBQzRCO1lBRW5CLElBQUl6SixNQUFNdkMsS0FBSyxDQUFDeUwsZUFBZSxFQUFFO2dCQUMvQmxKLE1BQU0wSixnQkFBZ0I7WUFDeEI7UUFDRjtRQUVBek0sZ0JBQWdCcUMsdUJBQXVCVSxRQUFRLFlBQVksU0FBVUosQ0FBQztZQUNwRUksTUFBTXdKLFFBQVEsQ0FBQzVKO1lBRWZJLE1BQU13SSxTQUFTLEdBQUc7UUFDcEI7UUFFQXZMLGdCQUFnQnFDLHVCQUF1QlUsUUFBUSxhQUFhO1lBQzFELG9EQUFvRDtZQUNwRCx1REFBdUQ7WUFDdkQsaUNBQWlDO1lBQ2pDQSxNQUFNa0MsY0FBYyxDQUFDcEYsSUFBSSxDQUFDcUYsV0FBVztnQkFDbkMsT0FBT25DLE1BQU1rRSxXQUFXLENBQUM7b0JBQ3ZCQyxTQUFTO2dCQUNYO1lBQ0YsR0FBRztRQUNMO1FBRUFsSCxnQkFBZ0JxQyx1QkFBdUJVLFFBQVEsYUFBYTtZQUMxREEsTUFBTWtDLGNBQWMsQ0FBQ3BGLElBQUksQ0FBQ3FGLFdBQVc7Z0JBQ25DLE9BQU9uQyxNQUFNa0UsV0FBVyxDQUFDO29CQUN2QkMsU0FBUztnQkFDWDtZQUNGLEdBQUc7UUFDTDtRQUVBbEgsZ0JBQWdCcUMsdUJBQXVCVSxRQUFRLGFBQWEsU0FBVXlDLEtBQUs7WUFDekUsSUFBSThFLGNBQWNqTSxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS29KLFlBQVlwSixTQUFTLENBQUMsRUFBRSxHQUFHO1lBQ3RGbUgsUUFBUWtILE9BQU9sSDtZQUNmLElBQUltSCxNQUFNbkgsUUFBUSxPQUFPO1lBRXpCekMsTUFBTWtDLGNBQWMsQ0FBQ3BGLElBQUksQ0FBQ3FGLFdBQVc7Z0JBQ25DLE9BQU9uQyxNQUFNa0UsV0FBVyxDQUFDO29CQUN2QkMsU0FBUztvQkFDVEMsT0FBTzNCO29CQUNQaEMsY0FBY1QsTUFBTVEsS0FBSyxDQUFDQyxZQUFZO2dCQUN4QyxHQUFHOEc7WUFDTCxHQUFHO1FBQ0w7UUFFQXRLLGdCQUFnQnFDLHVCQUF1QlUsUUFBUSxRQUFRO1lBQ3JELElBQUk2SjtZQUVKLElBQUk3SixNQUFNdkMsS0FBSyxDQUFDcUwsR0FBRyxFQUFFO2dCQUNuQmUsWUFBWTdKLE1BQU1RLEtBQUssQ0FBQ0MsWUFBWSxHQUFHVCxNQUFNdkMsS0FBSyxDQUFDcU0sY0FBYztZQUNuRSxPQUFPO2dCQUNMLElBQUksQ0FBQyxHQUFHeFAsa0JBQWtCeVAsU0FBUyxFQUFFaE4sY0FBY0EsY0FBYyxDQUFDLEdBQUdpRCxNQUFNdkMsS0FBSyxHQUFHdUMsTUFBTVEsS0FBSyxJQUFJO29CQUNoR3FKLFlBQVk3SixNQUFNUSxLQUFLLENBQUNDLFlBQVksR0FBR1QsTUFBTXZDLEtBQUssQ0FBQ3FNLGNBQWM7Z0JBQ25FLE9BQU87b0JBQ0wsT0FBTztnQkFDVDtZQUNGO1lBRUE5SixNQUFNNkgsWUFBWSxDQUFDZ0M7UUFDckI7UUFFQTVNLGdCQUFnQnFDLHVCQUF1QlUsUUFBUSxZQUFZLFNBQVVnSyxRQUFRO1lBQzNFLElBQUloSyxNQUFNd0QsYUFBYSxFQUFFO2dCQUN2QkosY0FBY3BELE1BQU13RCxhQUFhO1lBQ25DO1lBRUEsSUFBSXlHLGNBQWNqSyxNQUFNUSxLQUFLLENBQUN5SixXQUFXO1lBRXpDLElBQUlELGFBQWEsVUFBVTtnQkFDekIsSUFBSUMsZ0JBQWdCLGFBQWFBLGdCQUFnQixhQUFhQSxnQkFBZ0IsVUFBVTtvQkFDdEY7Z0JBQ0Y7WUFDRixPQUFPLElBQUlELGFBQWEsU0FBUztnQkFDL0IsSUFBSUMsZ0JBQWdCLFlBQVlBLGdCQUFnQixXQUFXO29CQUN6RDtnQkFDRjtZQUNGLE9BQU8sSUFBSUQsYUFBYSxRQUFRO2dCQUM5QixJQUFJQyxnQkFBZ0IsWUFBWUEsZ0JBQWdCLFdBQVc7b0JBQ3pEO2dCQUNGO1lBQ0Y7WUFFQWpLLE1BQU13RCxhQUFhLEdBQUczQixZQUFZN0IsTUFBTWtLLElBQUksRUFBRWxLLE1BQU12QyxLQUFLLENBQUMwTSxhQUFhLEdBQUc7WUFFMUVuSyxNQUFNaUIsUUFBUSxDQUFDO2dCQUNiZ0osYUFBYTtZQUNmO1FBQ0Y7UUFFQWhOLGdCQUFnQnFDLHVCQUF1QlUsUUFBUSxTQUFTLFNBQVVvSyxTQUFTO1lBQ3pFLElBQUlwSyxNQUFNd0QsYUFBYSxFQUFFO2dCQUN2QkosY0FBY3BELE1BQU13RCxhQUFhO2dCQUNqQ3hELE1BQU13RCxhQUFhLEdBQUc7WUFDeEI7WUFFQSxJQUFJeUcsY0FBY2pLLE1BQU1RLEtBQUssQ0FBQ3lKLFdBQVc7WUFFekMsSUFBSUcsY0FBYyxVQUFVO2dCQUMxQnBLLE1BQU1pQixRQUFRLENBQUM7b0JBQ2JnSixhQUFhO2dCQUNmO1lBQ0YsT0FBTyxJQUFJRyxjQUFjLFdBQVc7Z0JBQ2xDLElBQUlILGdCQUFnQixhQUFhQSxnQkFBZ0IsV0FBVztvQkFDMURqSyxNQUFNaUIsUUFBUSxDQUFDO3dCQUNiZ0osYUFBYTtvQkFDZjtnQkFDRjtZQUNGLE9BQU87Z0JBQ0wsMEJBQTBCO2dCQUMxQixJQUFJQSxnQkFBZ0IsV0FBVztvQkFDN0JqSyxNQUFNaUIsUUFBUSxDQUFDO3dCQUNiZ0osYUFBYTtvQkFDZjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQWhOLGdCQUFnQnFDLHVCQUF1QlUsUUFBUSxjQUFjO1lBQzNELE9BQU9BLE1BQU12QyxLQUFLLENBQUNpRSxRQUFRLElBQUkxQixNQUFNc0UsS0FBSyxDQUFDO1FBQzdDO1FBRUFySCxnQkFBZ0JxQyx1QkFBdUJVLFFBQVEsZUFBZTtZQUM1RCxPQUFPQSxNQUFNdkMsS0FBSyxDQUFDaUUsUUFBUSxJQUFJMUIsTUFBTVEsS0FBSyxDQUFDeUosV0FBVyxLQUFLLGFBQWFqSyxNQUFNMkIsUUFBUSxDQUFDO1FBQ3pGO1FBRUExRSxnQkFBZ0JxQyx1QkFBdUJVLFFBQVEsZUFBZTtZQUM1RCxPQUFPQSxNQUFNdkMsS0FBSyxDQUFDaUUsUUFBUSxJQUFJMUIsTUFBTXNFLEtBQUssQ0FBQztRQUM3QztRQUVBckgsZ0JBQWdCcUMsdUJBQXVCVSxRQUFRLGdCQUFnQjtZQUM3RCxPQUFPQSxNQUFNdkMsS0FBSyxDQUFDaUUsUUFBUSxJQUFJMUIsTUFBTVEsS0FBSyxDQUFDeUosV0FBVyxLQUFLLGFBQWFqSyxNQUFNMkIsUUFBUSxDQUFDO1FBQ3pGO1FBRUExRSxnQkFBZ0JxQyx1QkFBdUJVLFFBQVEsZ0JBQWdCO1lBQzdELE9BQU9BLE1BQU12QyxLQUFLLENBQUNpRSxRQUFRLElBQUkxQixNQUFNc0UsS0FBSyxDQUFDO1FBQzdDO1FBRUFySCxnQkFBZ0JxQyx1QkFBdUJVLFFBQVEsZUFBZTtZQUM1RCxPQUFPQSxNQUFNdkMsS0FBSyxDQUFDaUUsUUFBUSxJQUFJMUIsTUFBTVEsS0FBSyxDQUFDeUosV0FBVyxLQUFLLGFBQWFqSyxNQUFNMkIsUUFBUSxDQUFDO1FBQ3pGO1FBRUExRSxnQkFBZ0JxQyx1QkFBdUJVLFFBQVEsVUFBVTtZQUN2RCxJQUFJcUssWUFBWSxDQUFDLEdBQUdoUSxXQUFXLENBQUMsVUFBVSxFQUFFLGdCQUFnQjJGLE1BQU12QyxLQUFLLENBQUM0TSxTQUFTLEVBQUU7Z0JBQ2pGLGtCQUFrQnJLLE1BQU12QyxLQUFLLENBQUM2TSxRQUFRO2dCQUN0QyxxQkFBcUI7WUFDdkI7WUFFQSxJQUFJakosT0FBT3RFLGNBQWNBLGNBQWMsQ0FBQyxHQUFHaUQsTUFBTXZDLEtBQUssR0FBR3VDLE1BQU1RLEtBQUs7WUFFcEUsSUFBSStKLGFBQWEsQ0FBQyxHQUFHalEsa0JBQWtCa1EsYUFBYSxFQUFFbkosTUFBTTtnQkFBQztnQkFBUTtnQkFBVztnQkFBUztnQkFBWTtnQkFBYztnQkFBaUI7Z0JBQWdCO2dCQUFZO2dCQUFrQjtnQkFBTztnQkFBYztnQkFBZTtnQkFBYztnQkFBWTtnQkFBZ0I7Z0JBQWtCO2dCQUFjO2dCQUFjO2dCQUFpQjtnQkFBVztnQkFBaUI7Z0JBQWU7YUFBUztZQUNuWCxJQUFJb0osZUFBZXpLLE1BQU12QyxLQUFLLENBQUNnTixZQUFZO1lBQzNDRixhQUFheE4sY0FBY0EsY0FBYyxDQUFDLEdBQUd3TixhQUFhLENBQUMsR0FBRztnQkFDNURHLGNBQWNELGVBQWV6SyxNQUFNMkssV0FBVyxHQUFHO2dCQUNqREMsY0FBY0gsZUFBZXpLLE1BQU02SyxZQUFZLEdBQUc7Z0JBQ2xEQyxhQUFhTCxlQUFlekssTUFBTTJLLFdBQVcsR0FBRztnQkFDaERyQyxlQUFldEksTUFBTXZDLEtBQUssQ0FBQzZLLGFBQWEsSUFBSXRJLE1BQU13SSxTQUFTLEdBQUd4SSxNQUFNK0ssYUFBYSxHQUFHO1lBQ3RGO1lBQ0EsSUFBSUM7WUFFSixJQUFJaEwsTUFBTXZDLEtBQUssQ0FBQ3VOLElBQUksS0FBSyxRQUFRaEwsTUFBTVEsS0FBSyxDQUFDb0YsVUFBVSxJQUFJNUYsTUFBTXZDLEtBQUssQ0FBQzRHLFlBQVksRUFBRTtnQkFDbkYsSUFBSTRHLFdBQVcsQ0FBQyxHQUFHM1Esa0JBQWtCa1EsYUFBYSxFQUFFbkosTUFBTTtvQkFBQztvQkFBYTtvQkFBYztvQkFBZ0I7b0JBQWdCO29CQUFrQjtvQkFBZ0I7b0JBQVk7b0JBQWdCO29CQUFZO2lCQUFhO2dCQUM3TSxJQUFJNkosbUJBQW1CbEwsTUFBTXZDLEtBQUssQ0FBQ3lOLGdCQUFnQjtnQkFDbkRELFdBQVdsTyxjQUFjQSxjQUFjLENBQUMsR0FBR2tPLFdBQVcsQ0FBQyxHQUFHO29CQUN4REUsY0FBY25MLE1BQU1rRSxXQUFXO29CQUMvQndHLGNBQWNRLG1CQUFtQmxMLE1BQU1vTCxXQUFXLEdBQUc7b0JBQ3JETixhQUFhSSxtQkFBbUJsTCxNQUFNcUwsVUFBVSxHQUFHO29CQUNuRFQsY0FBY00sbUJBQW1CbEwsTUFBTW9MLFdBQVcsR0FBRztnQkFDdkQ7Z0JBQ0FKLE9BQU8sV0FBVyxHQUFFaFIsTUFBTSxDQUFDLFVBQVUsQ0FBQ3NSLGFBQWEsQ0FBQzlRLE1BQU0rUSxJQUFJLEVBQUVOO1lBQ2xFO1lBRUEsSUFBSU8sV0FBV0M7WUFDZixJQUFJQyxhQUFhLENBQUMsR0FBR3BSLGtCQUFrQmtRLGFBQWEsRUFBRW5KLE1BQU07Z0JBQUM7Z0JBQVk7Z0JBQWM7Z0JBQWdCO2dCQUFjO2dCQUFnQjtnQkFBYTthQUFZO1lBQzlKcUssV0FBV1AsWUFBWSxHQUFHbkwsTUFBTWtFLFdBQVc7WUFFM0MsSUFBSWxFLE1BQU12QyxLQUFLLENBQUNrTyxNQUFNLEVBQUU7Z0JBQ3RCSCxZQUFZLFdBQVcsR0FBRXhSLE1BQU0sQ0FBQyxVQUFVLENBQUNzUixhQUFhLENBQUM3USxRQUFRbVIsU0FBUyxFQUFFRjtnQkFDNUVELFlBQVksV0FBVyxHQUFFelIsTUFBTSxDQUFDLFVBQVUsQ0FBQ3NSLGFBQWEsQ0FBQzdRLFFBQVFvUixTQUFTLEVBQUVIO1lBQzlFO1lBRUEsSUFBSUksc0JBQXNCO1lBRTFCLElBQUk5TCxNQUFNdkMsS0FBSyxDQUFDNk0sUUFBUSxFQUFFO2dCQUN4QndCLHNCQUFzQjtvQkFDcEJuTCxRQUFRWCxNQUFNUSxLQUFLLENBQUN1TCxVQUFVO2dCQUNoQztZQUNGO1lBRUEsSUFBSUMscUJBQXFCO1lBRXpCLElBQUloTSxNQUFNdkMsS0FBSyxDQUFDNk0sUUFBUSxLQUFLLE9BQU87Z0JBQ2xDLElBQUl0SyxNQUFNdkMsS0FBSyxDQUFDMkksVUFBVSxLQUFLLE1BQU07b0JBQ25DNEYscUJBQXFCO3dCQUNuQkMsU0FBUyxTQUFTak0sTUFBTXZDLEtBQUssQ0FBQ3lPLGFBQWE7b0JBQzdDO2dCQUNGO1lBQ0YsT0FBTztnQkFDTCxJQUFJbE0sTUFBTXZDLEtBQUssQ0FBQzJJLFVBQVUsS0FBSyxNQUFNO29CQUNuQzRGLHFCQUFxQjt3QkFDbkJDLFNBQVNqTSxNQUFNdkMsS0FBSyxDQUFDeU8sYUFBYSxHQUFHO29CQUN2QztnQkFDRjtZQUNGO1lBRUEsSUFBSUMsWUFBWXBQLGNBQWNBLGNBQWMsQ0FBQyxHQUFHK08sc0JBQXNCRTtZQUV0RSxJQUFJSSxZQUFZcE0sTUFBTXZDLEtBQUssQ0FBQzJPLFNBQVM7WUFDckMsSUFBSUMsWUFBWTtnQkFDZGhDLFdBQVc7Z0JBQ1gzSixPQUFPeUw7Z0JBQ1BHLFNBQVN0TSxNQUFNbUwsWUFBWTtnQkFDM0JvQixhQUFhSCxZQUFZcE0sTUFBTW9KLFVBQVUsR0FBRztnQkFDNUNvRCxhQUFheE0sTUFBTVEsS0FBSyxDQUFDaU0sUUFBUSxJQUFJTCxZQUFZcE0sTUFBTXVKLFNBQVMsR0FBRztnQkFDbkVtRCxXQUFXTixZQUFZcE0sTUFBTXdKLFFBQVEsR0FBRztnQkFDeENvQixjQUFjNUssTUFBTVEsS0FBSyxDQUFDaU0sUUFBUSxJQUFJTCxZQUFZcE0sTUFBTXdKLFFBQVEsR0FBRztnQkFDbkVtRCxjQUFjUCxZQUFZcE0sTUFBTW9KLFVBQVUsR0FBRztnQkFDN0N3RCxhQUFhNU0sTUFBTVEsS0FBSyxDQUFDaU0sUUFBUSxJQUFJTCxZQUFZcE0sTUFBTXVKLFNBQVMsR0FBRztnQkFDbkVzRCxZQUFZVCxZQUFZcE0sTUFBTThNLFFBQVEsR0FBRztnQkFDekNDLGVBQWUvTSxNQUFNUSxLQUFLLENBQUNpTSxRQUFRLElBQUlMLFlBQVlwTSxNQUFNd0osUUFBUSxHQUFHO2dCQUNwRXdELFdBQVdoTixNQUFNdkMsS0FBSyxDQUFDb0wsYUFBYSxHQUFHN0ksTUFBTTRJLFVBQVUsR0FBRztZQUM1RDtZQUNBLElBQUlxRSxtQkFBbUI7Z0JBQ3JCNUMsV0FBV0E7Z0JBQ1gxQixLQUFLO2dCQUNMakksT0FBT1YsTUFBTXZDLEtBQUssQ0FBQ2lELEtBQUs7WUFDMUI7WUFFQSxJQUFJVixNQUFNdkMsS0FBSyxDQUFDeVAsT0FBTyxFQUFFO2dCQUN2QmIsWUFBWTtvQkFDVmhDLFdBQVc7Z0JBQ2I7Z0JBQ0E0QyxtQkFBbUI7b0JBQ2pCNUMsV0FBV0E7Z0JBQ2I7WUFDRjtZQUVBLE9BQU8sV0FBVyxHQUFFclEsTUFBTSxDQUFDLFVBQVUsQ0FBQ3NSLGFBQWEsQ0FBQyxPQUFPMkIsa0JBQWtCLENBQUNqTixNQUFNdkMsS0FBSyxDQUFDeVAsT0FBTyxHQUFHMUIsWUFBWSxJQUFJLFdBQVcsR0FBRXhSLE1BQU0sQ0FBQyxVQUFVLENBQUNzUixhQUFhLENBQUMsT0FBT3BRLFNBQVM7Z0JBQy9LK0UsS0FBS0QsTUFBTW1OLGNBQWM7WUFDM0IsR0FBR2QsWUFBWSxXQUFXLEdBQUVyUyxNQUFNLENBQUMsVUFBVSxDQUFDc1IsYUFBYSxDQUFDL1EsT0FBTzZTLEtBQUssRUFBRWxTLFNBQVM7Z0JBQ2pGK0UsS0FBS0QsTUFBTXFOLGVBQWU7WUFDNUIsR0FBRzlDLGFBQWF2SyxNQUFNdkMsS0FBSyxDQUFDd0csUUFBUSxJQUFJLENBQUNqRSxNQUFNdkMsS0FBSyxDQUFDeVAsT0FBTyxHQUFHekIsWUFBWSxJQUFJLENBQUN6TCxNQUFNdkMsS0FBSyxDQUFDeVAsT0FBTyxHQUFHbEMsT0FBTztRQUMvRztRQUVBaEwsTUFBTUUsSUFBSSxHQUFHO1FBQ2JGLE1BQU1HLEtBQUssR0FBRztRQUNkSCxNQUFNUSxLQUFLLEdBQUd6RCxjQUFjQSxjQUFjLENBQUMsR0FBRzVDLGFBQWEsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxHQUFHO1lBQzNFc0csY0FBY1QsTUFBTXZDLEtBQUssQ0FBQzZQLFlBQVk7WUFDdEMxSCxZQUFZNUwsTUFBTSxDQUFDLFVBQVUsQ0FBQytKLFFBQVEsQ0FBQ0MsS0FBSyxDQUFDaEUsTUFBTXZDLEtBQUssQ0FBQ3dHLFFBQVE7UUFDbkU7UUFDQWpFLE1BQU1rQyxjQUFjLEdBQUcsRUFBRTtRQUN6QmxDLE1BQU13SSxTQUFTLEdBQUc7UUFDbEJ4SSxNQUFNdUUsZUFBZSxHQUFHO1FBRXhCLElBQUlnSixXQUFXdk4sTUFBTXdOLE9BQU87UUFFNUJ4TixNQUFNUSxLQUFLLEdBQUd6RCxjQUFjQSxjQUFjLENBQUMsR0FBR2lELE1BQU1RLEtBQUssR0FBRytNO1FBQzVELE9BQU92TjtJQUNUO0lBRUFuQyxhQUFhOUQsYUFBYTtRQUFDO1lBQ3pCMEIsS0FBSztZQUNMM0IsT0FBTyxTQUFTZ0ssZUFBZUosU0FBUztnQkFDdEMsSUFBSUcsZ0JBQWdCO2dCQUVwQixJQUFLLElBQUk0SixNQUFNLEdBQUdDLGVBQWUvVCxPQUFPMEMsSUFBSSxDQUFDLElBQUksQ0FBQ29CLEtBQUssR0FBR2dRLE1BQU1DLGFBQWFuUyxNQUFNLEVBQUVrUyxNQUFPO29CQUMxRixJQUFJaFMsTUFBTWlTLFlBQVksQ0FBQ0QsSUFBSTtvQkFFM0IsSUFBSSxDQUFDL0osVUFBVWhJLGNBQWMsQ0FBQ0QsTUFBTTt3QkFDbENvSSxnQkFBZ0I7d0JBQ2hCO29CQUNGO29CQUVBLElBQUloSixRQUFRNkksU0FBUyxDQUFDakksSUFBSSxNQUFNLFlBQVksT0FBT2lJLFNBQVMsQ0FBQ2pJLElBQUksS0FBSyxZQUFZO3dCQUNoRjtvQkFDRjtvQkFFQSxJQUFJaUksU0FBUyxDQUFDakksSUFBSSxLQUFLLElBQUksQ0FBQ2dDLEtBQUssQ0FBQ2hDLElBQUksRUFBRTt3QkFDdENvSSxnQkFBZ0I7d0JBQ2hCO29CQUNGO2dCQUNGO2dCQUVBLE9BQU9BLGlCQUFpQjdKLE1BQU0sQ0FBQyxVQUFVLENBQUMrSixRQUFRLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUN2RyxLQUFLLENBQUN3RyxRQUFRLE1BQU1qSyxNQUFNLENBQUMsVUFBVSxDQUFDK0osUUFBUSxDQUFDQyxLQUFLLENBQUNOLFVBQVVPLFFBQVE7WUFDdkk7UUFDRjtLQUFFO0lBRUYsT0FBT2xLO0FBQ1QsRUFBRUMsTUFBTSxDQUFDLFVBQVUsQ0FBQzJULFNBQVM7QUFFN0I5VCxtQkFBbUIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bml2ZXJzYWwtZGVtby1hcHAvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL2lubmVyLXNsaWRlci5qcz9lOGFkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Jbm5lclNsaWRlciA9IHZvaWQgMDtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9pbml0aWFsU3RhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2luaXRpYWwtc3RhdGVcIikpO1xuXG52YXIgX2xvZGFzaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC5kZWJvdW5jZVwiKSk7XG5cbnZhciBfY2xhc3NuYW1lcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsYXNzbmFtZXNcIikpO1xuXG52YXIgX2lubmVyU2xpZGVyVXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy9pbm5lclNsaWRlclV0aWxzXCIpO1xuXG52YXIgX3RyYWNrID0gcmVxdWlyZShcIi4vdHJhY2tcIik7XG5cbnZhciBfZG90cyA9IHJlcXVpcmUoXCIuL2RvdHNcIik7XG5cbnZhciBfYXJyb3dzID0gcmVxdWlyZShcIi4vYXJyb3dzXCIpO1xuXG52YXIgX3Jlc2l6ZU9ic2VydmVyUG9seWZpbGwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGxcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIElubmVyU2xpZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhJbm5lclNsaWRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihJbm5lclNsaWRlcik7XG5cbiAgZnVuY3Rpb24gSW5uZXJTbGlkZXIocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5uZXJTbGlkZXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibGlzdFJlZkhhbmRsZXJcIiwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgcmV0dXJuIF90aGlzLmxpc3QgPSByZWY7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwidHJhY2tSZWZIYW5kbGVyXCIsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHJldHVybiBfdGhpcy50cmFjayA9IHJlZjtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJhZGFwdEhlaWdodFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMuYWRhcHRpdmVIZWlnaHQgJiYgX3RoaXMubGlzdCkge1xuICAgICAgICB2YXIgZWxlbSA9IF90aGlzLmxpc3QucXVlcnlTZWxlY3RvcihcIltkYXRhLWluZGV4PVxcXCJcIi5jb25jYXQoX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlLCBcIlxcXCJdXCIpKTtcblxuICAgICAgICBfdGhpcy5saXN0LnN0eWxlLmhlaWdodCA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5nZXRIZWlnaHQpKGVsZW0pICsgXCJweFwiO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNvbXBvbmVudERpZE1vdW50XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnByb3BzLm9uSW5pdCAmJiBfdGhpcy5wcm9wcy5vbkluaXQoKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLmxhenlMb2FkKSB7XG4gICAgICAgIHZhciBzbGlkZXNUb0xvYWQgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuZ2V0T25EZW1hbmRMYXp5U2xpZGVzKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF90aGlzLnByb3BzKSwgX3RoaXMuc3RhdGUpKTtcblxuICAgICAgICBpZiAoc2xpZGVzVG9Mb2FkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBsYXp5TG9hZGVkTGlzdDogcHJldlN0YXRlLmxhenlMb2FkZWRMaXN0LmNvbmNhdChzbGlkZXNUb0xvYWQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uTGF6eUxvYWQpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTGF6eUxvYWQoc2xpZGVzVG9Mb2FkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNwZWMgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgbGlzdFJlZjogX3RoaXMubGlzdCxcbiAgICAgICAgdHJhY2tSZWY6IF90aGlzLnRyYWNrXG4gICAgICB9LCBfdGhpcy5wcm9wcyk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZVN0YXRlKHNwZWMsIHRydWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuYWRhcHRIZWlnaHQoKTtcblxuICAgICAgICBfdGhpcy5wcm9wcy5hdXRvcGxheSAmJiBfdGhpcy5hdXRvUGxheShcInVwZGF0ZVwiKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMubGF6eUxvYWQgPT09IFwicHJvZ3Jlc3NpdmVcIikge1xuICAgICAgICBfdGhpcy5sYXp5TG9hZFRpbWVyID0gc2V0SW50ZXJ2YWwoX3RoaXMucHJvZ3Jlc3NpdmVMYXp5TG9hZCwgMTAwMCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnJvID0gbmV3IF9yZXNpemVPYnNlcnZlclBvbHlmaWxsW1wiZGVmYXVsdFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5zdGF0ZS5hbmltYXRpbmcpIHtcbiAgICAgICAgICBfdGhpcy5vbldpbmRvd1Jlc2l6ZWQoZmFsc2UpOyAvLyBkb24ndCBzZXQgdHJhY2tTdHlsZSBoZW5jZSBkb24ndCBicmVhayBhbmltYXRpb25cblxuXG4gICAgICAgICAgX3RoaXMuY2FsbGJhY2tUaW1lcnMucHVzaChzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5vbldpbmRvd1Jlc2l6ZWQoKTtcbiAgICAgICAgICB9LCBfdGhpcy5wcm9wcy5zcGVlZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLm9uV2luZG93UmVzaXplZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgX3RoaXMucm8ub2JzZXJ2ZShfdGhpcy5saXN0KTtcblxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCAmJiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2xpY2stc2xpZGVcIiksIGZ1bmN0aW9uIChzbGlkZSkge1xuICAgICAgICBzbGlkZS5vbmZvY3VzID0gX3RoaXMucHJvcHMucGF1c2VPbkZvY3VzID8gX3RoaXMub25TbGlkZUZvY3VzIDogbnVsbDtcbiAgICAgICAgc2xpZGUub25ibHVyID0gX3RoaXMucHJvcHMucGF1c2VPbkZvY3VzID8gX3RoaXMub25TbGlkZUJsdXIgOiBudWxsO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBfdGhpcy5vbldpbmRvd1Jlc2l6ZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmF0dGFjaEV2ZW50KFwib25yZXNpemVcIiwgX3RoaXMub25XaW5kb3dSZXNpemVkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuYW5pbWF0aW9uRW5kQ2FsbGJhY2spIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmFuaW1hdGlvbkVuZENhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLmxhenlMb2FkVGltZXIpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChfdGhpcy5sYXp5TG9hZFRpbWVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLmNhbGxiYWNrVGltZXJzLmxlbmd0aCkge1xuICAgICAgICBfdGhpcy5jYWxsYmFja1RpbWVycy5mb3JFYWNoKGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpcy5jYWxsYmFja1RpbWVycyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgX3RoaXMub25XaW5kb3dSZXNpemVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5kZXRhY2hFdmVudChcIm9ucmVzaXplXCIsIF90aGlzLm9uV2luZG93UmVzaXplZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5hdXRvcGxheVRpbWVyKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoX3RoaXMuYXV0b3BsYXlUaW1lcik7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnJvLmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjb21wb25lbnREaWRVcGRhdGVcIiwgZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgX3RoaXMuY2hlY2tJbWFnZXNMb2FkKCk7XG5cbiAgICAgIF90aGlzLnByb3BzLm9uUmVJbml0ICYmIF90aGlzLnByb3BzLm9uUmVJbml0KCk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5sYXp5TG9hZCkge1xuICAgICAgICB2YXIgc2xpZGVzVG9Mb2FkID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmdldE9uRGVtYW5kTGF6eVNsaWRlcykoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKSk7XG5cbiAgICAgICAgaWYgKHNsaWRlc1RvTG9hZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHByZXZTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbGF6eUxvYWRlZExpc3Q6IHByZXZTdGF0ZS5sYXp5TG9hZGVkTGlzdC5jb25jYXQoc2xpZGVzVG9Mb2FkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkxhenlMb2FkKSB7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxhenlMb2FkKHNsaWRlc1RvTG9hZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIGlmICh0aGlzLnByb3BzLm9uTGF6eUxvYWQpIHtcbiAgICAgIC8vICAgdGhpcy5wcm9wcy5vbkxhenlMb2FkKFtsZWZ0TW9zdFNsaWRlXSlcbiAgICAgIC8vIH1cblxuXG4gICAgICBfdGhpcy5hZGFwdEhlaWdodCgpO1xuXG4gICAgICB2YXIgc3BlYyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGxpc3RSZWY6IF90aGlzLmxpc3QsXG4gICAgICAgIHRyYWNrUmVmOiBfdGhpcy50cmFja1xuICAgICAgfSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSk7XG5cbiAgICAgIHZhciBzZXRUcmFja1N0eWxlID0gX3RoaXMuZGlkUHJvcHNDaGFuZ2UocHJldlByb3BzKTtcblxuICAgICAgc2V0VHJhY2tTdHlsZSAmJiBfdGhpcy51cGRhdGVTdGF0ZShzcGVjLCBzZXRUcmFja1N0eWxlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5zdGF0ZS5jdXJyZW50U2xpZGUgPj0gX3JlYWN0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5jb3VudChfdGhpcy5wcm9wcy5jaGlsZHJlbikpIHtcbiAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgICBtZXNzYWdlOiBcImluZGV4XCIsXG4gICAgICAgICAgICBpbmRleDogX3JlYWN0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5jb3VudChfdGhpcy5wcm9wcy5jaGlsZHJlbikgLSBfdGhpcy5wcm9wcy5zbGlkZXNUb1Nob3csXG4gICAgICAgICAgICBjdXJyZW50U2xpZGU6IF90aGlzLnN0YXRlLmN1cnJlbnRTbGlkZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzLnByb3BzLmF1dG9wbGF5KSB7XG4gICAgICAgICAgX3RoaXMuYXV0b1BsYXkoXCJ1cGRhdGVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMucGF1c2UoXCJwYXVzZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uV2luZG93UmVzaXplZFwiLCBmdW5jdGlvbiAoc2V0VHJhY2tTdHlsZSkge1xuICAgICAgaWYgKF90aGlzLmRlYm91bmNlZFJlc2l6ZSkgX3RoaXMuZGVib3VuY2VkUmVzaXplLmNhbmNlbCgpO1xuICAgICAgX3RoaXMuZGVib3VuY2VkUmVzaXplID0gKDAsIF9sb2Rhc2hbXCJkZWZhdWx0XCJdKShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5yZXNpemVXaW5kb3coc2V0VHJhY2tTdHlsZSk7XG4gICAgICB9LCA1MCk7XG5cbiAgICAgIF90aGlzLmRlYm91bmNlZFJlc2l6ZSgpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInJlc2l6ZVdpbmRvd1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2V0VHJhY2tTdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgIHZhciBpc1RyYWNrTW91bnRlZCA9IEJvb2xlYW4oX3RoaXMudHJhY2sgJiYgX3RoaXMudHJhY2subm9kZSk7IC8vIHByZXZlbnQgd2FybmluZzogc2V0dGluZyBzdGF0ZSBvbiB1bm1vdW50ZWQgY29tcG9uZW50IChzZXJ2ZXIgc2lkZSByZW5kZXJpbmcpXG5cbiAgICAgIGlmICghaXNUcmFja01vdW50ZWQpIHJldHVybjtcblxuICAgICAgdmFyIHNwZWMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBsaXN0UmVmOiBfdGhpcy5saXN0LFxuICAgICAgICB0cmFja1JlZjogX3RoaXMudHJhY2tcbiAgICAgIH0sIF90aGlzLnByb3BzKSwgX3RoaXMuc3RhdGUpO1xuXG4gICAgICBfdGhpcy51cGRhdGVTdGF0ZShzcGVjLCBzZXRUcmFja1N0eWxlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5wcm9wcy5hdXRvcGxheSkgX3RoaXMuYXV0b1BsYXkoXCJ1cGRhdGVcIik7ZWxzZSBfdGhpcy5wYXVzZShcInBhdXNlZFwiKTtcbiAgICAgIH0pOyAvLyBhbmltYXRpbmcgc3RhdGUgc2hvdWxkIGJlIGNsZWFyZWQgd2hpbGUgcmVzaXppbmcsIG90aGVyd2lzZSBhdXRvcGxheSBzdG9wcyB3b3JraW5nXG5cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBhbmltYXRpbmc6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmFuaW1hdGlvbkVuZENhbGxiYWNrKTtcbiAgICAgIGRlbGV0ZSBfdGhpcy5hbmltYXRpb25FbmRDYWxsYmFjaztcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ1cGRhdGVTdGF0ZVwiLCBmdW5jdGlvbiAoc3BlYywgc2V0VHJhY2tTdHlsZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciB1cGRhdGVkU3RhdGUgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuaW5pdGlhbGl6ZWRTdGF0ZSkoc3BlYyk7XG4gICAgICBzcGVjID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB1cGRhdGVkU3RhdGUpLCB7fSwge1xuICAgICAgICBzbGlkZUluZGV4OiB1cGRhdGVkU3RhdGUuY3VycmVudFNsaWRlXG4gICAgICB9KTtcbiAgICAgIHZhciB0YXJnZXRMZWZ0ID0gKDAsIF9pbm5lclNsaWRlclV0aWxzLmdldFRyYWNrTGVmdCkoc3BlYyk7XG4gICAgICBzcGVjID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgICAgbGVmdDogdGFyZ2V0TGVmdFxuICAgICAgfSk7XG4gICAgICB2YXIgdHJhY2tTdHlsZSA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5nZXRUcmFja0NTUykoc3BlYyk7XG5cbiAgICAgIGlmIChzZXRUcmFja1N0eWxlIHx8IF9yZWFjdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4uY291bnQoX3RoaXMucHJvcHMuY2hpbGRyZW4pICE9PSBfcmVhY3RbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmNvdW50KHNwZWMuY2hpbGRyZW4pKSB7XG4gICAgICAgIHVwZGF0ZWRTdGF0ZVtcInRyYWNrU3R5bGVcIl0gPSB0cmFja1N0eWxlO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh1cGRhdGVkU3RhdGUsIGNhbGxiYWNrKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzc3JJbml0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy52YXJpYWJsZVdpZHRoKSB7XG4gICAgICAgIHZhciBfdHJhY2tXaWR0aCA9IDAsXG4gICAgICAgICAgICBfdHJhY2tMZWZ0ID0gMDtcbiAgICAgICAgdmFyIGNoaWxkcmVuV2lkdGhzID0gW107XG4gICAgICAgIHZhciBwcmVDbG9uZXMgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuZ2V0UHJlQ2xvbmVzKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSksIHt9LCB7XG4gICAgICAgICAgc2xpZGVDb3VudDogX3RoaXMucHJvcHMuY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIHBvc3RDbG9uZXMgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuZ2V0UG9zdENsb25lcykoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF90aGlzLnByb3BzKSwgX3RoaXMuc3RhdGUpLCB7fSwge1xuICAgICAgICAgIHNsaWRlQ291bnQ6IF90aGlzLnByb3BzLmNoaWxkcmVuLmxlbmd0aFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgX3RoaXMucHJvcHMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICBjaGlsZHJlbldpZHRocy5wdXNoKGNoaWxkLnByb3BzLnN0eWxlLndpZHRoKTtcbiAgICAgICAgICBfdHJhY2tXaWR0aCArPSBjaGlsZC5wcm9wcy5zdHlsZS53aWR0aDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVDbG9uZXM7IGkrKykge1xuICAgICAgICAgIF90cmFja0xlZnQgKz0gY2hpbGRyZW5XaWR0aHNbY2hpbGRyZW5XaWR0aHMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICAgIF90cmFja1dpZHRoICs9IGNoaWxkcmVuV2lkdGhzW2NoaWxkcmVuV2lkdGhzLmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBwb3N0Q2xvbmVzOyBfaSsrKSB7XG4gICAgICAgICAgX3RyYWNrV2lkdGggKz0gY2hpbGRyZW5XaWR0aHNbX2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlOyBfaTIrKykge1xuICAgICAgICAgIF90cmFja0xlZnQgKz0gY2hpbGRyZW5XaWR0aHNbX2kyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfdHJhY2tTdHlsZSA9IHtcbiAgICAgICAgICB3aWR0aDogX3RyYWNrV2lkdGggKyBcInB4XCIsXG4gICAgICAgICAgbGVmdDogLV90cmFja0xlZnQgKyBcInB4XCJcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoX3RoaXMucHJvcHMuY2VudGVyTW9kZSkge1xuICAgICAgICAgIHZhciBjdXJyZW50V2lkdGggPSBcIlwiLmNvbmNhdChjaGlsZHJlbldpZHRoc1tfdGhpcy5zdGF0ZS5jdXJyZW50U2xpZGVdLCBcInB4XCIpO1xuICAgICAgICAgIF90cmFja1N0eWxlLmxlZnQgPSBcImNhbGMoXCIuY29uY2F0KF90cmFja1N0eWxlLmxlZnQsIFwiICsgKDEwMCUgLSBcIikuY29uY2F0KGN1cnJlbnRXaWR0aCwgXCIpIC8gMiApIFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhY2tTdHlsZTogX3RyYWNrU3R5bGVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuQ291bnQgPSBfcmVhY3RbXCJkZWZhdWx0XCJdLkNoaWxkcmVuLmNvdW50KF90aGlzLnByb3BzLmNoaWxkcmVuKTtcblxuICAgICAgdmFyIHNwZWMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSksIHt9LCB7XG4gICAgICAgIHNsaWRlQ291bnQ6IGNoaWxkcmVuQ291bnRcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc2xpZGVDb3VudCA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5nZXRQcmVDbG9uZXMpKHNwZWMpICsgKDAsIF9pbm5lclNsaWRlclV0aWxzLmdldFBvc3RDbG9uZXMpKHNwZWMpICsgY2hpbGRyZW5Db3VudDtcbiAgICAgIHZhciB0cmFja1dpZHRoID0gMTAwIC8gX3RoaXMucHJvcHMuc2xpZGVzVG9TaG93ICogc2xpZGVDb3VudDtcbiAgICAgIHZhciBzbGlkZVdpZHRoID0gMTAwIC8gc2xpZGVDb3VudDtcbiAgICAgIHZhciB0cmFja0xlZnQgPSAtc2xpZGVXaWR0aCAqICgoMCwgX2lubmVyU2xpZGVyVXRpbHMuZ2V0UHJlQ2xvbmVzKShzcGVjKSArIF90aGlzLnN0YXRlLmN1cnJlbnRTbGlkZSkgKiB0cmFja1dpZHRoIC8gMTAwO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMuY2VudGVyTW9kZSkge1xuICAgICAgICB0cmFja0xlZnQgKz0gKDEwMCAtIHNsaWRlV2lkdGggKiB0cmFja1dpZHRoIC8gMTAwKSAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmFja1N0eWxlID0ge1xuICAgICAgICB3aWR0aDogdHJhY2tXaWR0aCArIFwiJVwiLFxuICAgICAgICBsZWZ0OiB0cmFja0xlZnQgKyBcIiVcIlxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNsaWRlV2lkdGg6IHNsaWRlV2lkdGggKyBcIiVcIixcbiAgICAgICAgdHJhY2tTdHlsZTogdHJhY2tTdHlsZVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjaGVja0ltYWdlc0xvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGltYWdlcyA9IF90aGlzLmxpc3QgJiYgX3RoaXMubGlzdC5xdWVyeVNlbGVjdG9yQWxsICYmIF90aGlzLmxpc3QucXVlcnlTZWxlY3RvckFsbChcIi5zbGljay1zbGlkZSBpbWdcIikgfHwgW107XG4gICAgICB2YXIgaW1hZ2VzQ291bnQgPSBpbWFnZXMubGVuZ3RoLFxuICAgICAgICAgIGxvYWRlZENvdW50ID0gMDtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoaW1hZ2VzLCBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICAgIHJldHVybiArK2xvYWRlZENvdW50ICYmIGxvYWRlZENvdW50ID49IGltYWdlc0NvdW50ICYmIF90aGlzLm9uV2luZG93UmVzaXplZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghaW1hZ2Uub25jbGljaykge1xuICAgICAgICAgIGltYWdlLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1hZ2UucGFyZW50Tm9kZS5mb2N1cygpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZDbGlja0hhbmRsZXIgPSBpbWFnZS5vbmNsaWNrO1xuXG4gICAgICAgICAgaW1hZ2Uub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByZXZDbGlja0hhbmRsZXIoKTtcbiAgICAgICAgICAgIGltYWdlLnBhcmVudE5vZGUuZm9jdXMoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbWFnZS5vbmxvYWQpIHtcbiAgICAgICAgICBpZiAoX3RoaXMucHJvcHMubGF6eUxvYWQpIHtcbiAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMuYWRhcHRIZWlnaHQoKTtcblxuICAgICAgICAgICAgICBfdGhpcy5jYWxsYmFja1RpbWVycy5wdXNoKHNldFRpbWVvdXQoX3RoaXMub25XaW5kb3dSZXNpemVkLCBfdGhpcy5wcm9wcy5zcGVlZCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gaGFuZGxlcjtcblxuICAgICAgICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxhenlMb2FkRXJyb3IgJiYgX3RoaXMucHJvcHMub25MYXp5TG9hZEVycm9yKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwicHJvZ3Jlc3NpdmVMYXp5TG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2xpZGVzVG9Mb2FkID0gW107XG5cbiAgICAgIHZhciBzcGVjID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKTtcblxuICAgICAgZm9yICh2YXIgaW5kZXggPSBfdGhpcy5zdGF0ZS5jdXJyZW50U2xpZGU7IGluZGV4IDwgX3RoaXMuc3RhdGUuc2xpZGVDb3VudCArICgwLCBfaW5uZXJTbGlkZXJVdGlscy5nZXRQb3N0Q2xvbmVzKShzcGVjKTsgaW5kZXgrKykge1xuICAgICAgICBpZiAoX3RoaXMuc3RhdGUubGF6eUxvYWRlZExpc3QuaW5kZXhPZihpbmRleCkgPCAwKSB7XG4gICAgICAgICAgc2xpZGVzVG9Mb2FkLnB1c2goaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pbmRleCA9IF90aGlzLnN0YXRlLmN1cnJlbnRTbGlkZSAtIDE7IF9pbmRleCA+PSAtKDAsIF9pbm5lclNsaWRlclV0aWxzLmdldFByZUNsb25lcykoc3BlYyk7IF9pbmRleC0tKSB7XG4gICAgICAgIGlmIChfdGhpcy5zdGF0ZS5sYXp5TG9hZGVkTGlzdC5pbmRleE9mKF9pbmRleCkgPCAwKSB7XG4gICAgICAgICAgc2xpZGVzVG9Mb2FkLnB1c2goX2luZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2xpZGVzVG9Mb2FkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhenlMb2FkZWRMaXN0OiBzdGF0ZS5sYXp5TG9hZGVkTGlzdC5jb25jYXQoc2xpZGVzVG9Mb2FkKVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkxhenlMb2FkKSB7XG4gICAgICAgICAgX3RoaXMucHJvcHMub25MYXp5TG9hZChzbGlkZXNUb0xvYWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX3RoaXMubGF6eUxvYWRUaW1lcikge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoX3RoaXMubGF6eUxvYWRUaW1lcik7XG4gICAgICAgICAgZGVsZXRlIF90aGlzLmxhenlMb2FkVGltZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzbGlkZUhhbmRsZXJcIiwgZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICB2YXIgZG9udEFuaW1hdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgYXNOYXZGb3IgPSBfdGhpcyRwcm9wcy5hc05hdkZvcixcbiAgICAgICAgICBiZWZvcmVDaGFuZ2UgPSBfdGhpcyRwcm9wcy5iZWZvcmVDaGFuZ2UsXG4gICAgICAgICAgb25MYXp5TG9hZCA9IF90aGlzJHByb3BzLm9uTGF6eUxvYWQsXG4gICAgICAgICAgc3BlZWQgPSBfdGhpcyRwcm9wcy5zcGVlZCxcbiAgICAgICAgICBhZnRlckNoYW5nZSA9IF90aGlzJHByb3BzLmFmdGVyQ2hhbmdlOyAvLyBjYXB0dXJlIGN1cnJlbnRzbGlkZSBiZWZvcmUgc3RhdGUgaXMgdXBkYXRlZFxuXG4gICAgICB2YXIgY3VycmVudFNsaWRlID0gX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlO1xuXG4gICAgICB2YXIgX3NsaWRlSGFuZGxlciA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5zbGlkZUhhbmRsZXIpKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICB9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKSwge30sIHtcbiAgICAgICAgdHJhY2tSZWY6IF90aGlzLnRyYWNrLFxuICAgICAgICB1c2VDU1M6IF90aGlzLnByb3BzLnVzZUNTUyAmJiAhZG9udEFuaW1hdGVcbiAgICAgIH0pKSxcbiAgICAgICAgICBzdGF0ZSA9IF9zbGlkZUhhbmRsZXIuc3RhdGUsXG4gICAgICAgICAgbmV4dFN0YXRlID0gX3NsaWRlSGFuZGxlci5uZXh0U3RhdGU7XG5cbiAgICAgIGlmICghc3RhdGUpIHJldHVybjtcbiAgICAgIGJlZm9yZUNoYW5nZSAmJiBiZWZvcmVDaGFuZ2UoY3VycmVudFNsaWRlLCBzdGF0ZS5jdXJyZW50U2xpZGUpO1xuICAgICAgdmFyIHNsaWRlc1RvTG9hZCA9IHN0YXRlLmxhenlMb2FkZWRMaXN0LmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnN0YXRlLmxhenlMb2FkZWRMaXN0LmluZGV4T2YodmFsdWUpIDwgMDtcbiAgICAgIH0pO1xuICAgICAgb25MYXp5TG9hZCAmJiBzbGlkZXNUb0xvYWQubGVuZ3RoID4gMCAmJiBvbkxhenlMb2FkKHNsaWRlc1RvTG9hZCk7XG5cbiAgICAgIGlmICghX3RoaXMucHJvcHMud2FpdEZvckFuaW1hdGUgJiYgX3RoaXMuYW5pbWF0aW9uRW5kQ2FsbGJhY2spIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmFuaW1hdGlvbkVuZENhbGxiYWNrKTtcbiAgICAgICAgYWZ0ZXJDaGFuZ2UgJiYgYWZ0ZXJDaGFuZ2UoY3VycmVudFNsaWRlKTtcbiAgICAgICAgZGVsZXRlIF90aGlzLmFuaW1hdGlvbkVuZENhbGxiYWNrO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zZXRTdGF0ZShzdGF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhc05hdkZvckluZGV4IGNoZWNrIGlzIHRvIGF2b2lkIHJlY3Vyc2l2ZSBjYWxscyBvZiBzbGlkZUhhbmRsZXIgaW4gd2FpdEZvckFuaW1hdGU9ZmFsc2UgbW9kZVxuICAgICAgICBpZiAoYXNOYXZGb3IgJiYgX3RoaXMuYXNOYXZGb3JJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgICAgICBfdGhpcy5hc05hdkZvckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYXNOYXZGb3IuaW5uZXJTbGlkZXIuc2xpZGVIYW5kbGVyKGluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmV4dFN0YXRlKSByZXR1cm47XG4gICAgICAgIF90aGlzLmFuaW1hdGlvbkVuZENhbGxiYWNrID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGFuaW1hdGluZyA9IG5leHRTdGF0ZS5hbmltYXRpbmcsXG4gICAgICAgICAgICAgIGZpcnN0QmF0Y2ggPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobmV4dFN0YXRlLCBbXCJhbmltYXRpbmdcIl0pO1xuXG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZmlyc3RCYXRjaCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2FsbGJhY2tUaW1lcnMucHVzaChzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBhbmltYXRpbmc6IGFuaW1hdGluZ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIDEwKSk7XG5cbiAgICAgICAgICAgIGFmdGVyQ2hhbmdlICYmIGFmdGVyQ2hhbmdlKHN0YXRlLmN1cnJlbnRTbGlkZSk7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMuYW5pbWF0aW9uRW5kQ2FsbGJhY2s7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIHNwZWVkKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNoYW5nZVNsaWRlXCIsIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgZG9udEFuaW1hdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICB2YXIgc3BlYyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3RoaXMucHJvcHMpLCBfdGhpcy5zdGF0ZSk7XG5cbiAgICAgIHZhciB0YXJnZXRTbGlkZSA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5jaGFuZ2VTbGlkZSkoc3BlYywgb3B0aW9ucyk7XG4gICAgICBpZiAodGFyZ2V0U2xpZGUgIT09IDAgJiYgIXRhcmdldFNsaWRlKSByZXR1cm47XG5cbiAgICAgIGlmIChkb250QW5pbWF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBfdGhpcy5zbGlkZUhhbmRsZXIodGFyZ2V0U2xpZGUsIGRvbnRBbmltYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnNsaWRlSGFuZGxlcih0YXJnZXRTbGlkZSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnByb3BzLmF1dG9wbGF5ICYmIF90aGlzLmF1dG9QbGF5KFwidXBkYXRlXCIpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMuZm9jdXNPblNlbGVjdCkge1xuICAgICAgICB2YXIgbm9kZXMgPSBfdGhpcy5saXN0LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2xpY2stY3VycmVudFwiKTtcblxuICAgICAgICBub2Rlc1swXSAmJiBub2Rlc1swXS5mb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNsaWNrSGFuZGxlclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKF90aGlzLmNsaWNrYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5jbGlja2FibGUgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImtleUhhbmRsZXJcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBkaXIgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMua2V5SGFuZGxlcikoZSwgX3RoaXMucHJvcHMuYWNjZXNzaWJpbGl0eSwgX3RoaXMucHJvcHMucnRsKTtcbiAgICAgIGRpciAhPT0gXCJcIiAmJiBfdGhpcy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgIG1lc3NhZ2U6IGRpclxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2VsZWN0SGFuZGxlclwiLCBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgX3RoaXMuY2hhbmdlU2xpZGUob3B0aW9ucyk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZGlzYWJsZUJvZHlTY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xuICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIHdpbmRvdy5vbnRvdWNobW92ZSA9IHByZXZlbnREZWZhdWx0O1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImVuYWJsZUJvZHlTY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgd2luZG93Lm9udG91Y2htb3ZlID0gbnVsbDtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzd2lwZVN0YXJ0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMudmVydGljYWxTd2lwaW5nKSB7XG4gICAgICAgIF90aGlzLmRpc2FibGVCb2R5U2Nyb2xsKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGF0ZSA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5zd2lwZVN0YXJ0KShlLCBfdGhpcy5wcm9wcy5zd2lwZSwgX3RoaXMucHJvcHMuZHJhZ2dhYmxlKTtcbiAgICAgIHN0YXRlICE9PSBcIlwiICYmIF90aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzd2lwZU1vdmVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBzdGF0ZSA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5zd2lwZU1vdmUpKGUsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKSwge30sIHtcbiAgICAgICAgdHJhY2tSZWY6IF90aGlzLnRyYWNrLFxuICAgICAgICBsaXN0UmVmOiBfdGhpcy5saXN0LFxuICAgICAgICBzbGlkZUluZGV4OiBfdGhpcy5zdGF0ZS5jdXJyZW50U2xpZGVcbiAgICAgIH0pKTtcbiAgICAgIGlmICghc3RhdGUpIHJldHVybjtcblxuICAgICAgaWYgKHN0YXRlW1wic3dpcGluZ1wiXSkge1xuICAgICAgICBfdGhpcy5jbGlja2FibGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN3aXBlRW5kXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgc3RhdGUgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuc3dpcGVFbmQpKGUsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKSwge30sIHtcbiAgICAgICAgdHJhY2tSZWY6IF90aGlzLnRyYWNrLFxuICAgICAgICBsaXN0UmVmOiBfdGhpcy5saXN0LFxuICAgICAgICBzbGlkZUluZGV4OiBfdGhpcy5zdGF0ZS5jdXJyZW50U2xpZGVcbiAgICAgIH0pKTtcbiAgICAgIGlmICghc3RhdGUpIHJldHVybjtcbiAgICAgIHZhciB0cmlnZ2VyU2xpZGVIYW5kbGVyID0gc3RhdGVbXCJ0cmlnZ2VyU2xpZGVIYW5kbGVyXCJdO1xuICAgICAgZGVsZXRlIHN0YXRlW1widHJpZ2dlclNsaWRlSGFuZGxlclwiXTtcblxuICAgICAgX3RoaXMuc2V0U3RhdGUoc3RhdGUpO1xuXG4gICAgICBpZiAodHJpZ2dlclNsaWRlSGFuZGxlciA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgIF90aGlzLnNsaWRlSGFuZGxlcih0cmlnZ2VyU2xpZGVIYW5kbGVyKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLnZlcnRpY2FsU3dpcGluZykge1xuICAgICAgICBfdGhpcy5lbmFibGVCb2R5U2Nyb2xsKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwidG91Y2hFbmRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIF90aGlzLnN3aXBlRW5kKGUpO1xuXG4gICAgICBfdGhpcy5jbGlja2FibGUgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNsaWNrUHJldlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB0aGlzIGFuZCBmZWxsb3cgbWV0aG9kcyBhcmUgd3JhcHBlZCBpbiBzZXRUaW1lb3V0XG4gICAgICAvLyB0byBtYWtlIHN1cmUgaW5pdGlhbGl6ZSBzZXRTdGF0ZSBoYXMgaGFwcGVuZWQgYmVmb3JlXG4gICAgICAvLyBhbnkgb2Ygc3VjaCBtZXRob2RzIGFyZSBjYWxsZWRcbiAgICAgIF90aGlzLmNhbGxiYWNrVGltZXJzLnB1c2goc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5jaGFuZ2VTbGlkZSh7XG4gICAgICAgICAgbWVzc2FnZTogXCJwcmV2aW91c1wiXG4gICAgICAgIH0pO1xuICAgICAgfSwgMCkpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNsaWNrTmV4dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5jYWxsYmFja1RpbWVycy5wdXNoKHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuY2hhbmdlU2xpZGUoe1xuICAgICAgICAgIG1lc3NhZ2U6IFwibmV4dFwiXG4gICAgICAgIH0pO1xuICAgICAgfSwgMCkpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNsaWNrR29Ub1wiLCBmdW5jdGlvbiAoc2xpZGUpIHtcbiAgICAgIHZhciBkb250QW5pbWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICBzbGlkZSA9IE51bWJlcihzbGlkZSk7XG4gICAgICBpZiAoaXNOYU4oc2xpZGUpKSByZXR1cm4gXCJcIjtcblxuICAgICAgX3RoaXMuY2FsbGJhY2tUaW1lcnMucHVzaChzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmNoYW5nZVNsaWRlKHtcbiAgICAgICAgICBtZXNzYWdlOiBcImluZGV4XCIsXG4gICAgICAgICAgaW5kZXg6IHNsaWRlLFxuICAgICAgICAgIGN1cnJlbnRTbGlkZTogX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlXG4gICAgICAgIH0sIGRvbnRBbmltYXRlKTtcbiAgICAgIH0sIDApKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJwbGF5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuZXh0SW5kZXg7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5ydGwpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gX3RoaXMuc3RhdGUuY3VycmVudFNsaWRlIC0gX3RoaXMucHJvcHMuc2xpZGVzVG9TY3JvbGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKDAsIF9pbm5lclNsaWRlclV0aWxzLmNhbkdvTmV4dCkoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfdGhpcy5wcm9wcyksIF90aGlzLnN0YXRlKSkpIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBfdGhpcy5zdGF0ZS5jdXJyZW50U2xpZGUgKyBfdGhpcy5wcm9wcy5zbGlkZXNUb1Njcm9sbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2xpZGVIYW5kbGVyKG5leHRJbmRleCk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiYXV0b1BsYXlcIiwgZnVuY3Rpb24gKHBsYXlUeXBlKSB7XG4gICAgICBpZiAoX3RoaXMuYXV0b3BsYXlUaW1lcikge1xuICAgICAgICBjbGVhckludGVydmFsKF90aGlzLmF1dG9wbGF5VGltZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXV0b3BsYXlpbmcgPSBfdGhpcy5zdGF0ZS5hdXRvcGxheWluZztcblxuICAgICAgaWYgKHBsYXlUeXBlID09PSBcInVwZGF0ZVwiKSB7XG4gICAgICAgIGlmIChhdXRvcGxheWluZyA9PT0gXCJob3ZlcmVkXCIgfHwgYXV0b3BsYXlpbmcgPT09IFwiZm9jdXNlZFwiIHx8IGF1dG9wbGF5aW5nID09PSBcInBhdXNlZFwiKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBsYXlUeXBlID09PSBcImxlYXZlXCIpIHtcbiAgICAgICAgaWYgKGF1dG9wbGF5aW5nID09PSBcInBhdXNlZFwiIHx8IGF1dG9wbGF5aW5nID09PSBcImZvY3VzZWRcIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwbGF5VHlwZSA9PT0gXCJibHVyXCIpIHtcbiAgICAgICAgaWYgKGF1dG9wbGF5aW5nID09PSBcInBhdXNlZFwiIHx8IGF1dG9wbGF5aW5nID09PSBcImhvdmVyZWRcIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfdGhpcy5hdXRvcGxheVRpbWVyID0gc2V0SW50ZXJ2YWwoX3RoaXMucGxheSwgX3RoaXMucHJvcHMuYXV0b3BsYXlTcGVlZCArIDUwKTtcblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBhdXRvcGxheWluZzogXCJwbGF5aW5nXCJcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInBhdXNlXCIsIGZ1bmN0aW9uIChwYXVzZVR5cGUpIHtcbiAgICAgIGlmIChfdGhpcy5hdXRvcGxheVRpbWVyKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoX3RoaXMuYXV0b3BsYXlUaW1lcik7XG4gICAgICAgIF90aGlzLmF1dG9wbGF5VGltZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXV0b3BsYXlpbmcgPSBfdGhpcy5zdGF0ZS5hdXRvcGxheWluZztcblxuICAgICAgaWYgKHBhdXNlVHlwZSA9PT0gXCJwYXVzZWRcIikge1xuICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgYXV0b3BsYXlpbmc6IFwicGF1c2VkXCJcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHBhdXNlVHlwZSA9PT0gXCJmb2N1c2VkXCIpIHtcbiAgICAgICAgaWYgKGF1dG9wbGF5aW5nID09PSBcImhvdmVyZWRcIiB8fCBhdXRvcGxheWluZyA9PT0gXCJwbGF5aW5nXCIpIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBhdXRvcGxheWluZzogXCJmb2N1c2VkXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcGF1c2VUeXBlICBpcyAnaG92ZXJlZCdcbiAgICAgICAgaWYgKGF1dG9wbGF5aW5nID09PSBcInBsYXlpbmdcIikge1xuICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGF1dG9wbGF5aW5nOiBcImhvdmVyZWRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25Eb3RzT3ZlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucHJvcHMuYXV0b3BsYXkgJiYgX3RoaXMucGF1c2UoXCJob3ZlcmVkXCIpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uRG90c0xlYXZlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5hdXRvcGxheSAmJiBfdGhpcy5zdGF0ZS5hdXRvcGxheWluZyA9PT0gXCJob3ZlcmVkXCIgJiYgX3RoaXMuYXV0b1BsYXkoXCJsZWF2ZVwiKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvblRyYWNrT3ZlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucHJvcHMuYXV0b3BsYXkgJiYgX3RoaXMucGF1c2UoXCJob3ZlcmVkXCIpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uVHJhY2tMZWF2ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucHJvcHMuYXV0b3BsYXkgJiYgX3RoaXMuc3RhdGUuYXV0b3BsYXlpbmcgPT09IFwiaG92ZXJlZFwiICYmIF90aGlzLmF1dG9QbGF5KFwibGVhdmVcIik7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25TbGlkZUZvY3VzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5hdXRvcGxheSAmJiBfdGhpcy5wYXVzZShcImZvY3VzZWRcIik7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25TbGlkZUJsdXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmF1dG9wbGF5ICYmIF90aGlzLnN0YXRlLmF1dG9wbGF5aW5nID09PSBcImZvY3VzZWRcIiAmJiBfdGhpcy5hdXRvUGxheShcImJsdXJcIik7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwicmVuZGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjbGFzc05hbWUgPSAoMCwgX2NsYXNzbmFtZXNbXCJkZWZhdWx0XCJdKShcInNsaWNrLXNsaWRlclwiLCBfdGhpcy5wcm9wcy5jbGFzc05hbWUsIHtcbiAgICAgICAgXCJzbGljay12ZXJ0aWNhbFwiOiBfdGhpcy5wcm9wcy52ZXJ0aWNhbCxcbiAgICAgICAgXCJzbGljay1pbml0aWFsaXplZFwiOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgdmFyIHNwZWMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF90aGlzLnByb3BzKSwgX3RoaXMuc3RhdGUpO1xuXG4gICAgICB2YXIgdHJhY2tQcm9wcyA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5leHRyYWN0T2JqZWN0KShzcGVjLCBbXCJmYWRlXCIsIFwiY3NzRWFzZVwiLCBcInNwZWVkXCIsIFwiaW5maW5pdGVcIiwgXCJjZW50ZXJNb2RlXCIsIFwiZm9jdXNPblNlbGVjdFwiLCBcImN1cnJlbnRTbGlkZVwiLCBcImxhenlMb2FkXCIsIFwibGF6eUxvYWRlZExpc3RcIiwgXCJydGxcIiwgXCJzbGlkZVdpZHRoXCIsIFwic2xpZGVIZWlnaHRcIiwgXCJsaXN0SGVpZ2h0XCIsIFwidmVydGljYWxcIiwgXCJzbGlkZXNUb1Nob3dcIiwgXCJzbGlkZXNUb1Njcm9sbFwiLCBcInNsaWRlQ291bnRcIiwgXCJ0cmFja1N0eWxlXCIsIFwidmFyaWFibGVXaWR0aFwiLCBcInVuc2xpY2tcIiwgXCJjZW50ZXJQYWRkaW5nXCIsIFwidGFyZ2V0U2xpZGVcIiwgXCJ1c2VDU1NcIl0pO1xuICAgICAgdmFyIHBhdXNlT25Ib3ZlciA9IF90aGlzLnByb3BzLnBhdXNlT25Ib3ZlcjtcbiAgICAgIHRyYWNrUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRyYWNrUHJvcHMpLCB7fSwge1xuICAgICAgICBvbk1vdXNlRW50ZXI6IHBhdXNlT25Ib3ZlciA/IF90aGlzLm9uVHJhY2tPdmVyIDogbnVsbCxcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBwYXVzZU9uSG92ZXIgPyBfdGhpcy5vblRyYWNrTGVhdmUgOiBudWxsLFxuICAgICAgICBvbk1vdXNlT3ZlcjogcGF1c2VPbkhvdmVyID8gX3RoaXMub25UcmFja092ZXIgOiBudWxsLFxuICAgICAgICBmb2N1c09uU2VsZWN0OiBfdGhpcy5wcm9wcy5mb2N1c09uU2VsZWN0ICYmIF90aGlzLmNsaWNrYWJsZSA/IF90aGlzLnNlbGVjdEhhbmRsZXIgOiBudWxsXG4gICAgICB9KTtcbiAgICAgIHZhciBkb3RzO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMuZG90cyA9PT0gdHJ1ZSAmJiBfdGhpcy5zdGF0ZS5zbGlkZUNvdW50ID49IF90aGlzLnByb3BzLnNsaWRlc1RvU2hvdykge1xuICAgICAgICB2YXIgZG90UHJvcHMgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuZXh0cmFjdE9iamVjdCkoc3BlYywgW1wiZG90c0NsYXNzXCIsIFwic2xpZGVDb3VudFwiLCBcInNsaWRlc1RvU2hvd1wiLCBcImN1cnJlbnRTbGlkZVwiLCBcInNsaWRlc1RvU2Nyb2xsXCIsIFwiY2xpY2tIYW5kbGVyXCIsIFwiY2hpbGRyZW5cIiwgXCJjdXN0b21QYWdpbmdcIiwgXCJpbmZpbml0ZVwiLCBcImFwcGVuZERvdHNcIl0pO1xuICAgICAgICB2YXIgcGF1c2VPbkRvdHNIb3ZlciA9IF90aGlzLnByb3BzLnBhdXNlT25Eb3RzSG92ZXI7XG4gICAgICAgIGRvdFByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkb3RQcm9wcyksIHt9LCB7XG4gICAgICAgICAgY2xpY2tIYW5kbGVyOiBfdGhpcy5jaGFuZ2VTbGlkZSxcbiAgICAgICAgICBvbk1vdXNlRW50ZXI6IHBhdXNlT25Eb3RzSG92ZXIgPyBfdGhpcy5vbkRvdHNMZWF2ZSA6IG51bGwsXG4gICAgICAgICAgb25Nb3VzZU92ZXI6IHBhdXNlT25Eb3RzSG92ZXIgPyBfdGhpcy5vbkRvdHNPdmVyIDogbnVsbCxcbiAgICAgICAgICBvbk1vdXNlTGVhdmU6IHBhdXNlT25Eb3RzSG92ZXIgPyBfdGhpcy5vbkRvdHNMZWF2ZSA6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIGRvdHMgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9kb3RzLkRvdHMsIGRvdFByb3BzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZBcnJvdywgbmV4dEFycm93O1xuICAgICAgdmFyIGFycm93UHJvcHMgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuZXh0cmFjdE9iamVjdCkoc3BlYywgW1wiaW5maW5pdGVcIiwgXCJjZW50ZXJNb2RlXCIsIFwiY3VycmVudFNsaWRlXCIsIFwic2xpZGVDb3VudFwiLCBcInNsaWRlc1RvU2hvd1wiLCBcInByZXZBcnJvd1wiLCBcIm5leHRBcnJvd1wiXSk7XG4gICAgICBhcnJvd1Byb3BzLmNsaWNrSGFuZGxlciA9IF90aGlzLmNoYW5nZVNsaWRlO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMuYXJyb3dzKSB7XG4gICAgICAgIHByZXZBcnJvdyA9IC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX2Fycm93cy5QcmV2QXJyb3csIGFycm93UHJvcHMpO1xuICAgICAgICBuZXh0QXJyb3cgPSAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KF9hcnJvd3MuTmV4dEFycm93LCBhcnJvd1Byb3BzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZlcnRpY2FsSGVpZ2h0U3R5bGUgPSBudWxsO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMudmVydGljYWwpIHtcbiAgICAgICAgdmVydGljYWxIZWlnaHRTdHlsZSA9IHtcbiAgICAgICAgICBoZWlnaHQ6IF90aGlzLnN0YXRlLmxpc3RIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNlbnRlclBhZGRpbmdTdHlsZSA9IG51bGw7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICBjZW50ZXJQYWRkaW5nU3R5bGUgPSB7XG4gICAgICAgICAgICBwYWRkaW5nOiBcIjBweCBcIiArIF90aGlzLnByb3BzLmNlbnRlclBhZGRpbmdcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX3RoaXMucHJvcHMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNlbnRlclBhZGRpbmdTdHlsZSA9IHtcbiAgICAgICAgICAgIHBhZGRpbmc6IF90aGlzLnByb3BzLmNlbnRlclBhZGRpbmcgKyBcIiAwcHhcIlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGxpc3RTdHlsZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdmVydGljYWxIZWlnaHRTdHlsZSksIGNlbnRlclBhZGRpbmdTdHlsZSk7XG5cbiAgICAgIHZhciB0b3VjaE1vdmUgPSBfdGhpcy5wcm9wcy50b3VjaE1vdmU7XG4gICAgICB2YXIgbGlzdFByb3BzID0ge1xuICAgICAgICBjbGFzc05hbWU6IFwic2xpY2stbGlzdFwiLFxuICAgICAgICBzdHlsZTogbGlzdFN0eWxlLFxuICAgICAgICBvbkNsaWNrOiBfdGhpcy5jbGlja0hhbmRsZXIsXG4gICAgICAgIG9uTW91c2VEb3duOiB0b3VjaE1vdmUgPyBfdGhpcy5zd2lwZVN0YXJ0IDogbnVsbCxcbiAgICAgICAgb25Nb3VzZU1vdmU6IF90aGlzLnN0YXRlLmRyYWdnaW5nICYmIHRvdWNoTW92ZSA/IF90aGlzLnN3aXBlTW92ZSA6IG51bGwsXG4gICAgICAgIG9uTW91c2VVcDogdG91Y2hNb3ZlID8gX3RoaXMuc3dpcGVFbmQgOiBudWxsLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IF90aGlzLnN0YXRlLmRyYWdnaW5nICYmIHRvdWNoTW92ZSA/IF90aGlzLnN3aXBlRW5kIDogbnVsbCxcbiAgICAgICAgb25Ub3VjaFN0YXJ0OiB0b3VjaE1vdmUgPyBfdGhpcy5zd2lwZVN0YXJ0IDogbnVsbCxcbiAgICAgICAgb25Ub3VjaE1vdmU6IF90aGlzLnN0YXRlLmRyYWdnaW5nICYmIHRvdWNoTW92ZSA/IF90aGlzLnN3aXBlTW92ZSA6IG51bGwsXG4gICAgICAgIG9uVG91Y2hFbmQ6IHRvdWNoTW92ZSA/IF90aGlzLnRvdWNoRW5kIDogbnVsbCxcbiAgICAgICAgb25Ub3VjaENhbmNlbDogX3RoaXMuc3RhdGUuZHJhZ2dpbmcgJiYgdG91Y2hNb3ZlID8gX3RoaXMuc3dpcGVFbmQgOiBudWxsLFxuICAgICAgICBvbktleURvd246IF90aGlzLnByb3BzLmFjY2Vzc2liaWxpdHkgPyBfdGhpcy5rZXlIYW5kbGVyIDogbnVsbFxuICAgICAgfTtcbiAgICAgIHZhciBpbm5lclNsaWRlclByb3BzID0ge1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgZGlyOiBcImx0clwiLFxuICAgICAgICBzdHlsZTogX3RoaXMucHJvcHMuc3R5bGVcbiAgICAgIH07XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy51bnNsaWNrKSB7XG4gICAgICAgIGxpc3RQcm9wcyA9IHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwic2xpY2stbGlzdFwiXG4gICAgICAgIH07XG4gICAgICAgIGlubmVyU2xpZGVyUHJvcHMgPSB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgaW5uZXJTbGlkZXJQcm9wcywgIV90aGlzLnByb3BzLnVuc2xpY2sgPyBwcmV2QXJyb3cgOiBcIlwiLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICAgICAgcmVmOiBfdGhpcy5saXN0UmVmSGFuZGxlclxuICAgICAgfSwgbGlzdFByb3BzKSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChfdHJhY2suVHJhY2ssIF9leHRlbmRzKHtcbiAgICAgICAgcmVmOiBfdGhpcy50cmFja1JlZkhhbmRsZXJcbiAgICAgIH0sIHRyYWNrUHJvcHMpLCBfdGhpcy5wcm9wcy5jaGlsZHJlbikpLCAhX3RoaXMucHJvcHMudW5zbGljayA/IG5leHRBcnJvdyA6IFwiXCIsICFfdGhpcy5wcm9wcy51bnNsaWNrID8gZG90cyA6IFwiXCIpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMubGlzdCA9IG51bGw7XG4gICAgX3RoaXMudHJhY2sgPSBudWxsO1xuICAgIF90aGlzLnN0YXRlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfaW5pdGlhbFN0YXRlW1wiZGVmYXVsdFwiXSksIHt9LCB7XG4gICAgICBjdXJyZW50U2xpZGU6IF90aGlzLnByb3BzLmluaXRpYWxTbGlkZSxcbiAgICAgIHNsaWRlQ291bnQ6IF9yZWFjdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4uY291bnQoX3RoaXMucHJvcHMuY2hpbGRyZW4pXG4gICAgfSk7XG4gICAgX3RoaXMuY2FsbGJhY2tUaW1lcnMgPSBbXTtcbiAgICBfdGhpcy5jbGlja2FibGUgPSB0cnVlO1xuICAgIF90aGlzLmRlYm91bmNlZFJlc2l6ZSA9IG51bGw7XG5cbiAgICB2YXIgc3NyU3RhdGUgPSBfdGhpcy5zc3JJbml0KCk7XG5cbiAgICBfdGhpcy5zdGF0ZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3RoaXMuc3RhdGUpLCBzc3JTdGF0ZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKElubmVyU2xpZGVyLCBbe1xuICAgIGtleTogXCJkaWRQcm9wc0NoYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaWRQcm9wc0NoYW5nZShwcmV2UHJvcHMpIHtcbiAgICAgIHZhciBzZXRUcmFja1N0eWxlID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDAsIF9PYmplY3Qka2V5cyA9IE9iamVjdC5rZXlzKHRoaXMucHJvcHMpOyBfaTMgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICB2YXIga2V5ID0gX09iamVjdCRrZXlzW19pM107XG5cbiAgICAgICAgaWYgKCFwcmV2UHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHNldFRyYWNrU3R5bGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90eXBlb2YocHJldlByb3BzW2tleV0pID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBwcmV2UHJvcHNba2V5XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldlByb3BzW2tleV0gIT09IHRoaXMucHJvcHNba2V5XSkge1xuICAgICAgICAgIHNldFRyYWNrU3R5bGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXRUcmFja1N0eWxlIHx8IF9yZWFjdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4uY291bnQodGhpcy5wcm9wcy5jaGlsZHJlbikgIT09IF9yZWFjdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4uY291bnQocHJldlByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW5uZXJTbGlkZXI7XG59KF9yZWFjdFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuZXhwb3J0cy5Jbm5lclNsaWRlciA9IElubmVyU2xpZGVyOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIklubmVyU2xpZGVyIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfaW5pdGlhbFN0YXRlIiwiX2xvZGFzaCIsIl9jbGFzc25hbWVzIiwiX2lubmVyU2xpZGVyVXRpbHMiLCJfdHJhY2siLCJfZG90cyIsIl9hcnJvd3MiLCJfcmVzaXplT2JzZXJ2ZXJQb2x5ZmlsbCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9leHRlbmRzIiwiYXNzaWduIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJzb3VyY2VLZXlzIiwia2V5cyIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsInN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsIm8iLCJwIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfY3JlYXRlU3VwZXIiLCJEZXJpdmVkIiwiaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY3JlYXRlU3VwZXJJbnRlcm5hbCIsIlN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwicmVzdWx0IiwiTmV3VGFyZ2V0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsInNoYW0iLCJQcm94eSIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwiZSIsImdldFByb3RvdHlwZU9mIiwiX1JlYWN0JENvbXBvbmVudCIsIl9zdXBlciIsIl90aGlzIiwicmVmIiwibGlzdCIsInRyYWNrIiwiYWRhcHRpdmVIZWlnaHQiLCJlbGVtIiwicXVlcnlTZWxlY3RvciIsImNvbmNhdCIsInN0YXRlIiwiY3VycmVudFNsaWRlIiwic3R5bGUiLCJoZWlnaHQiLCJnZXRIZWlnaHQiLCJvbkluaXQiLCJsYXp5TG9hZCIsInNsaWRlc1RvTG9hZCIsImdldE9uRGVtYW5kTGF6eVNsaWRlcyIsInNldFN0YXRlIiwicHJldlN0YXRlIiwibGF6eUxvYWRlZExpc3QiLCJvbkxhenlMb2FkIiwic3BlYyIsImxpc3RSZWYiLCJ0cmFja1JlZiIsInVwZGF0ZVN0YXRlIiwiYWRhcHRIZWlnaHQiLCJhdXRvcGxheSIsImF1dG9QbGF5IiwibGF6eUxvYWRUaW1lciIsInNldEludGVydmFsIiwicHJvZ3Jlc3NpdmVMYXp5TG9hZCIsInJvIiwiYW5pbWF0aW5nIiwib25XaW5kb3dSZXNpemVkIiwiY2FsbGJhY2tUaW1lcnMiLCJzZXRUaW1lb3V0Iiwic3BlZWQiLCJvYnNlcnZlIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiQXJyYXkiLCJzbGlkZSIsIm9uZm9jdXMiLCJwYXVzZU9uRm9jdXMiLCJvblNsaWRlRm9jdXMiLCJvbmJsdXIiLCJvblNsaWRlQmx1ciIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsImFuaW1hdGlvbkVuZENhbGxiYWNrIiwiY2xlYXJUaW1lb3V0IiwiY2xlYXJJbnRlcnZhbCIsInRpbWVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRldGFjaEV2ZW50IiwiYXV0b3BsYXlUaW1lciIsImRpc2Nvbm5lY3QiLCJwcmV2UHJvcHMiLCJjaGVja0ltYWdlc0xvYWQiLCJvblJlSW5pdCIsInNldFRyYWNrU3R5bGUiLCJkaWRQcm9wc0NoYW5nZSIsIkNoaWxkcmVuIiwiY291bnQiLCJjaGlsZHJlbiIsImNoYW5nZVNsaWRlIiwibWVzc2FnZSIsImluZGV4Iiwic2xpZGVzVG9TaG93IiwicGF1c2UiLCJkZWJvdW5jZWRSZXNpemUiLCJjYW5jZWwiLCJyZXNpemVXaW5kb3ciLCJ1bmRlZmluZWQiLCJpc1RyYWNrTW91bnRlZCIsIm5vZGUiLCJjYWxsYmFjayIsInVwZGF0ZWRTdGF0ZSIsImluaXRpYWxpemVkU3RhdGUiLCJzbGlkZUluZGV4IiwidGFyZ2V0TGVmdCIsImdldFRyYWNrTGVmdCIsImxlZnQiLCJ0cmFja1N0eWxlIiwiZ2V0VHJhY2tDU1MiLCJ2YXJpYWJsZVdpZHRoIiwiX3RyYWNrV2lkdGgiLCJfdHJhY2tMZWZ0IiwiY2hpbGRyZW5XaWR0aHMiLCJwcmVDbG9uZXMiLCJnZXRQcmVDbG9uZXMiLCJzbGlkZUNvdW50IiwicG9zdENsb25lcyIsImdldFBvc3RDbG9uZXMiLCJjaGlsZCIsIndpZHRoIiwiX2kiLCJfaTIiLCJfdHJhY2tTdHlsZSIsImNlbnRlck1vZGUiLCJjdXJyZW50V2lkdGgiLCJjaGlsZHJlbkNvdW50IiwidHJhY2tXaWR0aCIsInNsaWRlV2lkdGgiLCJ0cmFja0xlZnQiLCJpbWFnZXMiLCJpbWFnZXNDb3VudCIsImxvYWRlZENvdW50IiwiaW1hZ2UiLCJoYW5kbGVyIiwib25jbGljayIsInBhcmVudE5vZGUiLCJmb2N1cyIsInByZXZDbGlja0hhbmRsZXIiLCJvbmxvYWQiLCJvbmVycm9yIiwib25MYXp5TG9hZEVycm9yIiwiX2luZGV4IiwiZG9udEFuaW1hdGUiLCJfdGhpcyRwcm9wcyIsImFzTmF2Rm9yIiwiYmVmb3JlQ2hhbmdlIiwiYWZ0ZXJDaGFuZ2UiLCJfc2xpZGVIYW5kbGVyIiwic2xpZGVIYW5kbGVyIiwidXNlQ1NTIiwibmV4dFN0YXRlIiwid2FpdEZvckFuaW1hdGUiLCJhc05hdkZvckluZGV4IiwiaW5uZXJTbGlkZXIiLCJmaXJzdEJhdGNoIiwib3B0aW9ucyIsInRhcmdldFNsaWRlIiwiZm9jdXNPblNlbGVjdCIsIm5vZGVzIiwiY2xpY2thYmxlIiwic3RvcFByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJkaXIiLCJrZXlIYW5kbGVyIiwiYWNjZXNzaWJpbGl0eSIsInJ0bCIsImV2ZW50IiwicmV0dXJuVmFsdWUiLCJvbnRvdWNobW92ZSIsInZlcnRpY2FsU3dpcGluZyIsImRpc2FibGVCb2R5U2Nyb2xsIiwic3dpcGVTdGFydCIsInN3aXBlIiwiZHJhZ2dhYmxlIiwic3dpcGVNb3ZlIiwic3dpcGVFbmQiLCJ0cmlnZ2VyU2xpZGVIYW5kbGVyIiwiZW5hYmxlQm9keVNjcm9sbCIsIk51bWJlciIsImlzTmFOIiwibmV4dEluZGV4Iiwic2xpZGVzVG9TY3JvbGwiLCJjYW5Hb05leHQiLCJwbGF5VHlwZSIsImF1dG9wbGF5aW5nIiwicGxheSIsImF1dG9wbGF5U3BlZWQiLCJwYXVzZVR5cGUiLCJjbGFzc05hbWUiLCJ2ZXJ0aWNhbCIsInRyYWNrUHJvcHMiLCJleHRyYWN0T2JqZWN0IiwicGF1c2VPbkhvdmVyIiwib25Nb3VzZUVudGVyIiwib25UcmFja092ZXIiLCJvbk1vdXNlTGVhdmUiLCJvblRyYWNrTGVhdmUiLCJvbk1vdXNlT3ZlciIsInNlbGVjdEhhbmRsZXIiLCJkb3RzIiwiZG90UHJvcHMiLCJwYXVzZU9uRG90c0hvdmVyIiwiY2xpY2tIYW5kbGVyIiwib25Eb3RzTGVhdmUiLCJvbkRvdHNPdmVyIiwiY3JlYXRlRWxlbWVudCIsIkRvdHMiLCJwcmV2QXJyb3ciLCJuZXh0QXJyb3ciLCJhcnJvd1Byb3BzIiwiYXJyb3dzIiwiUHJldkFycm93IiwiTmV4dEFycm93IiwidmVydGljYWxIZWlnaHRTdHlsZSIsImxpc3RIZWlnaHQiLCJjZW50ZXJQYWRkaW5nU3R5bGUiLCJwYWRkaW5nIiwiY2VudGVyUGFkZGluZyIsImxpc3RTdHlsZSIsInRvdWNoTW92ZSIsImxpc3RQcm9wcyIsIm9uQ2xpY2siLCJvbk1vdXNlRG93biIsIm9uTW91c2VNb3ZlIiwiZHJhZ2dpbmciLCJvbk1vdXNlVXAiLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoTW92ZSIsIm9uVG91Y2hFbmQiLCJ0b3VjaEVuZCIsIm9uVG91Y2hDYW5jZWwiLCJvbktleURvd24iLCJpbm5lclNsaWRlclByb3BzIiwidW5zbGljayIsImxpc3RSZWZIYW5kbGVyIiwiVHJhY2siLCJ0cmFja1JlZkhhbmRsZXIiLCJpbml0aWFsU2xpZGUiLCJzc3JTdGF0ZSIsInNzckluaXQiLCJfaTMiLCJfT2JqZWN0JGtleXMiLCJDb21wb25lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-slick/lib/inner-slider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-slick/lib/slider.js":
/*!************************************************!*\
  !*** ./node_modules/react-slick/lib/slider.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _innerSlider = __webpack_require__(/*! ./inner-slider */ \"(ssr)/./node_modules/react-slick/lib/inner-slider.js\");\nvar _json2mq = _interopRequireDefault(__webpack_require__(/*! json2mq */ \"(ssr)/./node_modules/json2mq/index.js\"));\nvar _defaultProps = _interopRequireDefault(__webpack_require__(/*! ./default-props */ \"(ssr)/./node_modules/react-slick/lib/default-props.js\"));\nvar _innerSliderUtils = __webpack_require__(/*! ./utils/innerSliderUtils */ \"(ssr)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nvar enquire = (0, _innerSliderUtils.canUseDOM)() && __webpack_require__(/*! enquire.js */ \"(ssr)/./node_modules/enquire.js/src/index.js\");\nvar Slider = /*#__PURE__*/ function(_React$Component) {\n    _inherits(Slider, _React$Component);\n    var _super = _createSuper(Slider);\n    function Slider(props) {\n        var _this;\n        _classCallCheck(this, Slider);\n        _this = _super.call(this, props);\n        _defineProperty(_assertThisInitialized(_this), \"innerSliderRefHandler\", function(ref) {\n            return _this.innerSlider = ref;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickPrev\", function() {\n            return _this.innerSlider.slickPrev();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickNext\", function() {\n            return _this.innerSlider.slickNext();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickGoTo\", function(slide) {\n            var dontAnimate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n            return _this.innerSlider.slickGoTo(slide, dontAnimate);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickPause\", function() {\n            return _this.innerSlider.pause(\"paused\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickPlay\", function() {\n            return _this.innerSlider.autoPlay(\"play\");\n        });\n        _this.state = {\n            breakpoint: null\n        };\n        _this._responsiveMediaHandlers = [];\n        return _this;\n    }\n    _createClass(Slider, [\n        {\n            key: \"media\",\n            value: function media(query, handler) {\n                // javascript handler for  css media query\n                enquire.register(query, handler);\n                this._responsiveMediaHandlers.push({\n                    query: query,\n                    handler: handler\n                });\n            } // handles responsive breakpoints\n        },\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                var _this2 = this;\n                // performance monitoring\n                //if (process.env.NODE_ENV !== 'production') {\n                //const { whyDidYouUpdate } = require('why-did-you-update')\n                //whyDidYouUpdate(React)\n                //}\n                if (this.props.responsive) {\n                    var breakpoints = this.props.responsive.map(function(breakpt) {\n                        return breakpt.breakpoint;\n                    }); // sort them in increasing order of their numerical value\n                    breakpoints.sort(function(x, y) {\n                        return x - y;\n                    });\n                    breakpoints.forEach(function(breakpoint, index) {\n                        // media query for each breakpoint\n                        var bQuery;\n                        if (index === 0) {\n                            bQuery = (0, _json2mq[\"default\"])({\n                                minWidth: 0,\n                                maxWidth: breakpoint\n                            });\n                        } else {\n                            bQuery = (0, _json2mq[\"default\"])({\n                                minWidth: breakpoints[index - 1] + 1,\n                                maxWidth: breakpoint\n                            });\n                        } // when not using server side rendering\n                        (0, _innerSliderUtils.canUseDOM)() && _this2.media(bQuery, function() {\n                            _this2.setState({\n                                breakpoint: breakpoint\n                            });\n                        });\n                    }); // Register media query for full screen. Need to support resize from small to large\n                    // convert javascript object to media query string\n                    var query = (0, _json2mq[\"default\"])({\n                        minWidth: breakpoints.slice(-1)[0]\n                    });\n                    (0, _innerSliderUtils.canUseDOM)() && this.media(query, function() {\n                        _this2.setState({\n                            breakpoint: null\n                        });\n                    });\n                }\n            }\n        },\n        {\n            key: \"componentWillUnmount\",\n            value: function componentWillUnmount() {\n                this._responsiveMediaHandlers.forEach(function(obj) {\n                    enquire.unregister(obj.query, obj.handler);\n                });\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this3 = this;\n                var settings;\n                var newProps;\n                if (this.state.breakpoint) {\n                    newProps = this.props.responsive.filter(function(resp) {\n                        return resp.breakpoint === _this3.state.breakpoint;\n                    });\n                    settings = newProps[0].settings === \"unslick\" ? \"unslick\" : _objectSpread(_objectSpread(_objectSpread({}, _defaultProps[\"default\"]), this.props), newProps[0].settings);\n                } else {\n                    settings = _objectSpread(_objectSpread({}, _defaultProps[\"default\"]), this.props);\n                } // force scrolling by one if centerMode is on\n                if (settings.centerMode) {\n                    if (settings.slidesToScroll > 1 && \"development\" !== \"production\") {\n                        console.warn(\"slidesToScroll should be equal to 1 in centerMode, you are using \".concat(settings.slidesToScroll));\n                    }\n                    settings.slidesToScroll = 1;\n                } // force showing one slide and scrolling by one if the fade mode is on\n                if (settings.fade) {\n                    if (settings.slidesToShow > 1 && \"development\" !== \"production\") {\n                        console.warn(\"slidesToShow should be equal to 1 when fade is true, you're using \".concat(settings.slidesToShow));\n                    }\n                    if (settings.slidesToScroll > 1 && \"development\" !== \"production\") {\n                        console.warn(\"slidesToScroll should be equal to 1 when fade is true, you're using \".concat(settings.slidesToScroll));\n                    }\n                    settings.slidesToShow = 1;\n                    settings.slidesToScroll = 1;\n                } // makes sure that children is an array, even when there is only 1 child\n                var children = _react[\"default\"].Children.toArray(this.props.children); // Children may contain false or null, so we should filter them\n                // children may also contain string filled with spaces (in certain cases where we use jsx strings)\n                children = children.filter(function(child) {\n                    if (typeof child === \"string\") {\n                        return !!child.trim();\n                    }\n                    return !!child;\n                }); // rows and slidesPerRow logic is handled here\n                if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {\n                    console.warn(\"variableWidth is not supported in case of rows > 1 or slidesPerRow > 1\");\n                    settings.variableWidth = false;\n                }\n                var newChildren = [];\n                var currentWidth = null;\n                for(var i = 0; i < children.length; i += settings.rows * settings.slidesPerRow){\n                    var newSlide = [];\n                    for(var j = i; j < i + settings.rows * settings.slidesPerRow; j += settings.slidesPerRow){\n                        var row = [];\n                        for(var k = j; k < j + settings.slidesPerRow; k += 1){\n                            if (settings.variableWidth && children[k].props.style) {\n                                currentWidth = children[k].props.style.width;\n                            }\n                            if (k >= children.length) break;\n                            row.push(/*#__PURE__*/ _react[\"default\"].cloneElement(children[k], {\n                                key: 100 * i + 10 * j + k,\n                                tabIndex: -1,\n                                style: {\n                                    width: \"\".concat(100 / settings.slidesPerRow, \"%\"),\n                                    display: \"inline-block\"\n                                }\n                            }));\n                        }\n                        newSlide.push(/*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n                            key: 10 * i + j\n                        }, row));\n                    }\n                    if (settings.variableWidth) {\n                        newChildren.push(/*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n                            key: i,\n                            style: {\n                                width: currentWidth\n                            }\n                        }, newSlide));\n                    } else {\n                        newChildren.push(/*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n                            key: i\n                        }, newSlide));\n                    }\n                }\n                if (settings === \"unslick\") {\n                    var className = \"regular slider \" + (this.props.className || \"\");\n                    return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n                        className: className\n                    }, children);\n                } else if (newChildren.length <= settings.slidesToShow) {\n                    settings.unslick = true;\n                }\n                return /*#__PURE__*/ _react[\"default\"].createElement(_innerSlider.InnerSlider, _extends({\n                    style: this.props.style,\n                    ref: this.innerSliderRefHandler\n                }, settings), newChildren);\n            }\n        }\n    ]);\n    return Slider;\n}(_react[\"default\"].Component);\nexports[\"default\"] = Slider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL3NsaWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLEdBQUc7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixHQUFHO1FBQUksT0FBTyxPQUFPQTtJQUFLLElBQUksU0FBVUEsR0FBRztRQUFJLE9BQU9BLE9BQU8sY0FBYyxPQUFPQyxVQUFVRCxJQUFJRyxXQUFXLEtBQUtGLFVBQVVELFFBQVFDLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUssR0FBR0QsUUFBUUM7QUFBTTtBQUUvVUssOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFrQixHQUFHLEtBQUs7QUFFMUIsSUFBSUUsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyx3R0FBTztBQUVuRCxJQUFJQyxlQUFlRCxtQkFBT0EsQ0FBQyw0RUFBZ0I7QUFFM0MsSUFBSUUsV0FBV0gsdUJBQXVCQyxtQkFBT0EsQ0FBQyxzREFBUztBQUV2RCxJQUFJRyxnQkFBZ0JKLHVCQUF1QkMsbUJBQU9BLENBQUMsOEVBQWlCO0FBRXBFLElBQUlJLG9CQUFvQkosbUJBQU9BLENBQUMsZ0dBQTBCO0FBRTFELFNBQVNELHVCQUF1QlYsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlnQixVQUFVLEdBQUdoQixNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUFHO0FBRWhHLFNBQVNpQjtJQUFhQSxXQUFXWixPQUFPYSxNQUFNLElBQUksU0FBVUMsTUFBTTtRQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFBRSxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFBRSxJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQUUsSUFBSWxCLE9BQU9ELFNBQVMsQ0FBQ3FCLGNBQWMsQ0FB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QUdDO29CQUNMLE9BQU87d0JBQ0xGLFlBQVk3RyxJQUFJLENBQUUsV0FBVyxHQUFFN0IsTUFBTSxDQUFDLFVBQVUsQ0FBQ3FKLGFBQWEsQ0FBQyxPQUFPOzRCQUNwRXRJLEtBQUtKO3dCQUNQLEdBQUdpSTtvQkFDTDtnQkFDRjtnQkFFQSxJQUFJckIsYUFBYSxXQUFXO29CQUMxQixJQUFJK0IsWUFBWSxvQkFBcUIsS0FBSSxDQUFDOUcsS0FBSyxDQUFDOEcsU0FBUyxJQUFJLEVBQUM7b0JBQzlELE9BQU8sV0FBVyxHQUFFdEosTUFBTSxDQUFDLFVBQVUsQ0FBQ3FKLGFBQWEsQ0FBQyxPQUFPO3dCQUN6REMsV0FBV0E7b0JBQ2IsR0FBR3BCO2dCQUNMLE9BQU8sSUFBSVEsWUFBWTdILE1BQU0sSUFBSTBHLFNBQVNVLFlBQVksRUFBRTtvQkFDdERWLFNBQVNnQyxPQUFPLEdBQUc7Z0JBQ3JCO2dCQUVBLE9BQU8sV0FBVyxHQUFFdkosTUFBTSxDQUFDLFVBQVUsQ0FBQ3FKLGFBQWEsQ0FBQ2xKLGFBQWFxSixXQUFXLEVBQUVoSixTQUFTO29CQUNyRndJLE9BQU8sSUFBSSxDQUFDeEcsS0FBSyxDQUFDd0csS0FBSztvQkFDdkI3RCxLQUFLLElBQUksQ0FBQ3NFLHFCQUFxQjtnQkFDakMsR0FBR2xDLFdBQVdtQjtZQUNoQjtRQUNGO0tBQUU7SUFFRixPQUFPM0Q7QUFDVCxFQUFFL0UsTUFBTSxDQUFDLFVBQVUsQ0FBQzBKLFNBQVM7QUFFN0I1SixrQkFBa0IsR0FBR2lGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pdmVyc2FsLWRlbW8tYXBwLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNsaWNrL2xpYi9zbGlkZXIuanM/ZDRhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfaW5uZXJTbGlkZXIgPSByZXF1aXJlKFwiLi9pbm5lci1zbGlkZXJcIik7XG5cbnZhciBfanNvbjJtcSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImpzb24ybXFcIikpO1xuXG52YXIgX2RlZmF1bHRQcm9wcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZGVmYXVsdC1wcm9wc1wiKSk7XG5cbnZhciBfaW5uZXJTbGlkZXJVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lubmVyU2xpZGVyVXRpbHNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGVucXVpcmUgPSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuY2FuVXNlRE9NKSgpICYmIHJlcXVpcmUoXCJlbnF1aXJlLmpzXCIpO1xuXG52YXIgU2xpZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTbGlkZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU2xpZGVyKTtcblxuICBmdW5jdGlvbiBTbGlkZXIocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2xpZGVyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImlubmVyU2xpZGVyUmVmSGFuZGxlclwiLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICByZXR1cm4gX3RoaXMuaW5uZXJTbGlkZXIgPSByZWY7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2xpY2tQcmV2XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5pbm5lclNsaWRlci5zbGlja1ByZXYoKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzbGlja05leHRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmlubmVyU2xpZGVyLnNsaWNrTmV4dCgpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNsaWNrR29Ub1wiLCBmdW5jdGlvbiAoc2xpZGUpIHtcbiAgICAgIHZhciBkb250QW5pbWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICByZXR1cm4gX3RoaXMuaW5uZXJTbGlkZXIuc2xpY2tHb1RvKHNsaWRlLCBkb250QW5pbWF0ZSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2xpY2tQYXVzZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuaW5uZXJTbGlkZXIucGF1c2UoXCJwYXVzZWRcIik7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2xpY2tQbGF5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5pbm5lclNsaWRlci5hdXRvUGxheShcInBsYXlcIik7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGJyZWFrcG9pbnQ6IG51bGxcbiAgICB9O1xuICAgIF90aGlzLl9yZXNwb25zaXZlTWVkaWFIYW5kbGVycyA9IFtdO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTbGlkZXIsIFt7XG4gICAga2V5OiBcIm1lZGlhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lZGlhKHF1ZXJ5LCBoYW5kbGVyKSB7XG4gICAgICAvLyBqYXZhc2NyaXB0IGhhbmRsZXIgZm9yICBjc3MgbWVkaWEgcXVlcnlcbiAgICAgIGVucXVpcmUucmVnaXN0ZXIocXVlcnksIGhhbmRsZXIpO1xuXG4gICAgICB0aGlzLl9yZXNwb25zaXZlTWVkaWFIYW5kbGVycy5wdXNoKHtcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgICB9KTtcbiAgICB9IC8vIGhhbmRsZXMgcmVzcG9uc2l2ZSBicmVha3BvaW50c1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gcGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuICAgICAgLy9pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy9jb25zdCB7IHdoeURpZFlvdVVwZGF0ZSB9ID0gcmVxdWlyZSgnd2h5LWRpZC15b3UtdXBkYXRlJylcbiAgICAgIC8vd2h5RGlkWW91VXBkYXRlKFJlYWN0KVxuICAgICAgLy99XG4gICAgICBpZiAodGhpcy5wcm9wcy5yZXNwb25zaXZlKSB7XG4gICAgICAgIHZhciBicmVha3BvaW50cyA9IHRoaXMucHJvcHMucmVzcG9uc2l2ZS5tYXAoZnVuY3Rpb24gKGJyZWFrcHQpIHtcbiAgICAgICAgICByZXR1cm4gYnJlYWtwdC5icmVha3BvaW50O1xuICAgICAgICB9KTsgLy8gc29ydCB0aGVtIGluIGluY3JlYXNpbmcgb3JkZXIgb2YgdGhlaXIgbnVtZXJpY2FsIHZhbHVlXG5cbiAgICAgICAgYnJlYWtwb2ludHMuc29ydChmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgIHJldHVybiB4IC0geTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKGJyZWFrcG9pbnQsIGluZGV4KSB7XG4gICAgICAgICAgLy8gbWVkaWEgcXVlcnkgZm9yIGVhY2ggYnJlYWtwb2ludFxuICAgICAgICAgIHZhciBiUXVlcnk7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIGJRdWVyeSA9ICgwLCBfanNvbjJtcVtcImRlZmF1bHRcIl0pKHtcbiAgICAgICAgICAgICAgbWluV2lkdGg6IDAsXG4gICAgICAgICAgICAgIG1heFdpZHRoOiBicmVha3BvaW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYlF1ZXJ5ID0gKDAsIF9qc29uMm1xW1wiZGVmYXVsdFwiXSkoe1xuICAgICAgICAgICAgICBtaW5XaWR0aDogYnJlYWtwb2ludHNbaW5kZXggLSAxXSArIDEsXG4gICAgICAgICAgICAgIG1heFdpZHRoOiBicmVha3BvaW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IC8vIHdoZW4gbm90IHVzaW5nIHNlcnZlciBzaWRlIHJlbmRlcmluZ1xuXG5cbiAgICAgICAgICAoMCwgX2lubmVyU2xpZGVyVXRpbHMuY2FuVXNlRE9NKSgpICYmIF90aGlzMi5tZWRpYShiUXVlcnksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgIGJyZWFrcG9pbnQ6IGJyZWFrcG9pbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgLy8gUmVnaXN0ZXIgbWVkaWEgcXVlcnkgZm9yIGZ1bGwgc2NyZWVuLiBOZWVkIHRvIHN1cHBvcnQgcmVzaXplIGZyb20gc21hbGwgdG8gbGFyZ2VcbiAgICAgICAgLy8gY29udmVydCBqYXZhc2NyaXB0IG9iamVjdCB0byBtZWRpYSBxdWVyeSBzdHJpbmdcblxuICAgICAgICB2YXIgcXVlcnkgPSAoMCwgX2pzb24ybXFbXCJkZWZhdWx0XCJdKSh7XG4gICAgICAgICAgbWluV2lkdGg6IGJyZWFrcG9pbnRzLnNsaWNlKC0xKVswXVxuICAgICAgICB9KTtcbiAgICAgICAgKDAsIF9pbm5lclNsaWRlclV0aWxzLmNhblVzZURPTSkoKSAmJiB0aGlzLm1lZGlhKHF1ZXJ5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGJyZWFrcG9pbnQ6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdGhpcy5fcmVzcG9uc2l2ZU1lZGlhSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGVucXVpcmUudW5yZWdpc3RlcihvYmoucXVlcnksIG9iai5oYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBzZXR0aW5ncztcbiAgICAgIHZhciBuZXdQcm9wcztcblxuICAgICAgaWYgKHRoaXMuc3RhdGUuYnJlYWtwb2ludCkge1xuICAgICAgICBuZXdQcm9wcyA9IHRoaXMucHJvcHMucmVzcG9uc2l2ZS5maWx0ZXIoZnVuY3Rpb24gKHJlc3ApIHtcbiAgICAgICAgICByZXR1cm4gcmVzcC5icmVha3BvaW50ID09PSBfdGhpczMuc3RhdGUuYnJlYWtwb2ludDtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldHRpbmdzID0gbmV3UHJvcHNbMF0uc2V0dGluZ3MgPT09IFwidW5zbGlja1wiID8gXCJ1bnNsaWNrXCIgOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX2RlZmF1bHRQcm9wc1tcImRlZmF1bHRcIl0pLCB0aGlzLnByb3BzKSwgbmV3UHJvcHNbMF0uc2V0dGluZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0dGluZ3MgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF9kZWZhdWx0UHJvcHNbXCJkZWZhdWx0XCJdKSwgdGhpcy5wcm9wcyk7XG4gICAgICB9IC8vIGZvcmNlIHNjcm9sbGluZyBieSBvbmUgaWYgY2VudGVyTW9kZSBpcyBvblxuXG5cbiAgICAgIGlmIChzZXR0aW5ncy5jZW50ZXJNb2RlKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5zbGlkZXNUb1Njcm9sbCA+IDEgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2xpZGVzVG9TY3JvbGwgc2hvdWxkIGJlIGVxdWFsIHRvIDEgaW4gY2VudGVyTW9kZSwgeW91IGFyZSB1c2luZyBcIi5jb25jYXQoc2V0dGluZ3Muc2xpZGVzVG9TY3JvbGwpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRpbmdzLnNsaWRlc1RvU2Nyb2xsID0gMTtcbiAgICAgIH0gLy8gZm9yY2Ugc2hvd2luZyBvbmUgc2xpZGUgYW5kIHNjcm9sbGluZyBieSBvbmUgaWYgdGhlIGZhZGUgbW9kZSBpcyBvblxuXG5cbiAgICAgIGlmIChzZXR0aW5ncy5mYWRlKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5zbGlkZXNUb1Nob3cgPiAxICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcInNsaWRlc1RvU2hvdyBzaG91bGQgYmUgZXF1YWwgdG8gMSB3aGVuIGZhZGUgaXMgdHJ1ZSwgeW91J3JlIHVzaW5nIFwiLmNvbmNhdChzZXR0aW5ncy5zbGlkZXNUb1Nob3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5zbGlkZXNUb1Njcm9sbCA+IDEgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2xpZGVzVG9TY3JvbGwgc2hvdWxkIGJlIGVxdWFsIHRvIDEgd2hlbiBmYWRlIGlzIHRydWUsIHlvdSdyZSB1c2luZyBcIi5jb25jYXQoc2V0dGluZ3Muc2xpZGVzVG9TY3JvbGwpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRpbmdzLnNsaWRlc1RvU2hvdyA9IDE7XG4gICAgICAgIHNldHRpbmdzLnNsaWRlc1RvU2Nyb2xsID0gMTtcbiAgICAgIH0gLy8gbWFrZXMgc3VyZSB0aGF0IGNoaWxkcmVuIGlzIGFuIGFycmF5LCBldmVuIHdoZW4gdGhlcmUgaXMgb25seSAxIGNoaWxkXG5cblxuICAgICAgdmFyIGNoaWxkcmVuID0gX3JlYWN0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi50b0FycmF5KHRoaXMucHJvcHMuY2hpbGRyZW4pOyAvLyBDaGlsZHJlbiBtYXkgY29udGFpbiBmYWxzZSBvciBudWxsLCBzbyB3ZSBzaG91bGQgZmlsdGVyIHRoZW1cbiAgICAgIC8vIGNoaWxkcmVuIG1heSBhbHNvIGNvbnRhaW4gc3RyaW5nIGZpbGxlZCB3aXRoIHNwYWNlcyAoaW4gY2VydGFpbiBjYXNlcyB3aGVyZSB3ZSB1c2UganN4IHN0cmluZ3MpXG5cblxuICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gISFjaGlsZC50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISFjaGlsZDtcbiAgICAgIH0pOyAvLyByb3dzIGFuZCBzbGlkZXNQZXJSb3cgbG9naWMgaXMgaGFuZGxlZCBoZXJlXG5cbiAgICAgIGlmIChzZXR0aW5ncy52YXJpYWJsZVdpZHRoICYmIChzZXR0aW5ncy5yb3dzID4gMSB8fCBzZXR0aW5ncy5zbGlkZXNQZXJSb3cgPiAxKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJ2YXJpYWJsZVdpZHRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gY2FzZSBvZiByb3dzID4gMSBvciBzbGlkZXNQZXJSb3cgPiAxXCIpO1xuICAgICAgICBzZXR0aW5ncy52YXJpYWJsZVdpZHRoID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRXaWR0aCA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IHNldHRpbmdzLnJvd3MgKiBzZXR0aW5ncy5zbGlkZXNQZXJSb3cpIHtcbiAgICAgICAgdmFyIG5ld1NsaWRlID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IGk7IGogPCBpICsgc2V0dGluZ3Mucm93cyAqIHNldHRpbmdzLnNsaWRlc1BlclJvdzsgaiArPSBzZXR0aW5ncy5zbGlkZXNQZXJSb3cpIHtcbiAgICAgICAgICB2YXIgcm93ID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBrID0gajsgayA8IGogKyBzZXR0aW5ncy5zbGlkZXNQZXJSb3c7IGsgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnZhcmlhYmxlV2lkdGggJiYgY2hpbGRyZW5ba10ucHJvcHMuc3R5bGUpIHtcbiAgICAgICAgICAgICAgY3VycmVudFdpZHRoID0gY2hpbGRyZW5ba10ucHJvcHMuc3R5bGUud2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChrID49IGNoaWxkcmVuLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICByb3cucHVzaCggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNoaWxkcmVuW2tdLCB7XG4gICAgICAgICAgICAgIGtleTogMTAwICogaSArIDEwICogaiArIGssXG4gICAgICAgICAgICAgIHRhYkluZGV4OiAtMSxcbiAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQoMTAwIC8gc2V0dGluZ3Muc2xpZGVzUGVyUm93LCBcIiVcIiksXG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3U2xpZGUucHVzaCggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBrZXk6IDEwICogaSArIGpcbiAgICAgICAgICB9LCByb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy52YXJpYWJsZVdpZHRoKSB7XG4gICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaCggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBrZXk6IGksXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICB3aWR0aDogY3VycmVudFdpZHRoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgbmV3U2xpZGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGtleTogaVxuICAgICAgICAgIH0sIG5ld1NsaWRlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNldHRpbmdzID09PSBcInVuc2xpY2tcIikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCJyZWd1bGFyIHNsaWRlciBcIiArICh0aGlzLnByb3BzLmNsYXNzTmFtZSB8fCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSBpZiAobmV3Q2hpbGRyZW4ubGVuZ3RoIDw9IHNldHRpbmdzLnNsaWRlc1RvU2hvdykge1xuICAgICAgICBzZXR0aW5ncy51bnNsaWNrID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoX2lubmVyU2xpZGVyLklubmVyU2xpZGVyLCBfZXh0ZW5kcyh7XG4gICAgICAgIHN0eWxlOiB0aGlzLnByb3BzLnN0eWxlLFxuICAgICAgICByZWY6IHRoaXMuaW5uZXJTbGlkZXJSZWZIYW5kbGVyXG4gICAgICB9LCBzZXR0aW5ncyksIG5ld0NoaWxkcmVuKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2xpZGVyO1xufShfcmVhY3RbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU2xpZGVyOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfaW5uZXJTbGlkZXIiLCJfanNvbjJtcSIsIl9kZWZhdWx0UHJvcHMiLCJfaW5uZXJTbGlkZXJVdGlscyIsIl9fZXNNb2R1bGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJvIiwicCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2NyZWF0ZVN1cGVyIiwiRGVyaXZlZCIsImhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NyZWF0ZVN1cGVySW50ZXJuYWwiLCJTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsInJlc3VsdCIsIk5ld1RhcmdldCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwidmFsdWVPZiIsImUiLCJnZXRQcm90b3R5cGVPZiIsImVucXVpcmUiLCJjYW5Vc2VET00iLCJTbGlkZXIiLCJfUmVhY3QkQ29tcG9uZW50IiwiX3N1cGVyIiwiX3RoaXMiLCJyZWYiLCJpbm5lclNsaWRlciIsInNsaWNrUHJldiIsInNsaWNrTmV4dCIsInNsaWRlIiwiZG9udEFuaW1hdGUiLCJ1bmRlZmluZWQiLCJzbGlja0dvVG8iLCJwYXVzZSIsImF1dG9QbGF5Iiwic3RhdGUiLCJicmVha3BvaW50IiwiX3Jlc3BvbnNpdmVNZWRpYUhhbmRsZXJzIiwibWVkaWEiLCJxdWVyeSIsImhhbmRsZXIiLCJyZWdpc3RlciIsImNvbXBvbmVudERpZE1vdW50IiwiX3RoaXMyIiwicmVzcG9uc2l2ZSIsImJyZWFrcG9pbnRzIiwibWFwIiwiYnJlYWtwdCIsInNvcnQiLCJ4IiwieSIsImluZGV4IiwiYlF1ZXJ5IiwibWluV2lkdGgiLCJtYXhXaWR0aCIsInNldFN0YXRlIiwic2xpY2UiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInVucmVnaXN0ZXIiLCJyZW5kZXIiLCJfdGhpczMiLCJzZXR0aW5ncyIsIm5ld1Byb3BzIiwicmVzcCIsImNlbnRlck1vZGUiLCJzbGlkZXNUb1Njcm9sbCIsInByb2Nlc3MiLCJjb25zb2xlIiwid2FybiIsImNvbmNhdCIsImZhZGUiLCJzbGlkZXNUb1Nob3ciLCJjaGlsZHJlbiIsIkNoaWxkcmVuIiwidG9BcnJheSIsImNoaWxkIiwidHJpbSIsInZhcmlhYmxlV2lkdGgiLCJyb3dzIiwic2xpZGVzUGVyUm93IiwibmV3Q2hpbGRyZW4iLCJjdXJyZW50V2lkdGgiLCJuZXdTbGlkZSIsImoiLCJyb3ciLCJrIiwic3R5bGUiLCJ3aWR0aCIsImNsb25lRWxlbWVudCIsInRhYkluZGV4IiwiZGlzcGxheSIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJ1bnNsaWNrIiwiSW5uZXJTbGlkZXIiLCJpbm5lclNsaWRlclJlZkhhbmRsZXIiLCJDb21wb25lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-slick/lib/slider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-slick/lib/track.js":
/*!***********************************************!*\
  !*** ./node_modules/react-slick/lib/track.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Track = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"(ssr)/./node_modules/classnames/index.js\"));\nvar _innerSliderUtils = __webpack_require__(/*! ./utils/innerSliderUtils */ \"(ssr)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n// given specifications/props for a slide, fetch all the classes that need to be applied to the slide\nvar getSlideClasses = function getSlideClasses(spec) {\n    var slickActive, slickCenter, slickCloned;\n    var centerOffset, index;\n    if (spec.rtl) {\n        index = spec.slideCount - 1 - spec.index;\n    } else {\n        index = spec.index;\n    }\n    slickCloned = index < 0 || index >= spec.slideCount;\n    if (spec.centerMode) {\n        centerOffset = Math.floor(spec.slidesToShow / 2);\n        slickCenter = (index - spec.currentSlide) % spec.slideCount === 0;\n        if (index > spec.currentSlide - centerOffset - 1 && index <= spec.currentSlide + centerOffset) {\n            slickActive = true;\n        }\n    } else {\n        slickActive = spec.currentSlide <= index && index < spec.currentSlide + spec.slidesToShow;\n    }\n    var focusedSlide;\n    if (spec.targetSlide < 0) {\n        focusedSlide = spec.targetSlide + spec.slideCount;\n    } else if (spec.targetSlide >= spec.slideCount) {\n        focusedSlide = spec.targetSlide - spec.slideCount;\n    } else {\n        focusedSlide = spec.targetSlide;\n    }\n    var slickCurrent = index === focusedSlide;\n    return {\n        \"slick-slide\": true,\n        \"slick-active\": slickActive,\n        \"slick-center\": slickCenter,\n        \"slick-cloned\": slickCloned,\n        \"slick-current\": slickCurrent // dubious in case of RTL\n    };\n};\nvar getSlideStyle = function getSlideStyle(spec) {\n    var style = {};\n    if (spec.variableWidth === undefined || spec.variableWidth === false) {\n        style.width = spec.slideWidth;\n    }\n    if (spec.fade) {\n        style.position = \"relative\";\n        if (spec.vertical) {\n            style.top = -spec.index * parseInt(spec.slideHeight);\n        } else {\n            style.left = -spec.index * parseInt(spec.slideWidth);\n        }\n        style.opacity = spec.currentSlide === spec.index ? 1 : 0;\n        if (spec.useCSS) {\n            style.transition = \"opacity \" + spec.speed + \"ms \" + spec.cssEase + \", \" + \"visibility \" + spec.speed + \"ms \" + spec.cssEase;\n        }\n    }\n    return style;\n};\nvar getKey = function getKey(child, fallbackKey) {\n    return child.key || fallbackKey;\n};\nvar renderSlides = function renderSlides(spec) {\n    var key;\n    var slides = [];\n    var preCloneSlides = [];\n    var postCloneSlides = [];\n    var childrenCount = _react[\"default\"].Children.count(spec.children);\n    var startIndex = (0, _innerSliderUtils.lazyStartIndex)(spec);\n    var endIndex = (0, _innerSliderUtils.lazyEndIndex)(spec);\n    _react[\"default\"].Children.forEach(spec.children, function(elem, index) {\n        var child;\n        var childOnClickOptions = {\n            message: \"children\",\n            index: index,\n            slidesToScroll: spec.slidesToScroll,\n            currentSlide: spec.currentSlide\n        }; // in case of lazyLoad, whether or not we want to fetch the slide\n        if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index) >= 0) {\n            child = elem;\n        } else {\n            child = /*#__PURE__*/ _react[\"default\"].createElement(\"div\", null);\n        }\n        var childStyle = getSlideStyle(_objectSpread(_objectSpread({}, spec), {}, {\n            index: index\n        }));\n        var slideClass = child.props.className || \"\";\n        var slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {\n            index: index\n        })); // push a cloned element of the desired slide\n        slides.push(/*#__PURE__*/ _react[\"default\"].cloneElement(child, {\n            key: \"original\" + getKey(child, index),\n            \"data-index\": index,\n            className: (0, _classnames[\"default\"])(slideClasses, slideClass),\n            tabIndex: \"-1\",\n            \"aria-hidden\": !slideClasses[\"slick-active\"],\n            style: _objectSpread(_objectSpread({\n                outline: \"none\"\n            }, child.props.style || {}), childStyle),\n            onClick: function onClick(e) {\n                child.props && child.props.onClick && child.props.onClick(e);\n                if (spec.focusOnSelect) {\n                    spec.focusOnSelect(childOnClickOptions);\n                }\n            }\n        })); // if slide needs to be precloned or postcloned\n        if (spec.infinite && spec.fade === false) {\n            var preCloneNo = childrenCount - index;\n            if (preCloneNo <= (0, _innerSliderUtils.getPreClones)(spec) && childrenCount !== spec.slidesToShow) {\n                key = -preCloneNo;\n                if (key >= startIndex) {\n                    child = elem;\n                }\n                slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {\n                    index: key\n                }));\n                preCloneSlides.push(/*#__PURE__*/ _react[\"default\"].cloneElement(child, {\n                    key: \"precloned\" + getKey(child, key),\n                    \"data-index\": key,\n                    tabIndex: \"-1\",\n                    className: (0, _classnames[\"default\"])(slideClasses, slideClass),\n                    \"aria-hidden\": !slideClasses[\"slick-active\"],\n                    style: _objectSpread(_objectSpread({}, child.props.style || {}), childStyle),\n                    onClick: function onClick(e) {\n                        child.props && child.props.onClick && child.props.onClick(e);\n                        if (spec.focusOnSelect) {\n                            spec.focusOnSelect(childOnClickOptions);\n                        }\n                    }\n                }));\n            }\n            if (childrenCount !== spec.slidesToShow) {\n                key = childrenCount + index;\n                if (key < endIndex) {\n                    child = elem;\n                }\n                slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {\n                    index: key\n                }));\n                postCloneSlides.push(/*#__PURE__*/ _react[\"default\"].cloneElement(child, {\n                    key: \"postcloned\" + getKey(child, key),\n                    \"data-index\": key,\n                    tabIndex: \"-1\",\n                    className: (0, _classnames[\"default\"])(slideClasses, slideClass),\n                    \"aria-hidden\": !slideClasses[\"slick-active\"],\n                    style: _objectSpread(_objectSpread({}, child.props.style || {}), childStyle),\n                    onClick: function onClick(e) {\n                        child.props && child.props.onClick && child.props.onClick(e);\n                        if (spec.focusOnSelect) {\n                            spec.focusOnSelect(childOnClickOptions);\n                        }\n                    }\n                }));\n            }\n        }\n    });\n    if (spec.rtl) {\n        return preCloneSlides.concat(slides, postCloneSlides).reverse();\n    } else {\n        return preCloneSlides.concat(slides, postCloneSlides);\n    }\n};\nvar Track = /*#__PURE__*/ function(_React$PureComponent) {\n    _inherits(Track, _React$PureComponent);\n    var _super = _createSuper(Track);\n    function Track() {\n        var _this;\n        _classCallCheck(this, Track);\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _super.call.apply(_super, [\n            this\n        ].concat(args));\n        _defineProperty(_assertThisInitialized(_this), \"node\", null);\n        _defineProperty(_assertThisInitialized(_this), \"handleRef\", function(ref) {\n            _this.node = ref;\n        });\n        return _this;\n    }\n    _createClass(Track, [\n        {\n            key: \"render\",\n            value: function render() {\n                var slides = renderSlides(this.props);\n                var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave;\n                var mouseEvents = {\n                    onMouseEnter: onMouseEnter,\n                    onMouseOver: onMouseOver,\n                    onMouseLeave: onMouseLeave\n                };\n                return /*#__PURE__*/ _react[\"default\"].createElement(\"div\", _extends({\n                    ref: this.handleRef,\n                    className: \"slick-track\",\n                    style: this.props.trackStyle\n                }, mouseEvents), slides);\n            }\n        }\n    ]);\n    return Track;\n}(_react[\"default\"].PureComponent);\nexports.Track = Track;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL3RyYWNrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsR0FBRztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLEdBQUc7UUFBSSxPQUFPLE9BQU9BO0lBQUssSUFBSSxTQUFVQSxHQUFHO1FBQUksT0FBT0EsT0FBTyxjQUFjLE9BQU9DLFVBQVVELElBQUlHLFdBQVcsS0FBS0YsVUFBVUQsUUFBUUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBSyxHQUFHRCxRQUFRQztBQUFNO0FBRS9VSyw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsYUFBYSxHQUFHLEtBQUs7QUFFckIsSUFBSUcsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyx3R0FBTztBQUVuRCxJQUFJQyxjQUFjRix1QkFBdUJDLG1CQUFPQSxDQUFDLDREQUFZO0FBRTdELElBQUlFLG9CQUFvQkYsbUJBQU9BLENBQUMsZ0dBQTBCO0FBRTFELFNBQVNELHVCQUF1QlgsR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUllLFVBQVUsR0FBR2YsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUVoRyxTQUFTZ0I7SUFBYUEsV0FBV1gsT0FBT1ksTUFBTSxJQUFJLFNBQVVDLE1BQU07UUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQUUsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQUUsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUFFLElBQUlqQixPQUFPRCxTQUFTLENBQUNvQixjQUFjLENBQUNDLElBQUksQ0FBQ0gsUUFBUUMsTUFBTTtvQkFBRUwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFBRTtZQUFFO1FBQUU7UUFBRSxPQUFPTDtJQUFRO0lBQUcsT0FBT0YsU0FBU1UsS0FBSyxDQUFDLElBQUksRUFBRU47QUFBWTtBQUU1VCxTQUFTTyxnQkFBZ0JDLFFBQVEsRUFBRUMsV0FBVztJQUFJLElBQUksQ0FBRUQsQ0FBQUEsb0JBQW9CQyxXQUFVLEdBQUk7UUFBRSxNQUFNLElBQUlDLFVBQVU7SUFBc0M7QUFBRTtBQUV4SixTQUFTQyxrQkFBa0JiLE1BQU0sRUFBRWMsS0FBSztJQUFJLElBQUssSUFBSWIsSUFBSSxHQUFHQSxJQUFJYSxNQUFNWCxNQUFNLEVBQUVGLElBQUs7UUFBRSxJQUFJYyxhQUFhRCxLQUFLLENBQUNiLEVBQUU7UUFBRWMsV0FBV0MsVUFBVSxHQUFHRCxXQUFXQyxVQUFVLElBQUk7UUFBT0QsV0FBV0UsWUFBWSxHQUFHO1FBQU0sSUFBSSxXQUFXRixZQUFZQSxXQUFXRyxRQUFRLEdBQUc7UUFBTS9CLE9BQU9DLGNBQWMsQ0FBQ1ksUUFBUWUsV0FBV1YsR0FBRyxFQUFFVTtJQUFhO0FBQUU7QUFFNVQsU0FBU0ksYUFBYVIsV0FBVyxFQUFFUyxVQUFVLEVBQUVDLFdBQVc7SUFBSSxJQUFJRCxZQUFZUCxrQkFBa0JGLFlBQVl6QixTQUFTLEVBQUVrQztJQUFhLElBQUlDLGFBQWFSLGtCQUFrQkYsYUFBYVU7SUFBY2xDLE9BQU9DLGNBQWMsQ0FBQ3VCLGFBQWEsYUFBYTtRQUFFTyxVQUFVO0lBQU07SUFBSSxPQUFPUDtBQUFhO0FBRTVSLFNBQVNXLFVBQVVDLFFBQVEsRUFBRUMsVUFBVTtJQUFJLElBQUksT0FBT0EsZUFBZSxjQUFjQSxlQUFlLE1BQU07UUFBRSxNQUFNLElBQUlaLFVBQVU7SUFBdUQ7SUFBRVcsU0FBU3JDLFNBQVMsR0FBR0MsT0FBT3NDLE1BQU0sQ0FBQ0QsY0FBY0EsV0FBV3RDLFNBQVMsRUFBRTtRQUFFRCxhQUFhO1lBQUVLLE9BQU9pQztZQUFVTCxVQUFVO1lBQU1ELGNBQWM7UUFBSztJQUFFO0lBQUk5QixPQUFPQyxjQUFjLENBQUNtQyxVQUFVLGFBQWE7UUFBRUwsVUFBVTtJQUFNO0lBQUksSUFBSU0sWUFBWUUsZ0JBQWdCSCxVQUFVQztBQUFhO0FBRW5jLFNBQVNFLGdCQUFnQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQUlGLGtCQUFrQnZDLE9BQU8wQyxjQUFjLElBQUksU0FBU0gsZ0JBQWdCQyxDQUFDLEVBQUVDLENBQUM7UUFBSUQsRUFBRUcsU0FBUyxHQUFHRjtRQUFHLE9BQU9EO0lBQUc7SUFBRyxPQUFPRCxnQkFBZ0JDLEdBQUdDO0FBQUk7QUFFekssU0FBU0csYUFBYUMsT0FBTztJQUFJLElBQUlDLDRCQUE0QkM7SUFBNkIsT0FBTyxTQUFTQztRQUF5QixJQUFJQyxRQUFRQyxnQkFBZ0JMLFVBQVVNO1FBQVEsSUFBSUwsMkJBQTJCO1lBQUUsSUFBSU0sWUFBWUYsZ0JBQWdCLElBQUksRUFBRXBELFdBQVc7WUFBRXFELFNBQVNFLFFBQVFDLFNBQVMsQ0FBQ0wsT0FBT2xDLFdBQVdxQztRQUFZLE9BQU87WUFBRUQsU0FBU0YsTUFBTTVCLEtBQUssQ0FBQyxJQUFJLEVBQUVOO1FBQVk7UUFBRSxPQUFPd0MsMkJBQTJCLElBQUksRUFBRUo7SUFBUztBQUFHO0FBRXhhLFNBQVNJLDJCQUEyQkMsSUFBSSxFQUFFcEMsSUFBSTtJQUFJLElBQUlBLFFBQVMxQixDQUFBQSxRQUFRMEIsVUFBVSxZQUFZLE9BQU9BLFNBQVMsVUFBUyxHQUFJO1FBQUUsT0FBT0E7SUFBTSxPQUFPLElBQUlBLFNBQVMsS0FBSyxHQUFHO1FBQUUsTUFBTSxJQUFJSyxVQUFVO0lBQTZEO0lBQUUsT0FBT2dDLHVCQUF1QkQ7QUFBTztBQUUvUixTQUFTQyx1QkFBdUJELElBQUk7SUFBSSxJQUFJQSxTQUFTLEtBQUssR0FBRztRQUFFLE1BQU0sSUFBSUUsZUFBZTtJQUE4RDtJQUFFLE9BQU9GO0FBQU07QUFFckssU0FBU1Q7SUFBOEIsSUFBSSxPQUFPTSxZQUFZLGVBQWUsQ0FBQ0EsUUFBUUMsU0FBUyxFQUFFLE9BQU87SUFBTyxJQUFJRCxRQUFRQyxTQUFTLENBQUNLLElBQUksRUFBRSxPQUFPO0lBQU8sSUFBSSxPQUFPQyxVQUFVLFlBQVksT0FBTztJQUFNLElBQUk7UUFBRUMsUUFBUTlELFNBQVMsQ0FBQytELE9BQU8sQ0FBQzFDLElBQUksQ0FBQ2lDLFFBQVFDLFNBQVMsQ0FBQ08sU0FBUyxFQUFFLEVBQUUsWUFBYTtRQUFLLE9BQU87SUFBTSxFQUFFLE9BQU9FLEdBQUc7UUFBRSxPQUFPO0lBQU87QUFBRTtBQUV4VSxTQUFTYixnQkFBZ0JWLENBQUM7SUFBSVUsa0JBQWtCbEQsT0FBTzBDLGNBQWMsR0FBRzFDLE9BQU9nRSxjQUFjLEdBQUcsU0FBU2QsZ0JBQWdCVixDQUFDO1FBQUksT0FBT0EsRUFBRUcsU0FBUyxJQUFJM0MsT0FBT2dFLGNBQWMsQ0FBQ3hCO0lBQUk7SUFBRyxPQUFPVSxnQkFBZ0JWO0FBQUk7QUFFNU0sU0FBU3lCLFFBQVFDLE1BQU0sRUFBRUMsY0FBYztJQUFJLElBQUlDLE9BQU9wRSxPQUFPb0UsSUFBSSxDQUFDRjtJQUFTLElBQUlsRSxPQUFPcUUscUJBQXFCLEVBQUU7UUFBRSxJQUFJQyxVQUFVdEUsT0FBT3FFLHFCQUFxQixDQUFDSDtRQUFTQyxrQkFBbUJHLENBQUFBLFVBQVVBLFFBQVFDLE1BQU0sQ0FBQyxTQUFVQyxHQUFHO1lBQUksT0FBT3hFLE9BQU95RSx3QkFBd0IsQ0FBQ1AsUUFBUU0sS0FBSzNDLFVBQVU7UUFBRSxFQUFDLEdBQUl1QyxLQUFLTSxJQUFJLENBQUNyRCxLQUFLLENBQUMrQyxNQUFNRTtJQUFVO0lBQUUsT0FBT0Y7QUFBTTtBQUVwVixTQUFTTyxjQUFjOUQsTUFBTTtJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7UUFBRSxJQUFJRyxTQUFTLFFBQVFGLFNBQVMsQ0FBQ0QsRUFBRSxHQUFHQyxTQUFTLENBQUNELEVBQUUsR0FBRyxDQUFDO1FBQUdBLElBQUksSUFBSW1ELFFBQVFqRSxPQUFPaUIsU0FBUyxDQUFDLEdBQUcyRCxPQUFPLENBQUMsU0FBVTFELEdBQUc7WUFBSTJELGdCQUFnQmhFLFFBQVFLLEtBQUtELE1BQU0sQ0FBQ0MsSUFBSTtRQUFHLEtBQUtsQixPQUFPOEUseUJBQXlCLEdBQUc5RSxPQUFPK0UsZ0JBQWdCLENBQUNsRSxRQUFRYixPQUFPOEUseUJBQXlCLENBQUM3RCxXQUFXZ0QsUUFBUWpFLE9BQU9pQixTQUFTMkQsT0FBTyxDQUFDLFNBQVUxRCxHQUFHO1lBQUlsQixPQUFPQyxjQUFjLENBQUNZLFFBQVFLLEtBQUtsQixPQUFPeUUsd0JBQXdCLENBQUN4RCxRQUFRQztRQUFPO0lBQUk7SUFBRSxPQUFPTDtBQUFRO0FBRXpmLFNBQVNnRSxnQkFBZ0JsRixHQUFHLEVBQUV1QixHQUFHLEVBQUVmLEtBQUs7SUFBSSxJQUFJZSxPQUFPdkIsS0FBSztRQUFFSyxPQUFPQyxjQUFjLENBQUNOLEtBQUt1QixLQUFLO1lBQUVmLE9BQU9BO1lBQU8wQixZQUFZO1lBQU1DLGNBQWM7WUFBTUMsVUFBVTtRQUFLO0lBQUksT0FBTztRQUFFcEMsR0FBRyxDQUFDdUIsSUFBSSxHQUFHZjtJQUFPO0lBQUUsT0FBT1I7QUFBSztBQUVoTixxR0FBcUc7QUFDckcsSUFBSXFGLGtCQUFrQixTQUFTQSxnQkFBZ0JDLElBQUk7SUFDakQsSUFBSUMsYUFBYUMsYUFBYUM7SUFDOUIsSUFBSUMsY0FBY0M7SUFFbEIsSUFBSUwsS0FBS00sR0FBRyxFQUFFO1FBQ1pELFFBQVFMLEtBQUtPLFVBQVUsR0FBRyxJQUFJUCxLQUFLSyxLQUFLO0lBQzFDLE9BQU87UUFDTEEsUUFBUUwsS0FBS0ssS0FBSztJQUNwQjtJQUVBRixjQUFjRSxRQUFRLEtBQUtBLFNBQVNMLEtBQUtPLFVBQVU7SUFFbkQsSUFBSVAsS0FBS1EsVUFBVSxFQUFFO1FBQ25CSixlQUFlSyxLQUFLQyxLQUFLLENBQUNWLEtBQUtXLFlBQVksR0FBRztRQUM5Q1QsY0FBYyxDQUFDRyxRQUFRTCxLQUFLWSxZQUFZLElBQUlaLEtBQUtPLFVBQVUsS0FBSztRQUVoRSxJQUFJRixRQUFRTCxLQUFLWSxZQUFZLEdBQUdSLGVBQWUsS0FBS0MsU0FBU0wsS0FBS1ksWUFBWSxHQUFHUixjQUFjO1lBQzdGSCxjQUFjO1FBQ2hCO0lBQ0YsT0FBTztRQUNMQSxjQUFjRCxLQUFLWSxZQUFZLElBQUlQLFNBQVNBLFFBQVFMLEtBQUtZLFlBQVksR0FBR1osS0FBS1csWUFBWTtJQUMzRjtJQUVBLElBQUlFO0lBRUosSUFBSWIsS0FBS2MsV0FBVyxHQUFHLEdBQUc7UUFDeEJELGVBQWViLEtBQUtjLFdBQVcsR0FBR2QsS0FBS08sVUFBVTtJQUNuRCxPQUFPLElBQUlQLEtBQUtjLFdBQVcsSUFBSWQsS0FBS08sVUFBVSxFQUFFO1FBQzlDTSxlQUFlYixLQUFLYyxXQUFXLEdBQUdkLEtBQUtPLFVBQVU7SUFDbkQsT0FBTztRQUNMTSxlQUFlYixLQUFLYyxXQUFXO0lBQ2pDO0lBRUEsSUFBSUMsZUFBZVYsVUFBVVE7SUFDN0IsT0FBTztRQUNMLGVBQWU7UUFDZixnQkFBZ0JaO1FBQ2hCLGdCQUFnQkM7UUFDaEIsZ0JBQWdCQztRQUNoQixpQkFBaUJZLGFBQWEseUJBQXlCO0lBRXpEO0FBQ0Y7QUFFQSxJQUFJQyxnQkFBZ0IsU0FBU0EsY0FBY2hCLElBQUk7SUFDN0MsSUFBSWlCLFFBQVEsQ0FBQztJQUViLElBQUlqQixLQUFLa0IsYUFBYSxLQUFLQyxhQUFhbkIsS0FBS2tCLGFBQWEsS0FBSyxPQUFPO1FBQ3BFRCxNQUFNRyxLQUFLLEdBQUdwQixLQUFLcUIsVUFBVTtJQUMvQjtJQUVBLElBQUlyQixLQUFLc0IsSUFBSSxFQUFFO1FBQ2JMLE1BQU1NLFFBQVEsR0FBRztRQUVqQixJQUFJdkIsS0FBS3dCLFFBQVEsRUFBRTtZQUNqQlAsTUFBTVEsR0FBRyxHQUFHLENBQUN6QixLQUFLSyxLQUFLLEdBQUdxQixTQUFTMUIsS0FBSzJCLFdBQVc7UUFDckQsT0FBTztZQUNMVixNQUFNVyxJQUFJLEdBQUcsQ0FBQzVCLEtBQUtLLEtBQUssR0FBR3FCLFNBQVMxQixLQUFLcUIsVUFBVTtRQUNyRDtRQUVBSixNQUFNWSxPQUFPLEdBQUc3QixLQUFLWSxZQUFZLEtBQUtaLEtBQUtLLEtBQUssR0FBRyxJQUFJO1FBRXZELElBQUlMLEtBQUs4QixNQUFNLEVBQUU7WUFDZmIsTUFBTWMsVUFBVSxHQUFHLGFBQWEvQixLQUFLZ0MsS0FBSyxHQUFHLFFBQVFoQyxLQUFLaUMsT0FBTyxHQUFHLE9BQU8sZ0JBQWdCakMsS0FBS2dDLEtBQUssR0FBRyxRQUFRaEMsS0FBS2lDLE9BQU87UUFDOUg7SUFDRjtJQUVBLE9BQU9oQjtBQUNUO0FBRUEsSUFBSWlCLFNBQVMsU0FBU0EsT0FBT0MsS0FBSyxFQUFFQyxXQUFXO0lBQzdDLE9BQU9ELE1BQU1sRyxHQUFHLElBQUltRztBQUN0QjtBQUVBLElBQUlDLGVBQWUsU0FBU0EsYUFBYXJDLElBQUk7SUFDM0MsSUFBSS9EO0lBQ0osSUFBSXFHLFNBQVMsRUFBRTtJQUNmLElBQUlDLGlCQUFpQixFQUFFO0lBQ3ZCLElBQUlDLGtCQUFrQixFQUFFO0lBRXhCLElBQUlDLGdCQUFnQnJILE1BQU0sQ0FBQyxVQUFVLENBQUNzSCxRQUFRLENBQUNDLEtBQUssQ0FBQzNDLEtBQUs0QyxRQUFRO0lBRWxFLElBQUlDLGFBQWEsQ0FBQyxHQUFHckgsa0JBQWtCc0gsY0FBYyxFQUFFOUM7SUFDdkQsSUFBSStDLFdBQVcsQ0FBQyxHQUFHdkgsa0JBQWtCd0gsWUFBWSxFQUFFaEQ7SUFFbkQ1RSxNQUFNLENBQUMsVUFBVSxDQUFDc0gsUUFBUSxDQUFDL0MsT0FBTyxDQUFDSyxLQUFLNEMsUUFBUSxFQUFFLFNBQVVLLElBQUksRUFBRTVDLEtBQUs7UUFDckUsSUFBSThCO1FBQ0osSUFBSWUsc0JBQXNCO1lBQ3hCQyxTQUFTO1lBQ1Q5QyxPQUFPQTtZQUNQK0MsZ0JBQWdCcEQsS0FBS29ELGNBQWM7WUFDbkN4QyxjQUFjWixLQUFLWSxZQUFZO1FBQ2pDLEdBQUcsaUVBQWlFO1FBRXBFLElBQUksQ0FBQ1osS0FBS3FELFFBQVEsSUFBSXJELEtBQUtxRCxRQUFRLElBQUlyRCxLQUFLc0QsY0FBYyxDQUFDQyxPQUFPLENBQUNsRCxVQUFVLEdBQUc7WUFDOUU4QixRQUFRYztRQUNWLE9BQU87WUFDTGQsUUFBUSxXQUFXLEdBQUUvRyxNQUFNLENBQUMsVUFBVSxDQUFDb0ksYUFBYSxDQUFDLE9BQU87UUFDOUQ7UUFFQSxJQUFJQyxhQUFhekMsY0FBY3RCLGNBQWNBLGNBQWMsQ0FBQyxHQUFHTSxPQUFPLENBQUMsR0FBRztZQUN4RUssT0FBT0E7UUFDVDtRQUNBLElBQUlxRCxhQUFhdkIsTUFBTXpGLEtBQUssQ0FBQ2lILFNBQVMsSUFBSTtRQUMxQyxJQUFJQyxlQUFlN0QsZ0JBQWdCTCxjQUFjQSxjQUFjLENBQUMsR0FBR00sT0FBTyxDQUFDLEdBQUc7WUFDNUVLLE9BQU9BO1FBQ1QsS0FBSyw2Q0FBNkM7UUFFbERpQyxPQUFPN0MsSUFBSSxDQUFFLFdBQVcsR0FBRXJFLE1BQU0sQ0FBQyxVQUFVLENBQUN5SSxZQUFZLENBQUMxQixPQUFPO1lBQzlEbEcsS0FBSyxhQUFhaUcsT0FBT0MsT0FBTzlCO1lBQ2hDLGNBQWNBO1lBQ2RzRCxXQUFXLENBQUMsR0FBR3BJLFdBQVcsQ0FBQyxVQUFVLEVBQUVxSSxjQUFjRjtZQUNyREksVUFBVTtZQUNWLGVBQWUsQ0FBQ0YsWUFBWSxDQUFDLGVBQWU7WUFDNUMzQyxPQUFPdkIsY0FBY0EsY0FBYztnQkFDakNxRSxTQUFTO1lBQ1gsR0FBRzVCLE1BQU16RixLQUFLLENBQUN1RSxLQUFLLElBQUksQ0FBQyxJQUFJd0M7WUFDN0JPLFNBQVMsU0FBU0EsUUFBUWxGLENBQUM7Z0JBQ3pCcUQsTUFBTXpGLEtBQUssSUFBSXlGLE1BQU16RixLQUFLLENBQUNzSCxPQUFPLElBQUk3QixNQUFNekYsS0FBSyxDQUFDc0gsT0FBTyxDQUFDbEY7Z0JBRTFELElBQUlrQixLQUFLaUUsYUFBYSxFQUFFO29CQUN0QmpFLEtBQUtpRSxhQUFhLENBQUNmO2dCQUNyQjtZQUNGO1FBQ0YsS0FBSywrQ0FBK0M7UUFFcEQsSUFBSWxELEtBQUtrRSxRQUFRLElBQUlsRSxLQUFLc0IsSUFBSSxLQUFLLE9BQU87WUFDeEMsSUFBSTZDLGFBQWExQixnQkFBZ0JwQztZQUVqQyxJQUFJOEQsY0FBYyxDQUFDLEdBQUczSSxrQkFBa0I0SSxZQUFZLEVBQUVwRSxTQUFTeUMsa0JBQWtCekMsS0FBS1csWUFBWSxFQUFFO2dCQUNsRzFFLE1BQU0sQ0FBQ2tJO2dCQUVQLElBQUlsSSxPQUFPNEcsWUFBWTtvQkFDckJWLFFBQVFjO2dCQUNWO2dCQUVBVyxlQUFlN0QsZ0JBQWdCTCxjQUFjQSxjQUFjLENBQUMsR0FBR00sT0FBTyxDQUFDLEdBQUc7b0JBQ3hFSyxPQUFPcEU7Z0JBQ1Q7Z0JBQ0FzRyxlQUFlOUMsSUFBSSxDQUFFLFdBQVcsR0FBRXJFLE1BQU0sQ0FBQyxVQUFVLENBQUN5SSxZQUFZLENBQUMxQixPQUFPO29CQUN0RWxHLEtBQUssY0FBY2lHLE9BQU9DLE9BQU9sRztvQkFDakMsY0FBY0E7b0JBQ2Q2SCxVQUFVO29CQUNWSCxXQUFXLENBQUMsR0FBR3BJLFdBQVcsQ0FBQyxVQUFVLEVBQUVxSSxjQUFjRjtvQkFDckQsZUFBZSxDQUFDRSxZQUFZLENBQUMsZUFBZTtvQkFDNUMzQyxPQUFPdkIsY0FBY0EsY0FBYyxDQUFDLEdBQUd5QyxNQUFNekYsS0FBSyxDQUFDdUUsS0FBSyxJQUFJLENBQUMsSUFBSXdDO29CQUNqRU8sU0FBUyxTQUFTQSxRQUFRbEYsQ0FBQzt3QkFDekJxRCxNQUFNekYsS0FBSyxJQUFJeUYsTUFBTXpGLEtBQUssQ0FBQ3NILE9BQU8sSUFBSTdCLE1BQU16RixLQUFLLENBQUNzSCxPQUFPLENBQUNsRjt3QkFFMUQsSUFBSWtCLEtBQUtpRSxhQUFhLEVBQUU7NEJBQ3RCakUsS0FBS2lFLGFBQWEsQ0FBQ2Y7d0JBQ3JCO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJVCxrQkFBa0J6QyxLQUFLVyxZQUFZLEVBQUU7Z0JBQ3ZDMUUsTUFBTXdHLGdCQUFnQnBDO2dCQUV0QixJQUFJcEUsTUFBTThHLFVBQVU7b0JBQ2xCWixRQUFRYztnQkFDVjtnQkFFQVcsZUFBZTdELGdCQUFnQkwsY0FBY0EsY0FBYyxDQUFDLEdBQUdNLE9BQU8sQ0FBQyxHQUFHO29CQUN4RUssT0FBT3BFO2dCQUNUO2dCQUNBdUcsZ0JBQWdCL0MsSUFBSSxDQUFFLFdBQVcsR0FBRXJFLE1BQU0sQ0FBQyxVQUFVLENBQUN5SSxZQUFZLENBQUMxQixPQUFPO29CQUN2RWxHLEtBQUssZUFBZWlHLE9BQU9DLE9BQU9sRztvQkFDbEMsY0FBY0E7b0JBQ2Q2SCxVQUFVO29CQUNWSCxXQUFXLENBQUMsR0FBR3BJLFdBQVcsQ0FBQyxVQUFVLEVBQUVxSSxjQUFjRjtvQkFDckQsZUFBZSxDQUFDRSxZQUFZLENBQUMsZUFBZTtvQkFDNUMzQyxPQUFPdkIsY0FBY0EsY0FBYyxDQUFDLEdBQUd5QyxNQUFNekYsS0FBSyxDQUFDdUUsS0FBSyxJQUFJLENBQUMsSUFBSXdDO29CQUNqRU8sU0FBUyxTQUFTQSxRQUFRbEYsQ0FBQzt3QkFDekJxRCxNQUFNekYsS0FBSyxJQUFJeUYsTUFBTXpGLEtBQUssQ0FBQ3NILE9BQU8sSUFBSTdCLE1BQU16RixLQUFLLENBQUNzSCxPQUFPLENBQUNsRjt3QkFFMUQsSUFBSWtCLEtBQUtpRSxhQUFhLEVBQUU7NEJBQ3RCakUsS0FBS2lFLGFBQWEsQ0FBQ2Y7d0JBQ3JCO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsSUFBSWxELEtBQUtNLEdBQUcsRUFBRTtRQUNaLE9BQU9pQyxlQUFlOEIsTUFBTSxDQUFDL0IsUUFBUUUsaUJBQWlCOEIsT0FBTztJQUMvRCxPQUFPO1FBQ0wsT0FBTy9CLGVBQWU4QixNQUFNLENBQUMvQixRQUFRRTtJQUN2QztBQUNGO0FBRUEsSUFBSXJILFFBQVEsV0FBVyxHQUFFLFNBQVVvSixvQkFBb0I7SUFDckRySCxVQUFVL0IsT0FBT29KO0lBRWpCLElBQUlDLFNBQVM3RyxhQUFheEM7SUFFMUIsU0FBU0E7UUFDUCxJQUFJc0o7UUFFSnBJLGdCQUFnQixJQUFJLEVBQUVsQjtRQUV0QixJQUFLLElBQUl1SixPQUFPNUksVUFBVUMsTUFBTSxFQUFFNEksT0FBTyxJQUFJQyxNQUFNRixPQUFPRyxPQUFPLEdBQUdBLE9BQU9ILE1BQU1HLE9BQVE7WUFDdkZGLElBQUksQ0FBQ0UsS0FBSyxHQUFHL0ksU0FBUyxDQUFDK0ksS0FBSztRQUM5QjtRQUVBSixRQUFRRCxPQUFPckksSUFBSSxDQUFDQyxLQUFLLENBQUNvSSxRQUFRO1lBQUMsSUFBSTtTQUFDLENBQUNILE1BQU0sQ0FBQ007UUFFaEQvRSxnQkFBZ0JwQix1QkFBdUJpRyxRQUFRLFFBQVE7UUFFdkQ3RSxnQkFBZ0JwQix1QkFBdUJpRyxRQUFRLGFBQWEsU0FBVUssR0FBRztZQUN2RUwsTUFBTU0sSUFBSSxHQUFHRDtRQUNmO1FBRUEsT0FBT0w7SUFDVDtJQUVBMUgsYUFBYTVCLE9BQU87UUFBQztZQUNuQmMsS0FBSztZQUNMZixPQUFPLFNBQVM4SjtnQkFDZCxJQUFJMUMsU0FBU0QsYUFBYSxJQUFJLENBQUMzRixLQUFLO2dCQUNwQyxJQUFJdUksY0FBYyxJQUFJLENBQUN2SSxLQUFLLEVBQ3hCd0ksZUFBZUQsWUFBWUMsWUFBWSxFQUN2Q0MsY0FBY0YsWUFBWUUsV0FBVyxFQUNyQ0MsZUFBZUgsWUFBWUcsWUFBWTtnQkFDM0MsSUFBSUMsY0FBYztvQkFDaEJILGNBQWNBO29CQUNkQyxhQUFhQTtvQkFDYkMsY0FBY0E7Z0JBQ2hCO2dCQUNBLE9BQU8sV0FBVyxHQUFFaEssTUFBTSxDQUFDLFVBQVUsQ0FBQ29JLGFBQWEsQ0FBQyxPQUFPOUgsU0FBUztvQkFDbEVvSixLQUFLLElBQUksQ0FBQ1EsU0FBUztvQkFDbkIzQixXQUFXO29CQUNYMUMsT0FBTyxJQUFJLENBQUN2RSxLQUFLLENBQUM2SSxVQUFVO2dCQUM5QixHQUFHRixjQUFjL0M7WUFDbkI7UUFDRjtLQUFFO0lBRUYsT0FBT25IO0FBQ1QsRUFBRUMsTUFBTSxDQUFDLFVBQVUsQ0FBQ29LLGFBQWE7QUFFakN2SyxhQUFhLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pdmVyc2FsLWRlbW8tYXBwLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNsaWNrL2xpYi90cmFjay5qcz9jMGZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlRyYWNrID0gdm9pZCAwO1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX2NsYXNzbmFtZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpKTtcblxudmFyIF9pbm5lclNsaWRlclV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMvaW5uZXJTbGlkZXJVdGlsc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBnaXZlbiBzcGVjaWZpY2F0aW9ucy9wcm9wcyBmb3IgYSBzbGlkZSwgZmV0Y2ggYWxsIHRoZSBjbGFzc2VzIHRoYXQgbmVlZCB0byBiZSBhcHBsaWVkIHRvIHRoZSBzbGlkZVxudmFyIGdldFNsaWRlQ2xhc3NlcyA9IGZ1bmN0aW9uIGdldFNsaWRlQ2xhc3NlcyhzcGVjKSB7XG4gIHZhciBzbGlja0FjdGl2ZSwgc2xpY2tDZW50ZXIsIHNsaWNrQ2xvbmVkO1xuICB2YXIgY2VudGVyT2Zmc2V0LCBpbmRleDtcblxuICBpZiAoc3BlYy5ydGwpIHtcbiAgICBpbmRleCA9IHNwZWMuc2xpZGVDb3VudCAtIDEgLSBzcGVjLmluZGV4O1xuICB9IGVsc2Uge1xuICAgIGluZGV4ID0gc3BlYy5pbmRleDtcbiAgfVxuXG4gIHNsaWNrQ2xvbmVkID0gaW5kZXggPCAwIHx8IGluZGV4ID49IHNwZWMuc2xpZGVDb3VudDtcblxuICBpZiAoc3BlYy5jZW50ZXJNb2RlKSB7XG4gICAgY2VudGVyT2Zmc2V0ID0gTWF0aC5mbG9vcihzcGVjLnNsaWRlc1RvU2hvdyAvIDIpO1xuICAgIHNsaWNrQ2VudGVyID0gKGluZGV4IC0gc3BlYy5jdXJyZW50U2xpZGUpICUgc3BlYy5zbGlkZUNvdW50ID09PSAwO1xuXG4gICAgaWYgKGluZGV4ID4gc3BlYy5jdXJyZW50U2xpZGUgLSBjZW50ZXJPZmZzZXQgLSAxICYmIGluZGV4IDw9IHNwZWMuY3VycmVudFNsaWRlICsgY2VudGVyT2Zmc2V0KSB7XG4gICAgICBzbGlja0FjdGl2ZSA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNsaWNrQWN0aXZlID0gc3BlYy5jdXJyZW50U2xpZGUgPD0gaW5kZXggJiYgaW5kZXggPCBzcGVjLmN1cnJlbnRTbGlkZSArIHNwZWMuc2xpZGVzVG9TaG93O1xuICB9XG5cbiAgdmFyIGZvY3VzZWRTbGlkZTtcblxuICBpZiAoc3BlYy50YXJnZXRTbGlkZSA8IDApIHtcbiAgICBmb2N1c2VkU2xpZGUgPSBzcGVjLnRhcmdldFNsaWRlICsgc3BlYy5zbGlkZUNvdW50O1xuICB9IGVsc2UgaWYgKHNwZWMudGFyZ2V0U2xpZGUgPj0gc3BlYy5zbGlkZUNvdW50KSB7XG4gICAgZm9jdXNlZFNsaWRlID0gc3BlYy50YXJnZXRTbGlkZSAtIHNwZWMuc2xpZGVDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBmb2N1c2VkU2xpZGUgPSBzcGVjLnRhcmdldFNsaWRlO1xuICB9XG5cbiAgdmFyIHNsaWNrQ3VycmVudCA9IGluZGV4ID09PSBmb2N1c2VkU2xpZGU7XG4gIHJldHVybiB7XG4gICAgXCJzbGljay1zbGlkZVwiOiB0cnVlLFxuICAgIFwic2xpY2stYWN0aXZlXCI6IHNsaWNrQWN0aXZlLFxuICAgIFwic2xpY2stY2VudGVyXCI6IHNsaWNrQ2VudGVyLFxuICAgIFwic2xpY2stY2xvbmVkXCI6IHNsaWNrQ2xvbmVkLFxuICAgIFwic2xpY2stY3VycmVudFwiOiBzbGlja0N1cnJlbnQgLy8gZHViaW91cyBpbiBjYXNlIG9mIFJUTFxuXG4gIH07XG59O1xuXG52YXIgZ2V0U2xpZGVTdHlsZSA9IGZ1bmN0aW9uIGdldFNsaWRlU3R5bGUoc3BlYykge1xuICB2YXIgc3R5bGUgPSB7fTtcblxuICBpZiAoc3BlYy52YXJpYWJsZVdpZHRoID09PSB1bmRlZmluZWQgfHwgc3BlYy52YXJpYWJsZVdpZHRoID09PSBmYWxzZSkge1xuICAgIHN0eWxlLndpZHRoID0gc3BlYy5zbGlkZVdpZHRoO1xuICB9XG5cbiAgaWYgKHNwZWMuZmFkZSkge1xuICAgIHN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXG4gICAgaWYgKHNwZWMudmVydGljYWwpIHtcbiAgICAgIHN0eWxlLnRvcCA9IC1zcGVjLmluZGV4ICogcGFyc2VJbnQoc3BlYy5zbGlkZUhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmxlZnQgPSAtc3BlYy5pbmRleCAqIHBhcnNlSW50KHNwZWMuc2xpZGVXaWR0aCk7XG4gICAgfVxuXG4gICAgc3R5bGUub3BhY2l0eSA9IHNwZWMuY3VycmVudFNsaWRlID09PSBzcGVjLmluZGV4ID8gMSA6IDA7XG5cbiAgICBpZiAoc3BlYy51c2VDU1MpIHtcbiAgICAgIHN0eWxlLnRyYW5zaXRpb24gPSBcIm9wYWNpdHkgXCIgKyBzcGVjLnNwZWVkICsgXCJtcyBcIiArIHNwZWMuY3NzRWFzZSArIFwiLCBcIiArIFwidmlzaWJpbGl0eSBcIiArIHNwZWMuc3BlZWQgKyBcIm1zIFwiICsgc3BlYy5jc3NFYXNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnZhciBnZXRLZXkgPSBmdW5jdGlvbiBnZXRLZXkoY2hpbGQsIGZhbGxiYWNrS2V5KSB7XG4gIHJldHVybiBjaGlsZC5rZXkgfHwgZmFsbGJhY2tLZXk7XG59O1xuXG52YXIgcmVuZGVyU2xpZGVzID0gZnVuY3Rpb24gcmVuZGVyU2xpZGVzKHNwZWMpIHtcbiAgdmFyIGtleTtcbiAgdmFyIHNsaWRlcyA9IFtdO1xuICB2YXIgcHJlQ2xvbmVTbGlkZXMgPSBbXTtcbiAgdmFyIHBvc3RDbG9uZVNsaWRlcyA9IFtdO1xuXG4gIHZhciBjaGlsZHJlbkNvdW50ID0gX3JlYWN0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5jb3VudChzcGVjLmNoaWxkcmVuKTtcblxuICB2YXIgc3RhcnRJbmRleCA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5sYXp5U3RhcnRJbmRleCkoc3BlYyk7XG4gIHZhciBlbmRJbmRleCA9ICgwLCBfaW5uZXJTbGlkZXJVdGlscy5sYXp5RW5kSW5kZXgpKHNwZWMpO1xuXG4gIF9yZWFjdFtcImRlZmF1bHRcIl0uQ2hpbGRyZW4uZm9yRWFjaChzcGVjLmNoaWxkcmVuLCBmdW5jdGlvbiAoZWxlbSwgaW5kZXgpIHtcbiAgICB2YXIgY2hpbGQ7XG4gICAgdmFyIGNoaWxkT25DbGlja09wdGlvbnMgPSB7XG4gICAgICBtZXNzYWdlOiBcImNoaWxkcmVuXCIsXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBzbGlkZXNUb1Njcm9sbDogc3BlYy5zbGlkZXNUb1Njcm9sbCxcbiAgICAgIGN1cnJlbnRTbGlkZTogc3BlYy5jdXJyZW50U2xpZGVcbiAgICB9OyAvLyBpbiBjYXNlIG9mIGxhenlMb2FkLCB3aGV0aGVyIG9yIG5vdCB3ZSB3YW50IHRvIGZldGNoIHRoZSBzbGlkZVxuXG4gICAgaWYgKCFzcGVjLmxhenlMb2FkIHx8IHNwZWMubGF6eUxvYWQgJiYgc3BlYy5sYXp5TG9hZGVkTGlzdC5pbmRleE9mKGluZGV4KSA+PSAwKSB7XG4gICAgICBjaGlsZCA9IGVsZW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsKTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRTdHlsZSA9IGdldFNsaWRlU3R5bGUoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH0pKTtcbiAgICB2YXIgc2xpZGVDbGFzcyA9IGNoaWxkLnByb3BzLmNsYXNzTmFtZSB8fCBcIlwiO1xuICAgIHZhciBzbGlkZUNsYXNzZXMgPSBnZXRTbGlkZUNsYXNzZXMoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH0pKTsgLy8gcHVzaCBhIGNsb25lZCBlbGVtZW50IG9mIHRoZSBkZXNpcmVkIHNsaWRlXG5cbiAgICBzbGlkZXMucHVzaCggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICBrZXk6IFwib3JpZ2luYWxcIiArIGdldEtleShjaGlsZCwgaW5kZXgpLFxuICAgICAgXCJkYXRhLWluZGV4XCI6IGluZGV4LFxuICAgICAgY2xhc3NOYW1lOiAoMCwgX2NsYXNzbmFtZXNbXCJkZWZhdWx0XCJdKShzbGlkZUNsYXNzZXMsIHNsaWRlQ2xhc3MpLFxuICAgICAgdGFiSW5kZXg6IFwiLTFcIixcbiAgICAgIFwiYXJpYS1oaWRkZW5cIjogIXNsaWRlQ2xhc3Nlc1tcInNsaWNrLWFjdGl2ZVwiXSxcbiAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBvdXRsaW5lOiBcIm5vbmVcIlxuICAgICAgfSwgY2hpbGQucHJvcHMuc3R5bGUgfHwge30pLCBjaGlsZFN0eWxlKSxcbiAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgICBjaGlsZC5wcm9wcyAmJiBjaGlsZC5wcm9wcy5vbkNsaWNrICYmIGNoaWxkLnByb3BzLm9uQ2xpY2soZSk7XG5cbiAgICAgICAgaWYgKHNwZWMuZm9jdXNPblNlbGVjdCkge1xuICAgICAgICAgIHNwZWMuZm9jdXNPblNlbGVjdChjaGlsZE9uQ2xpY2tPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKTsgLy8gaWYgc2xpZGUgbmVlZHMgdG8gYmUgcHJlY2xvbmVkIG9yIHBvc3RjbG9uZWRcblxuICAgIGlmIChzcGVjLmluZmluaXRlICYmIHNwZWMuZmFkZSA9PT0gZmFsc2UpIHtcbiAgICAgIHZhciBwcmVDbG9uZU5vID0gY2hpbGRyZW5Db3VudCAtIGluZGV4O1xuXG4gICAgICBpZiAocHJlQ2xvbmVObyA8PSAoMCwgX2lubmVyU2xpZGVyVXRpbHMuZ2V0UHJlQ2xvbmVzKShzcGVjKSAmJiBjaGlsZHJlbkNvdW50ICE9PSBzcGVjLnNsaWRlc1RvU2hvdykge1xuICAgICAgICBrZXkgPSAtcHJlQ2xvbmVObztcblxuICAgICAgICBpZiAoa2V5ID49IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICBjaGlsZCA9IGVsZW07XG4gICAgICAgIH1cblxuICAgICAgICBzbGlkZUNsYXNzZXMgPSBnZXRTbGlkZUNsYXNzZXMoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgICAgICBpbmRleDoga2V5XG4gICAgICAgIH0pKTtcbiAgICAgICAgcHJlQ2xvbmVTbGlkZXMucHVzaCggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAga2V5OiBcInByZWNsb25lZFwiICsgZ2V0S2V5KGNoaWxkLCBrZXkpLFxuICAgICAgICAgIFwiZGF0YS1pbmRleFwiOiBrZXksXG4gICAgICAgICAgdGFiSW5kZXg6IFwiLTFcIixcbiAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lc1tcImRlZmF1bHRcIl0pKHNsaWRlQ2xhc3Nlcywgc2xpZGVDbGFzcyksXG4gICAgICAgICAgXCJhcmlhLWhpZGRlblwiOiAhc2xpZGVDbGFzc2VzW1wic2xpY2stYWN0aXZlXCJdLFxuICAgICAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNoaWxkLnByb3BzLnN0eWxlIHx8IHt9KSwgY2hpbGRTdHlsZSksXG4gICAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgICAgICBjaGlsZC5wcm9wcyAmJiBjaGlsZC5wcm9wcy5vbkNsaWNrICYmIGNoaWxkLnByb3BzLm9uQ2xpY2soZSk7XG5cbiAgICAgICAgICAgIGlmIChzcGVjLmZvY3VzT25TZWxlY3QpIHtcbiAgICAgICAgICAgICAgc3BlYy5mb2N1c09uU2VsZWN0KGNoaWxkT25DbGlja09wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGRyZW5Db3VudCAhPT0gc3BlYy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAga2V5ID0gY2hpbGRyZW5Db3VudCArIGluZGV4O1xuXG4gICAgICAgIGlmIChrZXkgPCBlbmRJbmRleCkge1xuICAgICAgICAgIGNoaWxkID0gZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNsaWRlQ2xhc3NlcyA9IGdldFNsaWRlQ2xhc3Nlcyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgICAgIGluZGV4OiBrZXlcbiAgICAgICAgfSkpO1xuICAgICAgICBwb3N0Q2xvbmVTbGlkZXMucHVzaCggLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAga2V5OiBcInBvc3RjbG9uZWRcIiArIGdldEtleShjaGlsZCwga2V5KSxcbiAgICAgICAgICBcImRhdGEtaW5kZXhcIjoga2V5LFxuICAgICAgICAgIHRhYkluZGV4OiBcIi0xXCIsXG4gICAgICAgICAgY2xhc3NOYW1lOiAoMCwgX2NsYXNzbmFtZXNbXCJkZWZhdWx0XCJdKShzbGlkZUNsYXNzZXMsIHNsaWRlQ2xhc3MpLFxuICAgICAgICAgIFwiYXJpYS1oaWRkZW5cIjogIXNsaWRlQ2xhc3Nlc1tcInNsaWNrLWFjdGl2ZVwiXSxcbiAgICAgICAgICBzdHlsZTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjaGlsZC5wcm9wcy5zdHlsZSB8fCB7fSksIGNoaWxkU3R5bGUpLFxuICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgICAgICAgY2hpbGQucHJvcHMgJiYgY2hpbGQucHJvcHMub25DbGljayAmJiBjaGlsZC5wcm9wcy5vbkNsaWNrKGUpO1xuXG4gICAgICAgICAgICBpZiAoc3BlYy5mb2N1c09uU2VsZWN0KSB7XG4gICAgICAgICAgICAgIHNwZWMuZm9jdXNPblNlbGVjdChjaGlsZE9uQ2xpY2tPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChzcGVjLnJ0bCkge1xuICAgIHJldHVybiBwcmVDbG9uZVNsaWRlcy5jb25jYXQoc2xpZGVzLCBwb3N0Q2xvbmVTbGlkZXMpLnJldmVyc2UoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlQ2xvbmVTbGlkZXMuY29uY2F0KHNsaWRlcywgcG9zdENsb25lU2xpZGVzKTtcbiAgfVxufTtcblxudmFyIFRyYWNrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoVHJhY2ssIF9SZWFjdCRQdXJlQ29tcG9uZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFRyYWNrKTtcblxuICBmdW5jdGlvbiBUcmFjaygpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhY2spO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwuYXBwbHkoX3N1cGVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJub2RlXCIsIG51bGwpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhhbmRsZVJlZlwiLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICBfdGhpcy5ub2RlID0gcmVmO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRyYWNrLCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIHNsaWRlcyA9IHJlbmRlclNsaWRlcyh0aGlzLnByb3BzKTtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgb25Nb3VzZUVudGVyID0gX3RoaXMkcHJvcHMub25Nb3VzZUVudGVyLFxuICAgICAgICAgIG9uTW91c2VPdmVyID0gX3RoaXMkcHJvcHMub25Nb3VzZU92ZXIsXG4gICAgICAgICAgb25Nb3VzZUxlYXZlID0gX3RoaXMkcHJvcHMub25Nb3VzZUxlYXZlO1xuICAgICAgdmFyIG1vdXNlRXZlbnRzID0ge1xuICAgICAgICBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlcixcbiAgICAgICAgb25Nb3VzZU92ZXI6IG9uTW91c2VPdmVyLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IG9uTW91c2VMZWF2ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICAgICAgcmVmOiB0aGlzLmhhbmRsZVJlZixcbiAgICAgICAgY2xhc3NOYW1lOiBcInNsaWNrLXRyYWNrXCIsXG4gICAgICAgIHN0eWxlOiB0aGlzLnByb3BzLnRyYWNrU3R5bGVcbiAgICAgIH0sIG1vdXNlRXZlbnRzKSwgc2xpZGVzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJhY2s7XG59KF9yZWFjdFtcImRlZmF1bHRcIl0uUHVyZUNvbXBvbmVudCk7XG5cbmV4cG9ydHMuVHJhY2sgPSBUcmFjazsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlRyYWNrIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfY2xhc3NuYW1lcyIsIl9pbm5lclNsaWRlclV0aWxzIiwiX19lc01vZHVsZSIsIl9leHRlbmRzIiwiYXNzaWduIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwibyIsInAiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIl9jcmVhdGVTdXBlciIsIkRlcml2ZWQiLCJoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9jcmVhdGVTdXBlckludGVybmFsIiwiU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJyZXN1bHQiLCJOZXdUYXJnZXQiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInZhbHVlT2YiLCJlIiwiZ2V0UHJvdG90eXBlT2YiLCJvd25LZXlzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInB1c2giLCJfb2JqZWN0U3ByZWFkIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0U2xpZGVDbGFzc2VzIiwic3BlYyIsInNsaWNrQWN0aXZlIiwic2xpY2tDZW50ZXIiLCJzbGlja0Nsb25lZCIsImNlbnRlck9mZnNldCIsImluZGV4IiwicnRsIiwic2xpZGVDb3VudCIsImNlbnRlck1vZGUiLCJNYXRoIiwiZmxvb3IiLCJzbGlkZXNUb1Nob3ciLCJjdXJyZW50U2xpZGUiLCJmb2N1c2VkU2xpZGUiLCJ0YXJnZXRTbGlkZSIsInNsaWNrQ3VycmVudCIsImdldFNsaWRlU3R5bGUiLCJzdHlsZSIsInZhcmlhYmxlV2lkdGgiLCJ1bmRlZmluZWQiLCJ3aWR0aCIsInNsaWRlV2lkdGgiLCJmYWRlIiwicG9zaXRpb24iLCJ2ZXJ0aWNhbCIsInRvcCIsInBhcnNlSW50Iiwic2xpZGVIZWlnaHQiLCJsZWZ0Iiwib3BhY2l0eSIsInVzZUNTUyIsInRyYW5zaXRpb24iLCJzcGVlZCIsImNzc0Vhc2UiLCJnZXRLZXkiLCJjaGlsZCIsImZhbGxiYWNrS2V5IiwicmVuZGVyU2xpZGVzIiwic2xpZGVzIiwicHJlQ2xvbmVTbGlkZXMiLCJwb3N0Q2xvbmVTbGlkZXMiLCJjaGlsZHJlbkNvdW50IiwiQ2hpbGRyZW4iLCJjb3VudCIsImNoaWxkcmVuIiwic3RhcnRJbmRleCIsImxhenlTdGFydEluZGV4IiwiZW5kSW5kZXgiLCJsYXp5RW5kSW5kZXgiLCJlbGVtIiwiY2hpbGRPbkNsaWNrT3B0aW9ucyIsIm1lc3NhZ2UiLCJzbGlkZXNUb1Njcm9sbCIsImxhenlMb2FkIiwibGF6eUxvYWRlZExpc3QiLCJpbmRleE9mIiwiY3JlYXRlRWxlbWVudCIsImNoaWxkU3R5bGUiLCJzbGlkZUNsYXNzIiwiY2xhc3NOYW1lIiwic2xpZGVDbGFzc2VzIiwiY2xvbmVFbGVtZW50IiwidGFiSW5kZXgiLCJvdXRsaW5lIiwib25DbGljayIsImZvY3VzT25TZWxlY3QiLCJpbmZpbml0ZSIsInByZUNsb25lTm8iLCJnZXRQcmVDbG9uZXMiLCJjb25jYXQiLCJyZXZlcnNlIiwiX1JlYWN0JFB1cmVDb21wb25lbnQiLCJfc3VwZXIiLCJfdGhpcyIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwicmVmIiwibm9kZSIsInJlbmRlciIsIl90aGlzJHByb3BzIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZU92ZXIiLCJvbk1vdXNlTGVhdmUiLCJtb3VzZUV2ZW50cyIsImhhbmRsZVJlZiIsInRyYWNrU3R5bGUiLCJQdXJlQ29tcG9uZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-slick/lib/track.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-slick/lib/utils/innerSliderUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-slick/lib/utils/innerSliderUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.checkSpecKeys = exports.checkNavigable = exports.changeSlide = exports.canUseDOM = exports.canGoNext = void 0;\nexports.clamp = clamp;\nexports.swipeStart = exports.swipeMove = exports.swipeEnd = exports.slidesOnRight = exports.slidesOnLeft = exports.slideHandler = exports.siblingDirection = exports.safePreventDefault = exports.lazyStartIndex = exports.lazySlidesOnRight = exports.lazySlidesOnLeft = exports.lazyEndIndex = exports.keyHandler = exports.initializedState = exports.getWidth = exports.getTrackLeft = exports.getTrackCSS = exports.getTrackAnimateCSS = exports.getTotalSlides = exports.getSwipeDirection = exports.getSlideCount = exports.getRequiredLazySlides = exports.getPreClones = exports.getPostClones = exports.getOnDemandLazySlides = exports.getNavigableIndexes = exports.getHeight = exports.extractObject = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction clamp(number, lowerBound, upperBound) {\n    return Math.max(lowerBound, Math.min(number, upperBound));\n}\nvar safePreventDefault = function safePreventDefault(event) {\n    var passiveEvents = [\n        \"onTouchStart\",\n        \"onTouchMove\",\n        \"onWheel\"\n    ];\n    if (!passiveEvents.includes(event._reactName)) {\n        event.preventDefault();\n    }\n};\nexports.safePreventDefault = safePreventDefault;\nvar getOnDemandLazySlides = function getOnDemandLazySlides(spec) {\n    var onDemandSlides = [];\n    var startIndex = lazyStartIndex(spec);\n    var endIndex = lazyEndIndex(spec);\n    for(var slideIndex = startIndex; slideIndex < endIndex; slideIndex++){\n        if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {\n            onDemandSlides.push(slideIndex);\n        }\n    }\n    return onDemandSlides;\n}; // return list of slides that need to be present\nexports.getOnDemandLazySlides = getOnDemandLazySlides;\nvar getRequiredLazySlides = function getRequiredLazySlides(spec) {\n    var requiredSlides = [];\n    var startIndex = lazyStartIndex(spec);\n    var endIndex = lazyEndIndex(spec);\n    for(var slideIndex = startIndex; slideIndex < endIndex; slideIndex++){\n        requiredSlides.push(slideIndex);\n    }\n    return requiredSlides;\n}; // startIndex that needs to be present\nexports.getRequiredLazySlides = getRequiredLazySlides;\nvar lazyStartIndex = function lazyStartIndex(spec) {\n    return spec.currentSlide - lazySlidesOnLeft(spec);\n};\nexports.lazyStartIndex = lazyStartIndex;\nvar lazyEndIndex = function lazyEndIndex(spec) {\n    return spec.currentSlide + lazySlidesOnRight(spec);\n};\nexports.lazyEndIndex = lazyEndIndex;\nvar lazySlidesOnLeft = function lazySlidesOnLeft(spec) {\n    return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;\n};\nexports.lazySlidesOnLeft = lazySlidesOnLeft;\nvar lazySlidesOnRight = function lazySlidesOnRight(spec) {\n    return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;\n}; // get width of an element\nexports.lazySlidesOnRight = lazySlidesOnRight;\nvar getWidth = function getWidth(elem) {\n    return elem && elem.offsetWidth || 0;\n};\nexports.getWidth = getWidth;\nvar getHeight = function getHeight(elem) {\n    return elem && elem.offsetHeight || 0;\n};\nexports.getHeight = getHeight;\nvar getSwipeDirection = function getSwipeDirection(touchObject) {\n    var verticalSwiping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var xDist, yDist, r, swipeAngle;\n    xDist = touchObject.startX - touchObject.curX;\n    yDist = touchObject.startY - touchObject.curY;\n    r = Math.atan2(yDist, xDist);\n    swipeAngle = Math.round(r * 180 / Math.PI);\n    if (swipeAngle < 0) {\n        swipeAngle = 360 - Math.abs(swipeAngle);\n    }\n    if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n        return \"left\";\n    }\n    if (swipeAngle >= 135 && swipeAngle <= 225) {\n        return \"right\";\n    }\n    if (verticalSwiping === true) {\n        if (swipeAngle >= 35 && swipeAngle <= 135) {\n            return \"up\";\n        } else {\n            return \"down\";\n        }\n    }\n    return \"vertical\";\n}; // whether or not we can go next\nexports.getSwipeDirection = getSwipeDirection;\nvar canGoNext = function canGoNext(spec) {\n    var canGo = true;\n    if (!spec.infinite) {\n        if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {\n            canGo = false;\n        } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {\n            canGo = false;\n        }\n    }\n    return canGo;\n}; // given an object and a list of keys, return new object with given keys\nexports.canGoNext = canGoNext;\nvar extractObject = function extractObject(spec, keys) {\n    var newObject = {};\n    keys.forEach(function(key) {\n        return newObject[key] = spec[key];\n    });\n    return newObject;\n}; // get initialized state\nexports.extractObject = extractObject;\nvar initializedState = function initializedState(spec) {\n    // spec also contains listRef, trackRef\n    var slideCount = _react[\"default\"].Children.count(spec.children);\n    var listNode = spec.listRef;\n    var listWidth = Math.ceil(getWidth(listNode));\n    var trackNode = spec.trackRef && spec.trackRef.node;\n    var trackWidth = Math.ceil(getWidth(trackNode));\n    var slideWidth;\n    if (!spec.vertical) {\n        var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;\n        if (typeof spec.centerPadding === \"string\" && spec.centerPadding.slice(-1) === \"%\") {\n            centerPaddingAdj *= listWidth / 100;\n        }\n        slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);\n    } else {\n        slideWidth = listWidth;\n    }\n    var slideHeight = listNode && getHeight(listNode.querySelector('[data-index=\"0\"]'));\n    var listHeight = slideHeight * spec.slidesToShow;\n    var currentSlide = spec.currentSlide === undefined ? spec.initialSlide : spec.currentSlide;\n    if (spec.rtl && spec.currentSlide === undefined) {\n        currentSlide = slideCount - 1 - spec.initialSlide;\n    }\n    var lazyLoadedList = spec.lazyLoadedList || [];\n    var slidesToLoad = getOnDemandLazySlides(_objectSpread(_objectSpread({}, spec), {}, {\n        currentSlide: currentSlide,\n        lazyLoadedList: lazyLoadedList\n    }));\n    lazyLoadedList = lazyLoadedList.concat(slidesToLoad);\n    var state = {\n        slideCount: slideCount,\n        slideWidth: slideWidth,\n        listWidth: listWidth,\n        trackWidth: trackWidth,\n        currentSlide: currentSlide,\n        slideHeight: slideHeight,\n        listHeight: listHeight,\n        lazyLoadedList: lazyLoadedList\n    };\n    if (spec.autoplaying === null && spec.autoplay) {\n        state[\"autoplaying\"] = \"playing\";\n    }\n    return state;\n};\nexports.initializedState = initializedState;\nvar slideHandler = function slideHandler(spec) {\n    var waitForAnimate = spec.waitForAnimate, animating = spec.animating, fade = spec.fade, infinite = spec.infinite, index = spec.index, slideCount = spec.slideCount, lazyLoad = spec.lazyLoad, currentSlide = spec.currentSlide, centerMode = spec.centerMode, slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, useCSS = spec.useCSS;\n    var lazyLoadedList = spec.lazyLoadedList;\n    if (waitForAnimate && animating) return {};\n    var animationSlide = index, finalSlide, animationLeft, finalLeft;\n    var state = {}, nextState = {};\n    var targetSlide = infinite ? index : clamp(index, 0, slideCount - 1);\n    if (fade) {\n        if (!infinite && (index < 0 || index >= slideCount)) return {};\n        if (index < 0) {\n            animationSlide = index + slideCount;\n        } else if (index >= slideCount) {\n            animationSlide = index - slideCount;\n        }\n        if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {\n            lazyLoadedList = lazyLoadedList.concat(animationSlide);\n        }\n        state = {\n            animating: true,\n            currentSlide: animationSlide,\n            lazyLoadedList: lazyLoadedList,\n            targetSlide: animationSlide\n        };\n        nextState = {\n            animating: false,\n            targetSlide: animationSlide\n        };\n    } else {\n        finalSlide = animationSlide;\n        if (animationSlide < 0) {\n            finalSlide = animationSlide + slideCount;\n            if (!infinite) finalSlide = 0;\n            else if (slideCount % slidesToScroll !== 0) finalSlide = slideCount - slideCount % slidesToScroll;\n        } else if (!canGoNext(spec) && animationSlide > currentSlide) {\n            animationSlide = finalSlide = currentSlide;\n        } else if (centerMode && animationSlide >= slideCount) {\n            animationSlide = infinite ? slideCount : slideCount - 1;\n            finalSlide = infinite ? 0 : slideCount - 1;\n        } else if (animationSlide >= slideCount) {\n            finalSlide = animationSlide - slideCount;\n            if (!infinite) finalSlide = slideCount - slidesToShow;\n            else if (slideCount % slidesToScroll !== 0) finalSlide = 0;\n        }\n        if (!infinite && animationSlide + slidesToShow >= slideCount) {\n            finalSlide = slideCount - slidesToShow;\n        }\n        animationLeft = getTrackLeft(_objectSpread(_objectSpread({}, spec), {}, {\n            slideIndex: animationSlide\n        }));\n        finalLeft = getTrackLeft(_objectSpread(_objectSpread({}, spec), {}, {\n            slideIndex: finalSlide\n        }));\n        if (!infinite) {\n            if (animationLeft === finalLeft) animationSlide = finalSlide;\n            animationLeft = finalLeft;\n        }\n        if (lazyLoad) {\n            lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread(_objectSpread({}, spec), {}, {\n                currentSlide: animationSlide\n            })));\n        }\n        if (!useCSS) {\n            state = {\n                currentSlide: finalSlide,\n                trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n                    left: finalLeft\n                })),\n                lazyLoadedList: lazyLoadedList,\n                targetSlide: targetSlide\n            };\n        } else {\n            state = {\n                animating: true,\n                currentSlide: finalSlide,\n                trackStyle: getTrackAnimateCSS(_objectSpread(_objectSpread({}, spec), {}, {\n                    left: animationLeft\n                })),\n                lazyLoadedList: lazyLoadedList,\n                targetSlide: targetSlide\n            };\n            nextState = {\n                animating: false,\n                currentSlide: finalSlide,\n                trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n                    left: finalLeft\n                })),\n                swipeLeft: null,\n                targetSlide: targetSlide\n            };\n        }\n    }\n    return {\n        state: state,\n        nextState: nextState\n    };\n};\nexports.slideHandler = slideHandler;\nvar changeSlide = function changeSlide(spec, options) {\n    var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;\n    var slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, slideCount = spec.slideCount, currentSlide = spec.currentSlide, previousTargetSlide = spec.targetSlide, lazyLoad = spec.lazyLoad, infinite = spec.infinite;\n    unevenOffset = slideCount % slidesToScroll !== 0;\n    indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;\n    if (options.message === \"previous\") {\n        slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;\n        targetSlide = currentSlide - slideOffset;\n        if (lazyLoad && !infinite) {\n            previousInt = currentSlide - slideOffset;\n            targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;\n        }\n        if (!infinite) {\n            targetSlide = previousTargetSlide - slidesToScroll;\n        }\n    } else if (options.message === \"next\") {\n        slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;\n        targetSlide = currentSlide + slideOffset;\n        if (lazyLoad && !infinite) {\n            targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;\n        }\n        if (!infinite) {\n            targetSlide = previousTargetSlide + slidesToScroll;\n        }\n    } else if (options.message === \"dots\") {\n        // Click on dots\n        targetSlide = options.index * options.slidesToScroll;\n    } else if (options.message === \"children\") {\n        // Click on the slides\n        targetSlide = options.index;\n        if (infinite) {\n            var direction = siblingDirection(_objectSpread(_objectSpread({}, spec), {}, {\n                targetSlide: targetSlide\n            }));\n            if (targetSlide > options.currentSlide && direction === \"left\") {\n                targetSlide = targetSlide - slideCount;\n            } else if (targetSlide < options.currentSlide && direction === \"right\") {\n                targetSlide = targetSlide + slideCount;\n            }\n        }\n    } else if (options.message === \"index\") {\n        targetSlide = Number(options.index);\n    }\n    return targetSlide;\n};\nexports.changeSlide = changeSlide;\nvar keyHandler = function keyHandler(e, accessibility, rtl) {\n    if (e.target.tagName.match(\"TEXTAREA|INPUT|SELECT\") || !accessibility) return \"\";\n    if (e.keyCode === 37) return rtl ? \"next\" : \"previous\";\n    if (e.keyCode === 39) return rtl ? \"previous\" : \"next\";\n    return \"\";\n};\nexports.keyHandler = keyHandler;\nvar swipeStart = function swipeStart(e, swipe, draggable) {\n    e.target.tagName === \"IMG\" && safePreventDefault(e);\n    if (!swipe || !draggable && e.type.indexOf(\"mouse\") !== -1) return \"\";\n    return {\n        dragging: true,\n        touchObject: {\n            startX: e.touches ? e.touches[0].pageX : e.clientX,\n            startY: e.touches ? e.touches[0].pageY : e.clientY,\n            curX: e.touches ? e.touches[0].pageX : e.clientX,\n            curY: e.touches ? e.touches[0].pageY : e.clientY\n        }\n    };\n};\nexports.swipeStart = swipeStart;\nvar swipeMove = function swipeMove(e, spec) {\n    // spec also contains, trackRef and slideIndex\n    var scrolling = spec.scrolling, animating = spec.animating, vertical = spec.vertical, swipeToSlide = spec.swipeToSlide, verticalSwiping = spec.verticalSwiping, rtl = spec.rtl, currentSlide = spec.currentSlide, edgeFriction = spec.edgeFriction, edgeDragged = spec.edgeDragged, onEdge = spec.onEdge, swiped = spec.swiped, swiping = spec.swiping, slideCount = spec.slideCount, slidesToScroll = spec.slidesToScroll, infinite = spec.infinite, touchObject = spec.touchObject, swipeEvent = spec.swipeEvent, listHeight = spec.listHeight, listWidth = spec.listWidth;\n    if (scrolling) return;\n    if (animating) return safePreventDefault(e);\n    if (vertical && swipeToSlide && verticalSwiping) safePreventDefault(e);\n    var swipeLeft, state = {};\n    var curLeft = getTrackLeft(spec);\n    touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;\n    touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;\n    touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));\n    var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));\n    if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {\n        return {\n            scrolling: true\n        };\n    }\n    if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength;\n    var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);\n    if (verticalSwiping) positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;\n    var dotCount = Math.ceil(slideCount / slidesToScroll);\n    var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);\n    var touchSwipeLength = touchObject.swipeLength;\n    if (!infinite) {\n        if (currentSlide === 0 && (swipeDirection === \"right\" || swipeDirection === \"down\") || currentSlide + 1 >= dotCount && (swipeDirection === \"left\" || swipeDirection === \"up\") || !canGoNext(spec) && (swipeDirection === \"left\" || swipeDirection === \"up\")) {\n            touchSwipeLength = touchObject.swipeLength * edgeFriction;\n            if (edgeDragged === false && onEdge) {\n                onEdge(swipeDirection);\n                state[\"edgeDragged\"] = true;\n            }\n        }\n    }\n    if (!swiped && swipeEvent) {\n        swipeEvent(swipeDirection);\n        state[\"swiped\"] = true;\n    }\n    if (!vertical) {\n        if (!rtl) {\n            swipeLeft = curLeft + touchSwipeLength * positionOffset;\n        } else {\n            swipeLeft = curLeft - touchSwipeLength * positionOffset;\n        }\n    } else {\n        swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;\n    }\n    if (verticalSwiping) {\n        swipeLeft = curLeft + touchSwipeLength * positionOffset;\n    }\n    state = _objectSpread(_objectSpread({}, state), {}, {\n        touchObject: touchObject,\n        swipeLeft: swipeLeft,\n        trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n            left: swipeLeft\n        }))\n    });\n    if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {\n        return state;\n    }\n    if (touchObject.swipeLength > 10) {\n        state[\"swiping\"] = true;\n        safePreventDefault(e);\n    }\n    return state;\n};\nexports.swipeMove = swipeMove;\nvar swipeEnd = function swipeEnd(e, spec) {\n    var dragging = spec.dragging, swipe = spec.swipe, touchObject = spec.touchObject, listWidth = spec.listWidth, touchThreshold = spec.touchThreshold, verticalSwiping = spec.verticalSwiping, listHeight = spec.listHeight, swipeToSlide = spec.swipeToSlide, scrolling = spec.scrolling, onSwipe = spec.onSwipe, targetSlide = spec.targetSlide, currentSlide = spec.currentSlide, infinite = spec.infinite;\n    if (!dragging) {\n        if (swipe) safePreventDefault(e);\n        return {};\n    }\n    var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;\n    var swipeDirection = getSwipeDirection(touchObject, verticalSwiping); // reset the state of touch related state variables.\n    var state = {\n        dragging: false,\n        edgeDragged: false,\n        scrolling: false,\n        swiping: false,\n        swiped: false,\n        swipeLeft: null,\n        touchObject: {}\n    };\n    if (scrolling) {\n        return state;\n    }\n    if (!touchObject.swipeLength) {\n        return state;\n    }\n    if (touchObject.swipeLength > minSwipe) {\n        safePreventDefault(e);\n        if (onSwipe) {\n            onSwipe(swipeDirection);\n        }\n        var slideCount, newSlide;\n        var activeSlide = infinite ? currentSlide : targetSlide;\n        switch(swipeDirection){\n            case \"left\":\n            case \"up\":\n                newSlide = activeSlide + getSlideCount(spec);\n                slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n                state[\"currentDirection\"] = 0;\n                break;\n            case \"right\":\n            case \"down\":\n                newSlide = activeSlide - getSlideCount(spec);\n                slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n                state[\"currentDirection\"] = 1;\n                break;\n            default:\n                slideCount = activeSlide;\n        }\n        state[\"triggerSlideHandler\"] = slideCount;\n    } else {\n        // Adjust the track back to it's original position.\n        var currentLeft = getTrackLeft(spec);\n        state[\"trackStyle\"] = getTrackAnimateCSS(_objectSpread(_objectSpread({}, spec), {}, {\n            left: currentLeft\n        }));\n    }\n    return state;\n};\nexports.swipeEnd = swipeEnd;\nvar getNavigableIndexes = function getNavigableIndexes(spec) {\n    var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;\n    var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;\n    var counter = spec.infinite ? spec.slidesToShow * -1 : 0;\n    var indexes = [];\n    while(breakpoint < max){\n        indexes.push(breakpoint);\n        breakpoint = counter + spec.slidesToScroll;\n        counter += Math.min(spec.slidesToScroll, spec.slidesToShow);\n    }\n    return indexes;\n};\nexports.getNavigableIndexes = getNavigableIndexes;\nvar checkNavigable = function checkNavigable(spec, index) {\n    var navigables = getNavigableIndexes(spec);\n    var prevNavigable = 0;\n    if (index > navigables[navigables.length - 1]) {\n        index = navigables[navigables.length - 1];\n    } else {\n        for(var n in navigables){\n            if (index < navigables[n]) {\n                index = prevNavigable;\n                break;\n            }\n            prevNavigable = navigables[n];\n        }\n    }\n    return index;\n};\nexports.checkNavigable = checkNavigable;\nvar getSlideCount = function getSlideCount(spec) {\n    var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;\n    if (spec.swipeToSlide) {\n        var swipedSlide;\n        var slickList = spec.listRef;\n        var slides = slickList.querySelectorAll && slickList.querySelectorAll(\".slick-slide\") || [];\n        Array.from(slides).every(function(slide) {\n            if (!spec.vertical) {\n                if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {\n                    swipedSlide = slide;\n                    return false;\n                }\n            } else {\n                if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {\n                    swipedSlide = slide;\n                    return false;\n                }\n            }\n            return true;\n        });\n        if (!swipedSlide) {\n            return 0;\n        }\n        var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;\n        var slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;\n        return slidesTraversed;\n    } else {\n        return spec.slidesToScroll;\n    }\n};\nexports.getSlideCount = getSlideCount;\nvar checkSpecKeys = function checkSpecKeys(spec, keysArray) {\n    return keysArray.reduce(function(value, key) {\n        return value && spec.hasOwnProperty(key);\n    }, true) ? null : console.error(\"Keys Missing:\", spec);\n};\nexports.checkSpecKeys = checkSpecKeys;\nvar getTrackCSS = function getTrackCSS(spec) {\n    checkSpecKeys(spec, [\n        \"left\",\n        \"variableWidth\",\n        \"slideCount\",\n        \"slidesToShow\",\n        \"slideWidth\"\n    ]);\n    var trackWidth, trackHeight;\n    var trackChildren = spec.slideCount + 2 * spec.slidesToShow;\n    if (!spec.vertical) {\n        trackWidth = getTotalSlides(spec) * spec.slideWidth;\n    } else {\n        trackHeight = trackChildren * spec.slideHeight;\n    }\n    var style = {\n        opacity: 1,\n        transition: \"\",\n        WebkitTransition: \"\"\n    };\n    if (spec.useTransform) {\n        var WebkitTransform = !spec.vertical ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\" : \"translate3d(0px, \" + spec.left + \"px, 0px)\";\n        var transform = !spec.vertical ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\" : \"translate3d(0px, \" + spec.left + \"px, 0px)\";\n        var msTransform = !spec.vertical ? \"translateX(\" + spec.left + \"px)\" : \"translateY(\" + spec.left + \"px)\";\n        style = _objectSpread(_objectSpread({}, style), {}, {\n            WebkitTransform: WebkitTransform,\n            transform: transform,\n            msTransform: msTransform\n        });\n    } else {\n        if (spec.vertical) {\n            style[\"top\"] = spec.left;\n        } else {\n            style[\"left\"] = spec.left;\n        }\n    }\n    if (spec.fade) style = {\n        opacity: 1\n    };\n    if (trackWidth) style.width = trackWidth;\n    if (trackHeight) style.height = trackHeight; // Fallback for IE8\n    if (window && !window.addEventListener && window.attachEvent) {\n        if (!spec.vertical) {\n            style.marginLeft = spec.left + \"px\";\n        } else {\n            style.marginTop = spec.left + \"px\";\n        }\n    }\n    return style;\n};\nexports.getTrackCSS = getTrackCSS;\nvar getTrackAnimateCSS = function getTrackAnimateCSS(spec) {\n    checkSpecKeys(spec, [\n        \"left\",\n        \"variableWidth\",\n        \"slideCount\",\n        \"slidesToShow\",\n        \"slideWidth\",\n        \"speed\",\n        \"cssEase\"\n    ]);\n    var style = getTrackCSS(spec); // useCSS is true by default so it can be undefined\n    if (spec.useTransform) {\n        style.WebkitTransition = \"-webkit-transform \" + spec.speed + \"ms \" + spec.cssEase;\n        style.transition = \"transform \" + spec.speed + \"ms \" + spec.cssEase;\n    } else {\n        if (spec.vertical) {\n            style.transition = \"top \" + spec.speed + \"ms \" + spec.cssEase;\n        } else {\n            style.transition = \"left \" + spec.speed + \"ms \" + spec.cssEase;\n        }\n    }\n    return style;\n};\nexports.getTrackAnimateCSS = getTrackAnimateCSS;\nvar getTrackLeft = function getTrackLeft(spec) {\n    if (spec.unslick) {\n        return 0;\n    }\n    checkSpecKeys(spec, [\n        \"slideIndex\",\n        \"trackRef\",\n        \"infinite\",\n        \"centerMode\",\n        \"slideCount\",\n        \"slidesToShow\",\n        \"slidesToScroll\",\n        \"slideWidth\",\n        \"listWidth\",\n        \"variableWidth\",\n        \"slideHeight\"\n    ]);\n    var slideIndex = spec.slideIndex, trackRef = spec.trackRef, infinite = spec.infinite, centerMode = spec.centerMode, slideCount = spec.slideCount, slidesToShow = spec.slidesToShow, slidesToScroll = spec.slidesToScroll, slideWidth = spec.slideWidth, listWidth = spec.listWidth, variableWidth = spec.variableWidth, slideHeight = spec.slideHeight, fade = spec.fade, vertical = spec.vertical;\n    var slideOffset = 0;\n    var targetLeft;\n    var targetSlide;\n    var verticalOffset = 0;\n    if (fade || spec.slideCount === 1) {\n        return 0;\n    }\n    var slidesToOffset = 0;\n    if (infinite) {\n        slidesToOffset = -getPreClones(spec); // bring active slide to the beginning of visual area\n        // if next scroll doesn't have enough children, just reach till the end of original slides instead of shifting slidesToScroll children\n        if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n            slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);\n        } // shift current slide to center of the frame\n        if (centerMode) {\n            slidesToOffset += parseInt(slidesToShow / 2);\n        }\n    } else {\n        if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n            slidesToOffset = slidesToShow - slideCount % slidesToScroll;\n        }\n        if (centerMode) {\n            slidesToOffset = parseInt(slidesToShow / 2);\n        }\n    }\n    slideOffset = slidesToOffset * slideWidth;\n    verticalOffset = slidesToOffset * slideHeight;\n    if (!vertical) {\n        targetLeft = slideIndex * slideWidth * -1 + slideOffset;\n    } else {\n        targetLeft = slideIndex * slideHeight * -1 + verticalOffset;\n    }\n    if (variableWidth === true) {\n        var targetSlideIndex;\n        var trackElem = trackRef && trackRef.node;\n        targetSlideIndex = slideIndex + getPreClones(spec);\n        targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];\n        targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;\n        if (centerMode === true) {\n            targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;\n            targetSlide = trackElem && trackElem.children[targetSlideIndex];\n            targetLeft = 0;\n            for(var slide = 0; slide < targetSlideIndex; slide++){\n                targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;\n            }\n            targetLeft -= parseInt(spec.centerPadding);\n            targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;\n        }\n    }\n    return targetLeft;\n};\nexports.getTrackLeft = getTrackLeft;\nvar getPreClones = function getPreClones(spec) {\n    if (spec.unslick || !spec.infinite) {\n        return 0;\n    }\n    if (spec.variableWidth) {\n        return spec.slideCount;\n    }\n    return spec.slidesToShow + (spec.centerMode ? 1 : 0);\n};\nexports.getPreClones = getPreClones;\nvar getPostClones = function getPostClones(spec) {\n    if (spec.unslick || !spec.infinite) {\n        return 0;\n    }\n    return spec.slideCount;\n};\nexports.getPostClones = getPostClones;\nvar getTotalSlides = function getTotalSlides(spec) {\n    return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);\n};\nexports.getTotalSlides = getTotalSlides;\nvar siblingDirection = function siblingDirection(spec) {\n    if (spec.targetSlide > spec.currentSlide) {\n        if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {\n            return \"left\";\n        }\n        return \"right\";\n    } else {\n        if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {\n            return \"right\";\n        }\n        return \"left\";\n    }\n};\nexports.siblingDirection = siblingDirection;\nvar slidesOnRight = function slidesOnRight(_ref) {\n    var slidesToShow = _ref.slidesToShow, centerMode = _ref.centerMode, rtl = _ref.rtl, centerPadding = _ref.centerPadding;\n    // returns no of slides on the right of active slide\n    if (centerMode) {\n        var right = (slidesToShow - 1) / 2 + 1;\n        if (parseInt(centerPadding) > 0) right += 1;\n        if (rtl && slidesToShow % 2 === 0) right += 1;\n        return right;\n    }\n    if (rtl) {\n        return 0;\n    }\n    return slidesToShow - 1;\n};\nexports.slidesOnRight = slidesOnRight;\nvar slidesOnLeft = function slidesOnLeft(_ref2) {\n    var slidesToShow = _ref2.slidesToShow, centerMode = _ref2.centerMode, rtl = _ref2.rtl, centerPadding = _ref2.centerPadding;\n    // returns no of slides on the left of active slide\n    if (centerMode) {\n        var left = (slidesToShow - 1) / 2 + 1;\n        if (parseInt(centerPadding) > 0) left += 1;\n        if (!rtl && slidesToShow % 2 === 0) left += 1;\n        return left;\n    }\n    if (rtl) {\n        return slidesToShow - 1;\n    }\n    return 0;\n};\nexports.slidesOnLeft = slidesOnLeft;\nvar canUseDOM = function canUseDOM() {\n    return !!( false && 0);\n};\nexports.canUseDOM = canUseDOM;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpY2svbGliL3V0aWxzL2lubmVyU2xpZGVyVXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHFCQUFxQixHQUFHQSxzQkFBc0IsR0FBR0EsbUJBQW1CLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBRyxLQUFLO0FBQ3BIQSxhQUFhLEdBQUdPO0FBQ2hCUCxrQkFBa0IsR0FBR0EsaUJBQWlCLEdBQUdBLGdCQUFnQixHQUFHQSxxQkFBcUIsR0FBR0Esb0JBQW9CLEdBQUdBLG9CQUFvQixHQUFHQSx3QkFBd0IsR0FBR0EsMEJBQTBCLEdBQUdBLHNCQUFzQixHQUFHQSx5QkFBeUIsR0FBR0Esd0JBQXdCLEdBQUdBLG9CQUFvQixHQUFHQSxrQkFBa0IsR0FBR0Esd0JBQXdCLEdBQUdBLGdCQUFnQixHQUFHQSxvQkFBb0IsR0FBR0EsbUJBQW1CLEdBQUdBLDBCQUEwQixHQUFHQSxzQkFBc0IsR0FBR0EseUJBQXlCLEdBQUdBLHFCQUFxQixHQUFHQSw2QkFBNkIsR0FBR0Esb0JBQW9CLEdBQUdBLHFCQUFxQixHQUFHQSw2QkFBNkIsR0FBR0EsMkJBQTJCLEdBQUdBLGlCQUFpQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBRXpyQixJQUFJb0MsU0FBU0MsdUJBQXVCQyxtQkFBT0EsQ0FBQyx3R0FBTztBQUVuRCxTQUFTRCx1QkFBdUJFLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFFaEcsU0FBU0UsUUFBUUMsTUFBTSxFQUFFQyxjQUFjO0lBQUksSUFBSUMsT0FBTzlDLE9BQU84QyxJQUFJLENBQUNGO0lBQVMsSUFBSTVDLE9BQU8rQyxxQkFBcUIsRUFBRTtRQUFFLElBQUlDLFVBQVVoRCxPQUFPK0MscUJBQXFCLENBQUNIO1FBQVNDLGtCQUFtQkcsQ0FBQUEs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SUFBSWtFLE9BQU8sQ0FBQ2hFLGVBQWUsS0FBSyxJQUFJO1FBQ3BDLElBQUlDLFNBQVNDLGlCQUFpQixHQUFHOEQsUUFBUTtRQUN6QyxJQUFJLENBQUNwQixPQUFPNUMsZUFBZSxNQUFNLEdBQUdnRSxRQUFRO1FBQzVDLE9BQU9BO0lBQ1Q7SUFFQSxJQUFJcEIsS0FBSztRQUNQLE9BQU81QyxlQUFlO0lBQ3hCO0lBRUEsT0FBTztBQUNUO0FBRUF4RixvQkFBb0IsR0FBR1k7QUFFdkIsSUFBSVAsWUFBWSxTQUFTQTtJQUN2QixPQUFPLENBQUMsQ0FBRSxPQUFnRCxJQUFJd08sQ0FBNkI7QUFDN0Y7QUFFQTdPLGlCQUFpQixHQUFHSyIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaXZlcnNhbC1kZW1vLWFwcC8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGljay9saWIvdXRpbHMvaW5uZXJTbGlkZXJVdGlscy5qcz9hOTlhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jaGVja1NwZWNLZXlzID0gZXhwb3J0cy5jaGVja05hdmlnYWJsZSA9IGV4cG9ydHMuY2hhbmdlU2xpZGUgPSBleHBvcnRzLmNhblVzZURPTSA9IGV4cG9ydHMuY2FuR29OZXh0ID0gdm9pZCAwO1xuZXhwb3J0cy5jbGFtcCA9IGNsYW1wO1xuZXhwb3J0cy5zd2lwZVN0YXJ0ID0gZXhwb3J0cy5zd2lwZU1vdmUgPSBleHBvcnRzLnN3aXBlRW5kID0gZXhwb3J0cy5zbGlkZXNPblJpZ2h0ID0gZXhwb3J0cy5zbGlkZXNPbkxlZnQgPSBleHBvcnRzLnNsaWRlSGFuZGxlciA9IGV4cG9ydHMuc2libGluZ0RpcmVjdGlvbiA9IGV4cG9ydHMuc2FmZVByZXZlbnREZWZhdWx0ID0gZXhwb3J0cy5sYXp5U3RhcnRJbmRleCA9IGV4cG9ydHMubGF6eVNsaWRlc09uUmlnaHQgPSBleHBvcnRzLmxhenlTbGlkZXNPbkxlZnQgPSBleHBvcnRzLmxhenlFbmRJbmRleCA9IGV4cG9ydHMua2V5SGFuZGxlciA9IGV4cG9ydHMuaW5pdGlhbGl6ZWRTdGF0ZSA9IGV4cG9ydHMuZ2V0V2lkdGggPSBleHBvcnRzLmdldFRyYWNrTGVmdCA9IGV4cG9ydHMuZ2V0VHJhY2tDU1MgPSBleHBvcnRzLmdldFRyYWNrQW5pbWF0ZUNTUyA9IGV4cG9ydHMuZ2V0VG90YWxTbGlkZXMgPSBleHBvcnRzLmdldFN3aXBlRGlyZWN0aW9uID0gZXhwb3J0cy5nZXRTbGlkZUNvdW50ID0gZXhwb3J0cy5nZXRSZXF1aXJlZExhenlTbGlkZXMgPSBleHBvcnRzLmdldFByZUNsb25lcyA9IGV4cG9ydHMuZ2V0UG9zdENsb25lcyA9IGV4cG9ydHMuZ2V0T25EZW1hbmRMYXp5U2xpZGVzID0gZXhwb3J0cy5nZXROYXZpZ2FibGVJbmRleGVzID0gZXhwb3J0cy5nZXRIZWlnaHQgPSBleHBvcnRzLmV4dHJhY3RPYmplY3QgPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBjbGFtcChudW1iZXIsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGxvd2VyQm91bmQsIE1hdGgubWluKG51bWJlciwgdXBwZXJCb3VuZCkpO1xufVxuXG52YXIgc2FmZVByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gc2FmZVByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gIHZhciBwYXNzaXZlRXZlbnRzID0gW1wib25Ub3VjaFN0YXJ0XCIsIFwib25Ub3VjaE1vdmVcIiwgXCJvbldoZWVsXCJdO1xuXG4gIGlmICghcGFzc2l2ZUV2ZW50cy5pbmNsdWRlcyhldmVudC5fcmVhY3ROYW1lKSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2FmZVByZXZlbnREZWZhdWx0ID0gc2FmZVByZXZlbnREZWZhdWx0O1xuXG52YXIgZ2V0T25EZW1hbmRMYXp5U2xpZGVzID0gZnVuY3Rpb24gZ2V0T25EZW1hbmRMYXp5U2xpZGVzKHNwZWMpIHtcbiAgdmFyIG9uRGVtYW5kU2xpZGVzID0gW107XG4gIHZhciBzdGFydEluZGV4ID0gbGF6eVN0YXJ0SW5kZXgoc3BlYyk7XG4gIHZhciBlbmRJbmRleCA9IGxhenlFbmRJbmRleChzcGVjKTtcblxuICBmb3IgKHZhciBzbGlkZUluZGV4ID0gc3RhcnRJbmRleDsgc2xpZGVJbmRleCA8IGVuZEluZGV4OyBzbGlkZUluZGV4KyspIHtcbiAgICBpZiAoc3BlYy5sYXp5TG9hZGVkTGlzdC5pbmRleE9mKHNsaWRlSW5kZXgpIDwgMCkge1xuICAgICAgb25EZW1hbmRTbGlkZXMucHVzaChzbGlkZUluZGV4KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb25EZW1hbmRTbGlkZXM7XG59OyAvLyByZXR1cm4gbGlzdCBvZiBzbGlkZXMgdGhhdCBuZWVkIHRvIGJlIHByZXNlbnRcblxuXG5leHBvcnRzLmdldE9uRGVtYW5kTGF6eVNsaWRlcyA9IGdldE9uRGVtYW5kTGF6eVNsaWRlcztcblxudmFyIGdldFJlcXVpcmVkTGF6eVNsaWRlcyA9IGZ1bmN0aW9uIGdldFJlcXVpcmVkTGF6eVNsaWRlcyhzcGVjKSB7XG4gIHZhciByZXF1aXJlZFNsaWRlcyA9IFtdO1xuICB2YXIgc3RhcnRJbmRleCA9IGxhenlTdGFydEluZGV4KHNwZWMpO1xuICB2YXIgZW5kSW5kZXggPSBsYXp5RW5kSW5kZXgoc3BlYyk7XG5cbiAgZm9yICh2YXIgc2xpZGVJbmRleCA9IHN0YXJ0SW5kZXg7IHNsaWRlSW5kZXggPCBlbmRJbmRleDsgc2xpZGVJbmRleCsrKSB7XG4gICAgcmVxdWlyZWRTbGlkZXMucHVzaChzbGlkZUluZGV4KTtcbiAgfVxuXG4gIHJldHVybiByZXF1aXJlZFNsaWRlcztcbn07IC8vIHN0YXJ0SW5kZXggdGhhdCBuZWVkcyB0byBiZSBwcmVzZW50XG5cblxuZXhwb3J0cy5nZXRSZXF1aXJlZExhenlTbGlkZXMgPSBnZXRSZXF1aXJlZExhenlTbGlkZXM7XG5cbnZhciBsYXp5U3RhcnRJbmRleCA9IGZ1bmN0aW9uIGxhenlTdGFydEluZGV4KHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMuY3VycmVudFNsaWRlIC0gbGF6eVNsaWRlc09uTGVmdChzcGVjKTtcbn07XG5cbmV4cG9ydHMubGF6eVN0YXJ0SW5kZXggPSBsYXp5U3RhcnRJbmRleDtcblxudmFyIGxhenlFbmRJbmRleCA9IGZ1bmN0aW9uIGxhenlFbmRJbmRleChzcGVjKSB7XG4gIHJldHVybiBzcGVjLmN1cnJlbnRTbGlkZSArIGxhenlTbGlkZXNPblJpZ2h0KHNwZWMpO1xufTtcblxuZXhwb3J0cy5sYXp5RW5kSW5kZXggPSBsYXp5RW5kSW5kZXg7XG5cbnZhciBsYXp5U2xpZGVzT25MZWZ0ID0gZnVuY3Rpb24gbGF6eVNsaWRlc09uTGVmdChzcGVjKSB7XG4gIHJldHVybiBzcGVjLmNlbnRlck1vZGUgPyBNYXRoLmZsb29yKHNwZWMuc2xpZGVzVG9TaG93IC8gMikgKyAocGFyc2VJbnQoc3BlYy5jZW50ZXJQYWRkaW5nKSA+IDAgPyAxIDogMCkgOiAwO1xufTtcblxuZXhwb3J0cy5sYXp5U2xpZGVzT25MZWZ0ID0gbGF6eVNsaWRlc09uTGVmdDtcblxudmFyIGxhenlTbGlkZXNPblJpZ2h0ID0gZnVuY3Rpb24gbGF6eVNsaWRlc09uUmlnaHQoc3BlYykge1xuICByZXR1cm4gc3BlYy5jZW50ZXJNb2RlID8gTWF0aC5mbG9vcigoc3BlYy5zbGlkZXNUb1Nob3cgLSAxKSAvIDIpICsgMSArIChwYXJzZUludChzcGVjLmNlbnRlclBhZGRpbmcpID4gMCA/IDEgOiAwKSA6IHNwZWMuc2xpZGVzVG9TaG93O1xufTsgLy8gZ2V0IHdpZHRoIG9mIGFuIGVsZW1lbnRcblxuXG5leHBvcnRzLmxhenlTbGlkZXNPblJpZ2h0ID0gbGF6eVNsaWRlc09uUmlnaHQ7XG5cbnZhciBnZXRXaWR0aCA9IGZ1bmN0aW9uIGdldFdpZHRoKGVsZW0pIHtcbiAgcmV0dXJuIGVsZW0gJiYgZWxlbS5vZmZzZXRXaWR0aCB8fCAwO1xufTtcblxuZXhwb3J0cy5nZXRXaWR0aCA9IGdldFdpZHRoO1xuXG52YXIgZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gZ2V0SGVpZ2h0KGVsZW0pIHtcbiAgcmV0dXJuIGVsZW0gJiYgZWxlbS5vZmZzZXRIZWlnaHQgfHwgMDtcbn07XG5cbmV4cG9ydHMuZ2V0SGVpZ2h0ID0gZ2V0SGVpZ2h0O1xuXG52YXIgZ2V0U3dpcGVEaXJlY3Rpb24gPSBmdW5jdGlvbiBnZXRTd2lwZURpcmVjdGlvbih0b3VjaE9iamVjdCkge1xuICB2YXIgdmVydGljYWxTd2lwaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIHhEaXN0LCB5RGlzdCwgciwgc3dpcGVBbmdsZTtcbiAgeERpc3QgPSB0b3VjaE9iamVjdC5zdGFydFggLSB0b3VjaE9iamVjdC5jdXJYO1xuICB5RGlzdCA9IHRvdWNoT2JqZWN0LnN0YXJ0WSAtIHRvdWNoT2JqZWN0LmN1clk7XG4gIHIgPSBNYXRoLmF0YW4yKHlEaXN0LCB4RGlzdCk7XG4gIHN3aXBlQW5nbGUgPSBNYXRoLnJvdW5kKHIgKiAxODAgLyBNYXRoLlBJKTtcblxuICBpZiAoc3dpcGVBbmdsZSA8IDApIHtcbiAgICBzd2lwZUFuZ2xlID0gMzYwIC0gTWF0aC5hYnMoc3dpcGVBbmdsZSk7XG4gIH1cblxuICBpZiAoc3dpcGVBbmdsZSA8PSA0NSAmJiBzd2lwZUFuZ2xlID49IDAgfHwgc3dpcGVBbmdsZSA8PSAzNjAgJiYgc3dpcGVBbmdsZSA+PSAzMTUpIHtcbiAgICByZXR1cm4gXCJsZWZ0XCI7XG4gIH1cblxuICBpZiAoc3dpcGVBbmdsZSA+PSAxMzUgJiYgc3dpcGVBbmdsZSA8PSAyMjUpIHtcbiAgICByZXR1cm4gXCJyaWdodFwiO1xuICB9XG5cbiAgaWYgKHZlcnRpY2FsU3dpcGluZyA9PT0gdHJ1ZSkge1xuICAgIGlmIChzd2lwZUFuZ2xlID49IDM1ICYmIHN3aXBlQW5nbGUgPD0gMTM1KSB7XG4gICAgICByZXR1cm4gXCJ1cFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJkb3duXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwidmVydGljYWxcIjtcbn07IC8vIHdoZXRoZXIgb3Igbm90IHdlIGNhbiBnbyBuZXh0XG5cblxuZXhwb3J0cy5nZXRTd2lwZURpcmVjdGlvbiA9IGdldFN3aXBlRGlyZWN0aW9uO1xuXG52YXIgY2FuR29OZXh0ID0gZnVuY3Rpb24gY2FuR29OZXh0KHNwZWMpIHtcbiAgdmFyIGNhbkdvID0gdHJ1ZTtcblxuICBpZiAoIXNwZWMuaW5maW5pdGUpIHtcbiAgICBpZiAoc3BlYy5jZW50ZXJNb2RlICYmIHNwZWMuY3VycmVudFNsaWRlID49IHNwZWMuc2xpZGVDb3VudCAtIDEpIHtcbiAgICAgIGNhbkdvID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChzcGVjLnNsaWRlQ291bnQgPD0gc3BlYy5zbGlkZXNUb1Nob3cgfHwgc3BlYy5jdXJyZW50U2xpZGUgPj0gc3BlYy5zbGlkZUNvdW50IC0gc3BlYy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgIGNhbkdvID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNhbkdvO1xufTsgLy8gZ2l2ZW4gYW4gb2JqZWN0IGFuZCBhIGxpc3Qgb2Yga2V5cywgcmV0dXJuIG5ldyBvYmplY3Qgd2l0aCBnaXZlbiBrZXlzXG5cblxuZXhwb3J0cy5jYW5Hb05leHQgPSBjYW5Hb05leHQ7XG5cbnZhciBleHRyYWN0T2JqZWN0ID0gZnVuY3Rpb24gZXh0cmFjdE9iamVjdChzcGVjLCBrZXlzKSB7XG4gIHZhciBuZXdPYmplY3QgPSB7fTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbmV3T2JqZWN0W2tleV0gPSBzcGVjW2tleV07XG4gIH0pO1xuICByZXR1cm4gbmV3T2JqZWN0O1xufTsgLy8gZ2V0IGluaXRpYWxpemVkIHN0YXRlXG5cblxuZXhwb3J0cy5leHRyYWN0T2JqZWN0ID0gZXh0cmFjdE9iamVjdDtcblxudmFyIGluaXRpYWxpemVkU3RhdGUgPSBmdW5jdGlvbiBpbml0aWFsaXplZFN0YXRlKHNwZWMpIHtcbiAgLy8gc3BlYyBhbHNvIGNvbnRhaW5zIGxpc3RSZWYsIHRyYWNrUmVmXG4gIHZhciBzbGlkZUNvdW50ID0gX3JlYWN0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5jb3VudChzcGVjLmNoaWxkcmVuKTtcblxuICB2YXIgbGlzdE5vZGUgPSBzcGVjLmxpc3RSZWY7XG4gIHZhciBsaXN0V2lkdGggPSBNYXRoLmNlaWwoZ2V0V2lkdGgobGlzdE5vZGUpKTtcbiAgdmFyIHRyYWNrTm9kZSA9IHNwZWMudHJhY2tSZWYgJiYgc3BlYy50cmFja1JlZi5ub2RlO1xuICB2YXIgdHJhY2tXaWR0aCA9IE1hdGguY2VpbChnZXRXaWR0aCh0cmFja05vZGUpKTtcbiAgdmFyIHNsaWRlV2lkdGg7XG5cbiAgaWYgKCFzcGVjLnZlcnRpY2FsKSB7XG4gICAgdmFyIGNlbnRlclBhZGRpbmdBZGogPSBzcGVjLmNlbnRlck1vZGUgJiYgcGFyc2VJbnQoc3BlYy5jZW50ZXJQYWRkaW5nKSAqIDI7XG5cbiAgICBpZiAodHlwZW9mIHNwZWMuY2VudGVyUGFkZGluZyA9PT0gXCJzdHJpbmdcIiAmJiBzcGVjLmNlbnRlclBhZGRpbmcuc2xpY2UoLTEpID09PSBcIiVcIikge1xuICAgICAgY2VudGVyUGFkZGluZ0FkaiAqPSBsaXN0V2lkdGggLyAxMDA7XG4gICAgfVxuXG4gICAgc2xpZGVXaWR0aCA9IE1hdGguY2VpbCgobGlzdFdpZHRoIC0gY2VudGVyUGFkZGluZ0FkaikgLyBzcGVjLnNsaWRlc1RvU2hvdyk7XG4gIH0gZWxzZSB7XG4gICAgc2xpZGVXaWR0aCA9IGxpc3RXaWR0aDtcbiAgfVxuXG4gIHZhciBzbGlkZUhlaWdodCA9IGxpc3ROb2RlICYmIGdldEhlaWdodChsaXN0Tm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pbmRleD1cIjBcIl0nKSk7XG4gIHZhciBsaXN0SGVpZ2h0ID0gc2xpZGVIZWlnaHQgKiBzcGVjLnNsaWRlc1RvU2hvdztcbiAgdmFyIGN1cnJlbnRTbGlkZSA9IHNwZWMuY3VycmVudFNsaWRlID09PSB1bmRlZmluZWQgPyBzcGVjLmluaXRpYWxTbGlkZSA6IHNwZWMuY3VycmVudFNsaWRlO1xuXG4gIGlmIChzcGVjLnJ0bCAmJiBzcGVjLmN1cnJlbnRTbGlkZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY3VycmVudFNsaWRlID0gc2xpZGVDb3VudCAtIDEgLSBzcGVjLmluaXRpYWxTbGlkZTtcbiAgfVxuXG4gIHZhciBsYXp5TG9hZGVkTGlzdCA9IHNwZWMubGF6eUxvYWRlZExpc3QgfHwgW107XG4gIHZhciBzbGlkZXNUb0xvYWQgPSBnZXRPbkRlbWFuZExhenlTbGlkZXMoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICBjdXJyZW50U2xpZGU6IGN1cnJlbnRTbGlkZSxcbiAgICBsYXp5TG9hZGVkTGlzdDogbGF6eUxvYWRlZExpc3RcbiAgfSkpO1xuICBsYXp5TG9hZGVkTGlzdCA9IGxhenlMb2FkZWRMaXN0LmNvbmNhdChzbGlkZXNUb0xvYWQpO1xuICB2YXIgc3RhdGUgPSB7XG4gICAgc2xpZGVDb3VudDogc2xpZGVDb3VudCxcbiAgICBzbGlkZVdpZHRoOiBzbGlkZVdpZHRoLFxuICAgIGxpc3RXaWR0aDogbGlzdFdpZHRoLFxuICAgIHRyYWNrV2lkdGg6IHRyYWNrV2lkdGgsXG4gICAgY3VycmVudFNsaWRlOiBjdXJyZW50U2xpZGUsXG4gICAgc2xpZGVIZWlnaHQ6IHNsaWRlSGVpZ2h0LFxuICAgIGxpc3RIZWlnaHQ6IGxpc3RIZWlnaHQsXG4gICAgbGF6eUxvYWRlZExpc3Q6IGxhenlMb2FkZWRMaXN0XG4gIH07XG5cbiAgaWYgKHNwZWMuYXV0b3BsYXlpbmcgPT09IG51bGwgJiYgc3BlYy5hdXRvcGxheSkge1xuICAgIHN0YXRlW1wiYXV0b3BsYXlpbmdcIl0gPSBcInBsYXlpbmdcIjtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn07XG5cbmV4cG9ydHMuaW5pdGlhbGl6ZWRTdGF0ZSA9IGluaXRpYWxpemVkU3RhdGU7XG5cbnZhciBzbGlkZUhhbmRsZXIgPSBmdW5jdGlvbiBzbGlkZUhhbmRsZXIoc3BlYykge1xuICB2YXIgd2FpdEZvckFuaW1hdGUgPSBzcGVjLndhaXRGb3JBbmltYXRlLFxuICAgICAgYW5pbWF0aW5nID0gc3BlYy5hbmltYXRpbmcsXG4gICAgICBmYWRlID0gc3BlYy5mYWRlLFxuICAgICAgaW5maW5pdGUgPSBzcGVjLmluZmluaXRlLFxuICAgICAgaW5kZXggPSBzcGVjLmluZGV4LFxuICAgICAgc2xpZGVDb3VudCA9IHNwZWMuc2xpZGVDb3VudCxcbiAgICAgIGxhenlMb2FkID0gc3BlYy5sYXp5TG9hZCxcbiAgICAgIGN1cnJlbnRTbGlkZSA9IHNwZWMuY3VycmVudFNsaWRlLFxuICAgICAgY2VudGVyTW9kZSA9IHNwZWMuY2VudGVyTW9kZSxcbiAgICAgIHNsaWRlc1RvU2Nyb2xsID0gc3BlYy5zbGlkZXNUb1Njcm9sbCxcbiAgICAgIHNsaWRlc1RvU2hvdyA9IHNwZWMuc2xpZGVzVG9TaG93LFxuICAgICAgdXNlQ1NTID0gc3BlYy51c2VDU1M7XG4gIHZhciBsYXp5TG9hZGVkTGlzdCA9IHNwZWMubGF6eUxvYWRlZExpc3Q7XG4gIGlmICh3YWl0Rm9yQW5pbWF0ZSAmJiBhbmltYXRpbmcpIHJldHVybiB7fTtcbiAgdmFyIGFuaW1hdGlvblNsaWRlID0gaW5kZXgsXG4gICAgICBmaW5hbFNsaWRlLFxuICAgICAgYW5pbWF0aW9uTGVmdCxcbiAgICAgIGZpbmFsTGVmdDtcbiAgdmFyIHN0YXRlID0ge30sXG4gICAgICBuZXh0U3RhdGUgPSB7fTtcbiAgdmFyIHRhcmdldFNsaWRlID0gaW5maW5pdGUgPyBpbmRleCA6IGNsYW1wKGluZGV4LCAwLCBzbGlkZUNvdW50IC0gMSk7XG5cbiAgaWYgKGZhZGUpIHtcbiAgICBpZiAoIWluZmluaXRlICYmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2xpZGVDb3VudCkpIHJldHVybiB7fTtcblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGFuaW1hdGlvblNsaWRlID0gaW5kZXggKyBzbGlkZUNvdW50O1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPj0gc2xpZGVDb3VudCkge1xuICAgICAgYW5pbWF0aW9uU2xpZGUgPSBpbmRleCAtIHNsaWRlQ291bnQ7XG4gICAgfVxuXG4gICAgaWYgKGxhenlMb2FkICYmIGxhenlMb2FkZWRMaXN0LmluZGV4T2YoYW5pbWF0aW9uU2xpZGUpIDwgMCkge1xuICAgICAgbGF6eUxvYWRlZExpc3QgPSBsYXp5TG9hZGVkTGlzdC5jb25jYXQoYW5pbWF0aW9uU2xpZGUpO1xuICAgIH1cblxuICAgIHN0YXRlID0ge1xuICAgICAgYW5pbWF0aW5nOiB0cnVlLFxuICAgICAgY3VycmVudFNsaWRlOiBhbmltYXRpb25TbGlkZSxcbiAgICAgIGxhenlMb2FkZWRMaXN0OiBsYXp5TG9hZGVkTGlzdCxcbiAgICAgIHRhcmdldFNsaWRlOiBhbmltYXRpb25TbGlkZVxuICAgIH07XG4gICAgbmV4dFN0YXRlID0ge1xuICAgICAgYW5pbWF0aW5nOiBmYWxzZSxcbiAgICAgIHRhcmdldFNsaWRlOiBhbmltYXRpb25TbGlkZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZmluYWxTbGlkZSA9IGFuaW1hdGlvblNsaWRlO1xuXG4gICAgaWYgKGFuaW1hdGlvblNsaWRlIDwgMCkge1xuICAgICAgZmluYWxTbGlkZSA9IGFuaW1hdGlvblNsaWRlICsgc2xpZGVDb3VudDtcbiAgICAgIGlmICghaW5maW5pdGUpIGZpbmFsU2xpZGUgPSAwO2Vsc2UgaWYgKHNsaWRlQ291bnQgJSBzbGlkZXNUb1Njcm9sbCAhPT0gMCkgZmluYWxTbGlkZSA9IHNsaWRlQ291bnQgLSBzbGlkZUNvdW50ICUgc2xpZGVzVG9TY3JvbGw7XG4gICAgfSBlbHNlIGlmICghY2FuR29OZXh0KHNwZWMpICYmIGFuaW1hdGlvblNsaWRlID4gY3VycmVudFNsaWRlKSB7XG4gICAgICBhbmltYXRpb25TbGlkZSA9IGZpbmFsU2xpZGUgPSBjdXJyZW50U2xpZGU7XG4gICAgfSBlbHNlIGlmIChjZW50ZXJNb2RlICYmIGFuaW1hdGlvblNsaWRlID49IHNsaWRlQ291bnQpIHtcbiAgICAgIGFuaW1hdGlvblNsaWRlID0gaW5maW5pdGUgPyBzbGlkZUNvdW50IDogc2xpZGVDb3VudCAtIDE7XG4gICAgICBmaW5hbFNsaWRlID0gaW5maW5pdGUgPyAwIDogc2xpZGVDb3VudCAtIDE7XG4gICAgfSBlbHNlIGlmIChhbmltYXRpb25TbGlkZSA+PSBzbGlkZUNvdW50KSB7XG4gICAgICBmaW5hbFNsaWRlID0gYW5pbWF0aW9uU2xpZGUgLSBzbGlkZUNvdW50O1xuICAgICAgaWYgKCFpbmZpbml0ZSkgZmluYWxTbGlkZSA9IHNsaWRlQ291bnQgLSBzbGlkZXNUb1Nob3c7ZWxzZSBpZiAoc2xpZGVDb3VudCAlIHNsaWRlc1RvU2Nyb2xsICE9PSAwKSBmaW5hbFNsaWRlID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIWluZmluaXRlICYmIGFuaW1hdGlvblNsaWRlICsgc2xpZGVzVG9TaG93ID49IHNsaWRlQ291bnQpIHtcbiAgICAgIGZpbmFsU2xpZGUgPSBzbGlkZUNvdW50IC0gc2xpZGVzVG9TaG93O1xuICAgIH1cblxuICAgIGFuaW1hdGlvbkxlZnQgPSBnZXRUcmFja0xlZnQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgIHNsaWRlSW5kZXg6IGFuaW1hdGlvblNsaWRlXG4gICAgfSkpO1xuICAgIGZpbmFsTGVmdCA9IGdldFRyYWNrTGVmdChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgc2xpZGVJbmRleDogZmluYWxTbGlkZVxuICAgIH0pKTtcblxuICAgIGlmICghaW5maW5pdGUpIHtcbiAgICAgIGlmIChhbmltYXRpb25MZWZ0ID09PSBmaW5hbExlZnQpIGFuaW1hdGlvblNsaWRlID0gZmluYWxTbGlkZTtcbiAgICAgIGFuaW1hdGlvbkxlZnQgPSBmaW5hbExlZnQ7XG4gICAgfVxuXG4gICAgaWYgKGxhenlMb2FkKSB7XG4gICAgICBsYXp5TG9hZGVkTGlzdCA9IGxhenlMb2FkZWRMaXN0LmNvbmNhdChnZXRPbkRlbWFuZExhenlTbGlkZXMoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgICAgY3VycmVudFNsaWRlOiBhbmltYXRpb25TbGlkZVxuICAgICAgfSkpKTtcbiAgICB9XG5cbiAgICBpZiAoIXVzZUNTUykge1xuICAgICAgc3RhdGUgPSB7XG4gICAgICAgIGN1cnJlbnRTbGlkZTogZmluYWxTbGlkZSxcbiAgICAgICAgdHJhY2tTdHlsZTogZ2V0VHJhY2tDU1MoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgICAgICBsZWZ0OiBmaW5hbExlZnRcbiAgICAgICAgfSkpLFxuICAgICAgICBsYXp5TG9hZGVkTGlzdDogbGF6eUxvYWRlZExpc3QsXG4gICAgICAgIHRhcmdldFNsaWRlOiB0YXJnZXRTbGlkZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUgPSB7XG4gICAgICAgIGFuaW1hdGluZzogdHJ1ZSxcbiAgICAgICAgY3VycmVudFNsaWRlOiBmaW5hbFNsaWRlLFxuICAgICAgICB0cmFja1N0eWxlOiBnZXRUcmFja0FuaW1hdGVDU1MoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgICAgICBsZWZ0OiBhbmltYXRpb25MZWZ0XG4gICAgICAgIH0pKSxcbiAgICAgICAgbGF6eUxvYWRlZExpc3Q6IGxhenlMb2FkZWRMaXN0LFxuICAgICAgICB0YXJnZXRTbGlkZTogdGFyZ2V0U2xpZGVcbiAgICAgIH07XG4gICAgICBuZXh0U3RhdGUgPSB7XG4gICAgICAgIGFuaW1hdGluZzogZmFsc2UsXG4gICAgICAgIGN1cnJlbnRTbGlkZTogZmluYWxTbGlkZSxcbiAgICAgICAgdHJhY2tTdHlsZTogZ2V0VHJhY2tDU1MoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgICAgICBsZWZ0OiBmaW5hbExlZnRcbiAgICAgICAgfSkpLFxuICAgICAgICBzd2lwZUxlZnQ6IG51bGwsXG4gICAgICAgIHRhcmdldFNsaWRlOiB0YXJnZXRTbGlkZVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXRlOiBzdGF0ZSxcbiAgICBuZXh0U3RhdGU6IG5leHRTdGF0ZVxuICB9O1xufTtcblxuZXhwb3J0cy5zbGlkZUhhbmRsZXIgPSBzbGlkZUhhbmRsZXI7XG5cbnZhciBjaGFuZ2VTbGlkZSA9IGZ1bmN0aW9uIGNoYW5nZVNsaWRlKHNwZWMsIG9wdGlvbnMpIHtcbiAgdmFyIGluZGV4T2Zmc2V0LCBwcmV2aW91c0ludCwgc2xpZGVPZmZzZXQsIHVuZXZlbk9mZnNldCwgdGFyZ2V0U2xpZGU7XG4gIHZhciBzbGlkZXNUb1Njcm9sbCA9IHNwZWMuc2xpZGVzVG9TY3JvbGwsXG4gICAgICBzbGlkZXNUb1Nob3cgPSBzcGVjLnNsaWRlc1RvU2hvdyxcbiAgICAgIHNsaWRlQ291bnQgPSBzcGVjLnNsaWRlQ291bnQsXG4gICAgICBjdXJyZW50U2xpZGUgPSBzcGVjLmN1cnJlbnRTbGlkZSxcbiAgICAgIHByZXZpb3VzVGFyZ2V0U2xpZGUgPSBzcGVjLnRhcmdldFNsaWRlLFxuICAgICAgbGF6eUxvYWQgPSBzcGVjLmxhenlMb2FkLFxuICAgICAgaW5maW5pdGUgPSBzcGVjLmluZmluaXRlO1xuICB1bmV2ZW5PZmZzZXQgPSBzbGlkZUNvdW50ICUgc2xpZGVzVG9TY3JvbGwgIT09IDA7XG4gIGluZGV4T2Zmc2V0ID0gdW5ldmVuT2Zmc2V0ID8gMCA6IChzbGlkZUNvdW50IC0gY3VycmVudFNsaWRlKSAlIHNsaWRlc1RvU2Nyb2xsO1xuXG4gIGlmIChvcHRpb25zLm1lc3NhZ2UgPT09IFwicHJldmlvdXNcIikge1xuICAgIHNsaWRlT2Zmc2V0ID0gaW5kZXhPZmZzZXQgPT09IDAgPyBzbGlkZXNUb1Njcm9sbCA6IHNsaWRlc1RvU2hvdyAtIGluZGV4T2Zmc2V0O1xuICAgIHRhcmdldFNsaWRlID0gY3VycmVudFNsaWRlIC0gc2xpZGVPZmZzZXQ7XG5cbiAgICBpZiAobGF6eUxvYWQgJiYgIWluZmluaXRlKSB7XG4gICAgICBwcmV2aW91c0ludCA9IGN1cnJlbnRTbGlkZSAtIHNsaWRlT2Zmc2V0O1xuICAgICAgdGFyZ2V0U2xpZGUgPSBwcmV2aW91c0ludCA9PT0gLTEgPyBzbGlkZUNvdW50IC0gMSA6IHByZXZpb3VzSW50O1xuICAgIH1cblxuICAgIGlmICghaW5maW5pdGUpIHtcbiAgICAgIHRhcmdldFNsaWRlID0gcHJldmlvdXNUYXJnZXRTbGlkZSAtIHNsaWRlc1RvU2Nyb2xsO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcHRpb25zLm1lc3NhZ2UgPT09IFwibmV4dFwiKSB7XG4gICAgc2xpZGVPZmZzZXQgPSBpbmRleE9mZnNldCA9PT0gMCA/IHNsaWRlc1RvU2Nyb2xsIDogaW5kZXhPZmZzZXQ7XG4gICAgdGFyZ2V0U2xpZGUgPSBjdXJyZW50U2xpZGUgKyBzbGlkZU9mZnNldDtcblxuICAgIGlmIChsYXp5TG9hZCAmJiAhaW5maW5pdGUpIHtcbiAgICAgIHRhcmdldFNsaWRlID0gKGN1cnJlbnRTbGlkZSArIHNsaWRlc1RvU2Nyb2xsKSAlIHNsaWRlQ291bnQgKyBpbmRleE9mZnNldDtcbiAgICB9XG5cbiAgICBpZiAoIWluZmluaXRlKSB7XG4gICAgICB0YXJnZXRTbGlkZSA9IHByZXZpb3VzVGFyZ2V0U2xpZGUgKyBzbGlkZXNUb1Njcm9sbDtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5tZXNzYWdlID09PSBcImRvdHNcIikge1xuICAgIC8vIENsaWNrIG9uIGRvdHNcbiAgICB0YXJnZXRTbGlkZSA9IG9wdGlvbnMuaW5kZXggKiBvcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMubWVzc2FnZSA9PT0gXCJjaGlsZHJlblwiKSB7XG4gICAgLy8gQ2xpY2sgb24gdGhlIHNsaWRlc1xuICAgIHRhcmdldFNsaWRlID0gb3B0aW9ucy5pbmRleDtcblxuICAgIGlmIChpbmZpbml0ZSkge1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IHNpYmxpbmdEaXJlY3Rpb24oX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzcGVjKSwge30sIHtcbiAgICAgICAgdGFyZ2V0U2xpZGU6IHRhcmdldFNsaWRlXG4gICAgICB9KSk7XG5cbiAgICAgIGlmICh0YXJnZXRTbGlkZSA+IG9wdGlvbnMuY3VycmVudFNsaWRlICYmIGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgdGFyZ2V0U2xpZGUgPSB0YXJnZXRTbGlkZSAtIHNsaWRlQ291bnQ7XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldFNsaWRlIDwgb3B0aW9ucy5jdXJyZW50U2xpZGUgJiYgZGlyZWN0aW9uID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgdGFyZ2V0U2xpZGUgPSB0YXJnZXRTbGlkZSArIHNsaWRlQ291bnQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdGlvbnMubWVzc2FnZSA9PT0gXCJpbmRleFwiKSB7XG4gICAgdGFyZ2V0U2xpZGUgPSBOdW1iZXIob3B0aW9ucy5pbmRleCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0U2xpZGU7XG59O1xuXG5leHBvcnRzLmNoYW5nZVNsaWRlID0gY2hhbmdlU2xpZGU7XG5cbnZhciBrZXlIYW5kbGVyID0gZnVuY3Rpb24ga2V5SGFuZGxlcihlLCBhY2Nlc3NpYmlsaXR5LCBydGwpIHtcbiAgaWYgKGUudGFyZ2V0LnRhZ05hbWUubWF0Y2goXCJURVhUQVJFQXxJTlBVVHxTRUxFQ1RcIikgfHwgIWFjY2Vzc2liaWxpdHkpIHJldHVybiBcIlwiO1xuICBpZiAoZS5rZXlDb2RlID09PSAzNykgcmV0dXJuIHJ0bCA/IFwibmV4dFwiIDogXCJwcmV2aW91c1wiO1xuICBpZiAoZS5rZXlDb2RlID09PSAzOSkgcmV0dXJuIHJ0bCA/IFwicHJldmlvdXNcIiA6IFwibmV4dFwiO1xuICByZXR1cm4gXCJcIjtcbn07XG5cbmV4cG9ydHMua2V5SGFuZGxlciA9IGtleUhhbmRsZXI7XG5cbnZhciBzd2lwZVN0YXJ0ID0gZnVuY3Rpb24gc3dpcGVTdGFydChlLCBzd2lwZSwgZHJhZ2dhYmxlKSB7XG4gIGUudGFyZ2V0LnRhZ05hbWUgPT09IFwiSU1HXCIgJiYgc2FmZVByZXZlbnREZWZhdWx0KGUpO1xuICBpZiAoIXN3aXBlIHx8ICFkcmFnZ2FibGUgJiYgZS50eXBlLmluZGV4T2YoXCJtb3VzZVwiKSAhPT0gLTEpIHJldHVybiBcIlwiO1xuICByZXR1cm4ge1xuICAgIGRyYWdnaW5nOiB0cnVlLFxuICAgIHRvdWNoT2JqZWN0OiB7XG4gICAgICBzdGFydFg6IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXS5wYWdlWCA6IGUuY2xpZW50WCxcbiAgICAgIHN0YXJ0WTogZS50b3VjaGVzID8gZS50b3VjaGVzWzBdLnBhZ2VZIDogZS5jbGllbnRZLFxuICAgICAgY3VyWDogZS50b3VjaGVzID8gZS50b3VjaGVzWzBdLnBhZ2VYIDogZS5jbGllbnRYLFxuICAgICAgY3VyWTogZS50b3VjaGVzID8gZS50b3VjaGVzWzBdLnBhZ2VZIDogZS5jbGllbnRZXG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0cy5zd2lwZVN0YXJ0ID0gc3dpcGVTdGFydDtcblxudmFyIHN3aXBlTW92ZSA9IGZ1bmN0aW9uIHN3aXBlTW92ZShlLCBzcGVjKSB7XG4gIC8vIHNwZWMgYWxzbyBjb250YWlucywgdHJhY2tSZWYgYW5kIHNsaWRlSW5kZXhcbiAgdmFyIHNjcm9sbGluZyA9IHNwZWMuc2Nyb2xsaW5nLFxuICAgICAgYW5pbWF0aW5nID0gc3BlYy5hbmltYXRpbmcsXG4gICAgICB2ZXJ0aWNhbCA9IHNwZWMudmVydGljYWwsXG4gICAgICBzd2lwZVRvU2xpZGUgPSBzcGVjLnN3aXBlVG9TbGlkZSxcbiAgICAgIHZlcnRpY2FsU3dpcGluZyA9IHNwZWMudmVydGljYWxTd2lwaW5nLFxuICAgICAgcnRsID0gc3BlYy5ydGwsXG4gICAgICBjdXJyZW50U2xpZGUgPSBzcGVjLmN1cnJlbnRTbGlkZSxcbiAgICAgIGVkZ2VGcmljdGlvbiA9IHNwZWMuZWRnZUZyaWN0aW9uLFxuICAgICAgZWRnZURyYWdnZWQgPSBzcGVjLmVkZ2VEcmFnZ2VkLFxuICAgICAgb25FZGdlID0gc3BlYy5vbkVkZ2UsXG4gICAgICBzd2lwZWQgPSBzcGVjLnN3aXBlZCxcbiAgICAgIHN3aXBpbmcgPSBzcGVjLnN3aXBpbmcsXG4gICAgICBzbGlkZUNvdW50ID0gc3BlYy5zbGlkZUNvdW50LFxuICAgICAgc2xpZGVzVG9TY3JvbGwgPSBzcGVjLnNsaWRlc1RvU2Nyb2xsLFxuICAgICAgaW5maW5pdGUgPSBzcGVjLmluZmluaXRlLFxuICAgICAgdG91Y2hPYmplY3QgPSBzcGVjLnRvdWNoT2JqZWN0LFxuICAgICAgc3dpcGVFdmVudCA9IHNwZWMuc3dpcGVFdmVudCxcbiAgICAgIGxpc3RIZWlnaHQgPSBzcGVjLmxpc3RIZWlnaHQsXG4gICAgICBsaXN0V2lkdGggPSBzcGVjLmxpc3RXaWR0aDtcbiAgaWYgKHNjcm9sbGluZykgcmV0dXJuO1xuICBpZiAoYW5pbWF0aW5nKSByZXR1cm4gc2FmZVByZXZlbnREZWZhdWx0KGUpO1xuICBpZiAodmVydGljYWwgJiYgc3dpcGVUb1NsaWRlICYmIHZlcnRpY2FsU3dpcGluZykgc2FmZVByZXZlbnREZWZhdWx0KGUpO1xuICB2YXIgc3dpcGVMZWZ0LFxuICAgICAgc3RhdGUgPSB7fTtcbiAgdmFyIGN1ckxlZnQgPSBnZXRUcmFja0xlZnQoc3BlYyk7XG4gIHRvdWNoT2JqZWN0LmN1clggPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0ucGFnZVggOiBlLmNsaWVudFg7XG4gIHRvdWNoT2JqZWN0LmN1clkgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0ucGFnZVkgOiBlLmNsaWVudFk7XG4gIHRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoID0gTWF0aC5yb3VuZChNYXRoLnNxcnQoTWF0aC5wb3codG91Y2hPYmplY3QuY3VyWCAtIHRvdWNoT2JqZWN0LnN0YXJ0WCwgMikpKTtcbiAgdmFyIHZlcnRpY2FsU3dpcGVMZW5ndGggPSBNYXRoLnJvdW5kKE1hdGguc3FydChNYXRoLnBvdyh0b3VjaE9iamVjdC5jdXJZIC0gdG91Y2hPYmplY3Quc3RhcnRZLCAyKSkpO1xuXG4gIGlmICghdmVydGljYWxTd2lwaW5nICYmICFzd2lwaW5nICYmIHZlcnRpY2FsU3dpcGVMZW5ndGggPiAxMCkge1xuICAgIHJldHVybiB7XG4gICAgICBzY3JvbGxpbmc6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgaWYgKHZlcnRpY2FsU3dpcGluZykgdG91Y2hPYmplY3Quc3dpcGVMZW5ndGggPSB2ZXJ0aWNhbFN3aXBlTGVuZ3RoO1xuICB2YXIgcG9zaXRpb25PZmZzZXQgPSAoIXJ0bCA/IDEgOiAtMSkgKiAodG91Y2hPYmplY3QuY3VyWCA+IHRvdWNoT2JqZWN0LnN0YXJ0WCA/IDEgOiAtMSk7XG4gIGlmICh2ZXJ0aWNhbFN3aXBpbmcpIHBvc2l0aW9uT2Zmc2V0ID0gdG91Y2hPYmplY3QuY3VyWSA+IHRvdWNoT2JqZWN0LnN0YXJ0WSA/IDEgOiAtMTtcbiAgdmFyIGRvdENvdW50ID0gTWF0aC5jZWlsKHNsaWRlQ291bnQgLyBzbGlkZXNUb1Njcm9sbCk7XG4gIHZhciBzd2lwZURpcmVjdGlvbiA9IGdldFN3aXBlRGlyZWN0aW9uKHNwZWMudG91Y2hPYmplY3QsIHZlcnRpY2FsU3dpcGluZyk7XG4gIHZhciB0b3VjaFN3aXBlTGVuZ3RoID0gdG91Y2hPYmplY3Quc3dpcGVMZW5ndGg7XG5cbiAgaWYgKCFpbmZpbml0ZSkge1xuICAgIGlmIChjdXJyZW50U2xpZGUgPT09IDAgJiYgKHN3aXBlRGlyZWN0aW9uID09PSBcInJpZ2h0XCIgfHwgc3dpcGVEaXJlY3Rpb24gPT09IFwiZG93blwiKSB8fCBjdXJyZW50U2xpZGUgKyAxID49IGRvdENvdW50ICYmIChzd2lwZURpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgfHwgc3dpcGVEaXJlY3Rpb24gPT09IFwidXBcIikgfHwgIWNhbkdvTmV4dChzcGVjKSAmJiAoc3dpcGVEaXJlY3Rpb24gPT09IFwibGVmdFwiIHx8IHN3aXBlRGlyZWN0aW9uID09PSBcInVwXCIpKSB7XG4gICAgICB0b3VjaFN3aXBlTGVuZ3RoID0gdG91Y2hPYmplY3Quc3dpcGVMZW5ndGggKiBlZGdlRnJpY3Rpb247XG5cbiAgICAgIGlmIChlZGdlRHJhZ2dlZCA9PT0gZmFsc2UgJiYgb25FZGdlKSB7XG4gICAgICAgIG9uRWRnZShzd2lwZURpcmVjdGlvbik7XG4gICAgICAgIHN0YXRlW1wiZWRnZURyYWdnZWRcIl0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghc3dpcGVkICYmIHN3aXBlRXZlbnQpIHtcbiAgICBzd2lwZUV2ZW50KHN3aXBlRGlyZWN0aW9uKTtcbiAgICBzdGF0ZVtcInN3aXBlZFwiXSA9IHRydWU7XG4gIH1cblxuICBpZiAoIXZlcnRpY2FsKSB7XG4gICAgaWYgKCFydGwpIHtcbiAgICAgIHN3aXBlTGVmdCA9IGN1ckxlZnQgKyB0b3VjaFN3aXBlTGVuZ3RoICogcG9zaXRpb25PZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlTGVmdCA9IGN1ckxlZnQgLSB0b3VjaFN3aXBlTGVuZ3RoICogcG9zaXRpb25PZmZzZXQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN3aXBlTGVmdCA9IGN1ckxlZnQgKyB0b3VjaFN3aXBlTGVuZ3RoICogKGxpc3RIZWlnaHQgLyBsaXN0V2lkdGgpICogcG9zaXRpb25PZmZzZXQ7XG4gIH1cblxuICBpZiAodmVydGljYWxTd2lwaW5nKSB7XG4gICAgc3dpcGVMZWZ0ID0gY3VyTGVmdCArIHRvdWNoU3dpcGVMZW5ndGggKiBwb3NpdGlvbk9mZnNldDtcbiAgfVxuXG4gIHN0YXRlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdGF0ZSksIHt9LCB7XG4gICAgdG91Y2hPYmplY3Q6IHRvdWNoT2JqZWN0LFxuICAgIHN3aXBlTGVmdDogc3dpcGVMZWZ0LFxuICAgIHRyYWNrU3R5bGU6IGdldFRyYWNrQ1NTKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3BlYyksIHt9LCB7XG4gICAgICBsZWZ0OiBzd2lwZUxlZnRcbiAgICB9KSlcbiAgfSk7XG5cbiAgaWYgKE1hdGguYWJzKHRvdWNoT2JqZWN0LmN1clggLSB0b3VjaE9iamVjdC5zdGFydFgpIDwgTWF0aC5hYnModG91Y2hPYmplY3QuY3VyWSAtIHRvdWNoT2JqZWN0LnN0YXJ0WSkgKiAwLjgpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBpZiAodG91Y2hPYmplY3Quc3dpcGVMZW5ndGggPiAxMCkge1xuICAgIHN0YXRlW1wic3dpcGluZ1wiXSA9IHRydWU7XG4gICAgc2FmZVByZXZlbnREZWZhdWx0KGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufTtcblxuZXhwb3J0cy5zd2lwZU1vdmUgPSBzd2lwZU1vdmU7XG5cbnZhciBzd2lwZUVuZCA9IGZ1bmN0aW9uIHN3aXBlRW5kKGUsIHNwZWMpIHtcbiAgdmFyIGRyYWdnaW5nID0gc3BlYy5kcmFnZ2luZyxcbiAgICAgIHN3aXBlID0gc3BlYy5zd2lwZSxcbiAgICAgIHRvdWNoT2JqZWN0ID0gc3BlYy50b3VjaE9iamVjdCxcbiAgICAgIGxpc3RXaWR0aCA9IHNwZWMubGlzdFdpZHRoLFxuICAgICAgdG91Y2hUaHJlc2hvbGQgPSBzcGVjLnRvdWNoVGhyZXNob2xkLFxuICAgICAgdmVydGljYWxTd2lwaW5nID0gc3BlYy52ZXJ0aWNhbFN3aXBpbmcsXG4gICAgICBsaXN0SGVpZ2h0ID0gc3BlYy5saXN0SGVpZ2h0LFxuICAgICAgc3dpcGVUb1NsaWRlID0gc3BlYy5zd2lwZVRvU2xpZGUsXG4gICAgICBzY3JvbGxpbmcgPSBzcGVjLnNjcm9sbGluZyxcbiAgICAgIG9uU3dpcGUgPSBzcGVjLm9uU3dpcGUsXG4gICAgICB0YXJnZXRTbGlkZSA9IHNwZWMudGFyZ2V0U2xpZGUsXG4gICAgICBjdXJyZW50U2xpZGUgPSBzcGVjLmN1cnJlbnRTbGlkZSxcbiAgICAgIGluZmluaXRlID0gc3BlYy5pbmZpbml0ZTtcblxuICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgaWYgKHN3aXBlKSBzYWZlUHJldmVudERlZmF1bHQoZSk7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgdmFyIG1pblN3aXBlID0gdmVydGljYWxTd2lwaW5nID8gbGlzdEhlaWdodCAvIHRvdWNoVGhyZXNob2xkIDogbGlzdFdpZHRoIC8gdG91Y2hUaHJlc2hvbGQ7XG4gIHZhciBzd2lwZURpcmVjdGlvbiA9IGdldFN3aXBlRGlyZWN0aW9uKHRvdWNoT2JqZWN0LCB2ZXJ0aWNhbFN3aXBpbmcpOyAvLyByZXNldCB0aGUgc3RhdGUgb2YgdG91Y2ggcmVsYXRlZCBzdGF0ZSB2YXJpYWJsZXMuXG5cbiAgdmFyIHN0YXRlID0ge1xuICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICBlZGdlRHJhZ2dlZDogZmFsc2UsXG4gICAgc2Nyb2xsaW5nOiBmYWxzZSxcbiAgICBzd2lwaW5nOiBmYWxzZSxcbiAgICBzd2lwZWQ6IGZhbHNlLFxuICAgIHN3aXBlTGVmdDogbnVsbCxcbiAgICB0b3VjaE9iamVjdDoge31cbiAgfTtcblxuICBpZiAoc2Nyb2xsaW5nKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgaWYgKCF0b3VjaE9iamVjdC5zd2lwZUxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGlmICh0b3VjaE9iamVjdC5zd2lwZUxlbmd0aCA+IG1pblN3aXBlKSB7XG4gICAgc2FmZVByZXZlbnREZWZhdWx0KGUpO1xuXG4gICAgaWYgKG9uU3dpcGUpIHtcbiAgICAgIG9uU3dpcGUoc3dpcGVEaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIHZhciBzbGlkZUNvdW50LCBuZXdTbGlkZTtcbiAgICB2YXIgYWN0aXZlU2xpZGUgPSBpbmZpbml0ZSA/IGN1cnJlbnRTbGlkZSA6IHRhcmdldFNsaWRlO1xuXG4gICAgc3dpdGNoIChzd2lwZURpcmVjdGlvbikge1xuICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgIGNhc2UgXCJ1cFwiOlxuICAgICAgICBuZXdTbGlkZSA9IGFjdGl2ZVNsaWRlICsgZ2V0U2xpZGVDb3VudChzcGVjKTtcbiAgICAgICAgc2xpZGVDb3VudCA9IHN3aXBlVG9TbGlkZSA/IGNoZWNrTmF2aWdhYmxlKHNwZWMsIG5ld1NsaWRlKSA6IG5ld1NsaWRlO1xuICAgICAgICBzdGF0ZVtcImN1cnJlbnREaXJlY3Rpb25cIl0gPSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICBuZXdTbGlkZSA9IGFjdGl2ZVNsaWRlIC0gZ2V0U2xpZGVDb3VudChzcGVjKTtcbiAgICAgICAgc2xpZGVDb3VudCA9IHN3aXBlVG9TbGlkZSA/IGNoZWNrTmF2aWdhYmxlKHNwZWMsIG5ld1NsaWRlKSA6IG5ld1NsaWRlO1xuICAgICAgICBzdGF0ZVtcImN1cnJlbnREaXJlY3Rpb25cIl0gPSAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc2xpZGVDb3VudCA9IGFjdGl2ZVNsaWRlO1xuICAgIH1cblxuICAgIHN0YXRlW1widHJpZ2dlclNsaWRlSGFuZGxlclwiXSA9IHNsaWRlQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gQWRqdXN0IHRoZSB0cmFjayBiYWNrIHRvIGl0J3Mgb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgdmFyIGN1cnJlbnRMZWZ0ID0gZ2V0VHJhY2tMZWZ0KHNwZWMpO1xuICAgIHN0YXRlW1widHJhY2tTdHlsZVwiXSA9IGdldFRyYWNrQW5pbWF0ZUNTUyhfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHNwZWMpLCB7fSwge1xuICAgICAgbGVmdDogY3VycmVudExlZnRcbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59O1xuXG5leHBvcnRzLnN3aXBlRW5kID0gc3dpcGVFbmQ7XG5cbnZhciBnZXROYXZpZ2FibGVJbmRleGVzID0gZnVuY3Rpb24gZ2V0TmF2aWdhYmxlSW5kZXhlcyhzcGVjKSB7XG4gIHZhciBtYXggPSBzcGVjLmluZmluaXRlID8gc3BlYy5zbGlkZUNvdW50ICogMiA6IHNwZWMuc2xpZGVDb3VudDtcbiAgdmFyIGJyZWFrcG9pbnQgPSBzcGVjLmluZmluaXRlID8gc3BlYy5zbGlkZXNUb1Nob3cgKiAtMSA6IDA7XG4gIHZhciBjb3VudGVyID0gc3BlYy5pbmZpbml0ZSA/IHNwZWMuc2xpZGVzVG9TaG93ICogLTEgOiAwO1xuICB2YXIgaW5kZXhlcyA9IFtdO1xuXG4gIHdoaWxlIChicmVha3BvaW50IDwgbWF4KSB7XG4gICAgaW5kZXhlcy5wdXNoKGJyZWFrcG9pbnQpO1xuICAgIGJyZWFrcG9pbnQgPSBjb3VudGVyICsgc3BlYy5zbGlkZXNUb1Njcm9sbDtcbiAgICBjb3VudGVyICs9IE1hdGgubWluKHNwZWMuc2xpZGVzVG9TY3JvbGwsIHNwZWMuc2xpZGVzVG9TaG93KTtcbiAgfVxuXG4gIHJldHVybiBpbmRleGVzO1xufTtcblxuZXhwb3J0cy5nZXROYXZpZ2FibGVJbmRleGVzID0gZ2V0TmF2aWdhYmxlSW5kZXhlcztcblxudmFyIGNoZWNrTmF2aWdhYmxlID0gZnVuY3Rpb24gY2hlY2tOYXZpZ2FibGUoc3BlYywgaW5kZXgpIHtcbiAgdmFyIG5hdmlnYWJsZXMgPSBnZXROYXZpZ2FibGVJbmRleGVzKHNwZWMpO1xuICB2YXIgcHJldk5hdmlnYWJsZSA9IDA7XG5cbiAgaWYgKGluZGV4ID4gbmF2aWdhYmxlc1tuYXZpZ2FibGVzLmxlbmd0aCAtIDFdKSB7XG4gICAgaW5kZXggPSBuYXZpZ2FibGVzW25hdmlnYWJsZXMubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgbiBpbiBuYXZpZ2FibGVzKSB7XG4gICAgICBpZiAoaW5kZXggPCBuYXZpZ2FibGVzW25dKSB7XG4gICAgICAgIGluZGV4ID0gcHJldk5hdmlnYWJsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHByZXZOYXZpZ2FibGUgPSBuYXZpZ2FibGVzW25dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG5cbmV4cG9ydHMuY2hlY2tOYXZpZ2FibGUgPSBjaGVja05hdmlnYWJsZTtcblxudmFyIGdldFNsaWRlQ291bnQgPSBmdW5jdGlvbiBnZXRTbGlkZUNvdW50KHNwZWMpIHtcbiAgdmFyIGNlbnRlck9mZnNldCA9IHNwZWMuY2VudGVyTW9kZSA/IHNwZWMuc2xpZGVXaWR0aCAqIE1hdGguZmxvb3Ioc3BlYy5zbGlkZXNUb1Nob3cgLyAyKSA6IDA7XG5cbiAgaWYgKHNwZWMuc3dpcGVUb1NsaWRlKSB7XG4gICAgdmFyIHN3aXBlZFNsaWRlO1xuICAgIHZhciBzbGlja0xpc3QgPSBzcGVjLmxpc3RSZWY7XG4gICAgdmFyIHNsaWRlcyA9IHNsaWNrTGlzdC5xdWVyeVNlbGVjdG9yQWxsICYmIHNsaWNrTGlzdC5xdWVyeVNlbGVjdG9yQWxsKFwiLnNsaWNrLXNsaWRlXCIpIHx8IFtdO1xuICAgIEFycmF5LmZyb20oc2xpZGVzKS5ldmVyeShmdW5jdGlvbiAoc2xpZGUpIHtcbiAgICAgIGlmICghc3BlYy52ZXJ0aWNhbCkge1xuICAgICAgICBpZiAoc2xpZGUub2Zmc2V0TGVmdCAtIGNlbnRlck9mZnNldCArIGdldFdpZHRoKHNsaWRlKSAvIDIgPiBzcGVjLnN3aXBlTGVmdCAqIC0xKSB7XG4gICAgICAgICAgc3dpcGVkU2xpZGUgPSBzbGlkZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzbGlkZS5vZmZzZXRUb3AgKyBnZXRIZWlnaHQoc2xpZGUpIC8gMiA+IHNwZWMuc3dpcGVMZWZ0ICogLTEpIHtcbiAgICAgICAgICBzd2lwZWRTbGlkZSA9IHNsaWRlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGlmICghc3dpcGVkU2xpZGUpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50SW5kZXggPSBzcGVjLnJ0bCA9PT0gdHJ1ZSA/IHNwZWMuc2xpZGVDb3VudCAtIHNwZWMuY3VycmVudFNsaWRlIDogc3BlYy5jdXJyZW50U2xpZGU7XG4gICAgdmFyIHNsaWRlc1RyYXZlcnNlZCA9IE1hdGguYWJzKHN3aXBlZFNsaWRlLmRhdGFzZXQuaW5kZXggLSBjdXJyZW50SW5kZXgpIHx8IDE7XG4gICAgcmV0dXJuIHNsaWRlc1RyYXZlcnNlZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3BlYy5zbGlkZXNUb1Njcm9sbDtcbiAgfVxufTtcblxuZXhwb3J0cy5nZXRTbGlkZUNvdW50ID0gZ2V0U2xpZGVDb3VudDtcblxudmFyIGNoZWNrU3BlY0tleXMgPSBmdW5jdGlvbiBjaGVja1NwZWNLZXlzKHNwZWMsIGtleXNBcnJheSkge1xuICByZXR1cm4ga2V5c0FycmF5LnJlZHVjZShmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiBzcGVjLmhhc093blByb3BlcnR5KGtleSk7XG4gIH0sIHRydWUpID8gbnVsbCA6IGNvbnNvbGUuZXJyb3IoXCJLZXlzIE1pc3Npbmc6XCIsIHNwZWMpO1xufTtcblxuZXhwb3J0cy5jaGVja1NwZWNLZXlzID0gY2hlY2tTcGVjS2V5cztcblxudmFyIGdldFRyYWNrQ1NTID0gZnVuY3Rpb24gZ2V0VHJhY2tDU1Moc3BlYykge1xuICBjaGVja1NwZWNLZXlzKHNwZWMsIFtcImxlZnRcIiwgXCJ2YXJpYWJsZVdpZHRoXCIsIFwic2xpZGVDb3VudFwiLCBcInNsaWRlc1RvU2hvd1wiLCBcInNsaWRlV2lkdGhcIl0pO1xuICB2YXIgdHJhY2tXaWR0aCwgdHJhY2tIZWlnaHQ7XG4gIHZhciB0cmFja0NoaWxkcmVuID0gc3BlYy5zbGlkZUNvdW50ICsgMiAqIHNwZWMuc2xpZGVzVG9TaG93O1xuXG4gIGlmICghc3BlYy52ZXJ0aWNhbCkge1xuICAgIHRyYWNrV2lkdGggPSBnZXRUb3RhbFNsaWRlcyhzcGVjKSAqIHNwZWMuc2xpZGVXaWR0aDtcbiAgfSBlbHNlIHtcbiAgICB0cmFja0hlaWdodCA9IHRyYWNrQ2hpbGRyZW4gKiBzcGVjLnNsaWRlSGVpZ2h0O1xuICB9XG5cbiAgdmFyIHN0eWxlID0ge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgdHJhbnNpdGlvbjogXCJcIixcbiAgICBXZWJraXRUcmFuc2l0aW9uOiBcIlwiXG4gIH07XG5cbiAgaWYgKHNwZWMudXNlVHJhbnNmb3JtKSB7XG4gICAgdmFyIFdlYmtpdFRyYW5zZm9ybSA9ICFzcGVjLnZlcnRpY2FsID8gXCJ0cmFuc2xhdGUzZChcIiArIHNwZWMubGVmdCArIFwicHgsIDBweCwgMHB4KVwiIDogXCJ0cmFuc2xhdGUzZCgwcHgsIFwiICsgc3BlYy5sZWZ0ICsgXCJweCwgMHB4KVwiO1xuICAgIHZhciB0cmFuc2Zvcm0gPSAhc3BlYy52ZXJ0aWNhbCA/IFwidHJhbnNsYXRlM2QoXCIgKyBzcGVjLmxlZnQgKyBcInB4LCAwcHgsIDBweClcIiA6IFwidHJhbnNsYXRlM2QoMHB4LCBcIiArIHNwZWMubGVmdCArIFwicHgsIDBweClcIjtcbiAgICB2YXIgbXNUcmFuc2Zvcm0gPSAhc3BlYy52ZXJ0aWNhbCA/IFwidHJhbnNsYXRlWChcIiArIHNwZWMubGVmdCArIFwicHgpXCIgOiBcInRyYW5zbGF0ZVkoXCIgKyBzcGVjLmxlZnQgKyBcInB4KVwiO1xuICAgIHN0eWxlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdHlsZSksIHt9LCB7XG4gICAgICBXZWJraXRUcmFuc2Zvcm06IFdlYmtpdFRyYW5zZm9ybSxcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgbXNUcmFuc2Zvcm06IG1zVHJhbnNmb3JtXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNwZWMudmVydGljYWwpIHtcbiAgICAgIHN0eWxlW1widG9wXCJdID0gc3BlYy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtcImxlZnRcIl0gPSBzcGVjLmxlZnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNwZWMuZmFkZSkgc3R5bGUgPSB7XG4gICAgb3BhY2l0eTogMVxuICB9O1xuICBpZiAodHJhY2tXaWR0aCkgc3R5bGUud2lkdGggPSB0cmFja1dpZHRoO1xuICBpZiAodHJhY2tIZWlnaHQpIHN0eWxlLmhlaWdodCA9IHRyYWNrSGVpZ2h0OyAvLyBGYWxsYmFjayBmb3IgSUU4XG5cbiAgaWYgKHdpbmRvdyAmJiAhd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgJiYgd2luZG93LmF0dGFjaEV2ZW50KSB7XG4gICAgaWYgKCFzcGVjLnZlcnRpY2FsKSB7XG4gICAgICBzdHlsZS5tYXJnaW5MZWZ0ID0gc3BlYy5sZWZ0ICsgXCJweFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5tYXJnaW5Ub3AgPSBzcGVjLmxlZnQgKyBcInB4XCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuZXhwb3J0cy5nZXRUcmFja0NTUyA9IGdldFRyYWNrQ1NTO1xuXG52YXIgZ2V0VHJhY2tBbmltYXRlQ1NTID0gZnVuY3Rpb24gZ2V0VHJhY2tBbmltYXRlQ1NTKHNwZWMpIHtcbiAgY2hlY2tTcGVjS2V5cyhzcGVjLCBbXCJsZWZ0XCIsIFwidmFyaWFibGVXaWR0aFwiLCBcInNsaWRlQ291bnRcIiwgXCJzbGlkZXNUb1Nob3dcIiwgXCJzbGlkZVdpZHRoXCIsIFwic3BlZWRcIiwgXCJjc3NFYXNlXCJdKTtcbiAgdmFyIHN0eWxlID0gZ2V0VHJhY2tDU1Moc3BlYyk7IC8vIHVzZUNTUyBpcyB0cnVlIGJ5IGRlZmF1bHQgc28gaXQgY2FuIGJlIHVuZGVmaW5lZFxuXG4gIGlmIChzcGVjLnVzZVRyYW5zZm9ybSkge1xuICAgIHN0eWxlLldlYmtpdFRyYW5zaXRpb24gPSBcIi13ZWJraXQtdHJhbnNmb3JtIFwiICsgc3BlYy5zcGVlZCArIFwibXMgXCIgKyBzcGVjLmNzc0Vhc2U7XG4gICAgc3R5bGUudHJhbnNpdGlvbiA9IFwidHJhbnNmb3JtIFwiICsgc3BlYy5zcGVlZCArIFwibXMgXCIgKyBzcGVjLmNzc0Vhc2U7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNwZWMudmVydGljYWwpIHtcbiAgICAgIHN0eWxlLnRyYW5zaXRpb24gPSBcInRvcCBcIiArIHNwZWMuc3BlZWQgKyBcIm1zIFwiICsgc3BlYy5jc3NFYXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS50cmFuc2l0aW9uID0gXCJsZWZ0IFwiICsgc3BlYy5zcGVlZCArIFwibXMgXCIgKyBzcGVjLmNzc0Vhc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuZXhwb3J0cy5nZXRUcmFja0FuaW1hdGVDU1MgPSBnZXRUcmFja0FuaW1hdGVDU1M7XG5cbnZhciBnZXRUcmFja0xlZnQgPSBmdW5jdGlvbiBnZXRUcmFja0xlZnQoc3BlYykge1xuICBpZiAoc3BlYy51bnNsaWNrKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBjaGVja1NwZWNLZXlzKHNwZWMsIFtcInNsaWRlSW5kZXhcIiwgXCJ0cmFja1JlZlwiLCBcImluZmluaXRlXCIsIFwiY2VudGVyTW9kZVwiLCBcInNsaWRlQ291bnRcIiwgXCJzbGlkZXNUb1Nob3dcIiwgXCJzbGlkZXNUb1Njcm9sbFwiLCBcInNsaWRlV2lkdGhcIiwgXCJsaXN0V2lkdGhcIiwgXCJ2YXJpYWJsZVdpZHRoXCIsIFwic2xpZGVIZWlnaHRcIl0pO1xuICB2YXIgc2xpZGVJbmRleCA9IHNwZWMuc2xpZGVJbmRleCxcbiAgICAgIHRyYWNrUmVmID0gc3BlYy50cmFja1JlZixcbiAgICAgIGluZmluaXRlID0gc3BlYy5pbmZpbml0ZSxcbiAgICAgIGNlbnRlck1vZGUgPSBzcGVjLmNlbnRlck1vZGUsXG4gICAgICBzbGlkZUNvdW50ID0gc3BlYy5zbGlkZUNvdW50LFxuICAgICAgc2xpZGVzVG9TaG93ID0gc3BlYy5zbGlkZXNUb1Nob3csXG4gICAgICBzbGlkZXNUb1Njcm9sbCA9IHNwZWMuc2xpZGVzVG9TY3JvbGwsXG4gICAgICBzbGlkZVdpZHRoID0gc3BlYy5zbGlkZVdpZHRoLFxuICAgICAgbGlzdFdpZHRoID0gc3BlYy5saXN0V2lkdGgsXG4gICAgICB2YXJpYWJsZVdpZHRoID0gc3BlYy52YXJpYWJsZVdpZHRoLFxuICAgICAgc2xpZGVIZWlnaHQgPSBzcGVjLnNsaWRlSGVpZ2h0LFxuICAgICAgZmFkZSA9IHNwZWMuZmFkZSxcbiAgICAgIHZlcnRpY2FsID0gc3BlYy52ZXJ0aWNhbDtcbiAgdmFyIHNsaWRlT2Zmc2V0ID0gMDtcbiAgdmFyIHRhcmdldExlZnQ7XG4gIHZhciB0YXJnZXRTbGlkZTtcbiAgdmFyIHZlcnRpY2FsT2Zmc2V0ID0gMDtcblxuICBpZiAoZmFkZSB8fCBzcGVjLnNsaWRlQ291bnQgPT09IDEpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBzbGlkZXNUb09mZnNldCA9IDA7XG5cbiAgaWYgKGluZmluaXRlKSB7XG4gICAgc2xpZGVzVG9PZmZzZXQgPSAtZ2V0UHJlQ2xvbmVzKHNwZWMpOyAvLyBicmluZyBhY3RpdmUgc2xpZGUgdG8gdGhlIGJlZ2lubmluZyBvZiB2aXN1YWwgYXJlYVxuICAgIC8vIGlmIG5leHQgc2Nyb2xsIGRvZXNuJ3QgaGF2ZSBlbm91Z2ggY2hpbGRyZW4sIGp1c3QgcmVhY2ggdGlsbCB0aGUgZW5kIG9mIG9yaWdpbmFsIHNsaWRlcyBpbnN0ZWFkIG9mIHNoaWZ0aW5nIHNsaWRlc1RvU2Nyb2xsIGNoaWxkcmVuXG5cbiAgICBpZiAoc2xpZGVDb3VudCAlIHNsaWRlc1RvU2Nyb2xsICE9PSAwICYmIHNsaWRlSW5kZXggKyBzbGlkZXNUb1Njcm9sbCA+IHNsaWRlQ291bnQpIHtcbiAgICAgIHNsaWRlc1RvT2Zmc2V0ID0gLShzbGlkZUluZGV4ID4gc2xpZGVDb3VudCA/IHNsaWRlc1RvU2hvdyAtIChzbGlkZUluZGV4IC0gc2xpZGVDb3VudCkgOiBzbGlkZUNvdW50ICUgc2xpZGVzVG9TY3JvbGwpO1xuICAgIH0gLy8gc2hpZnQgY3VycmVudCBzbGlkZSB0byBjZW50ZXIgb2YgdGhlIGZyYW1lXG5cblxuICAgIGlmIChjZW50ZXJNb2RlKSB7XG4gICAgICBzbGlkZXNUb09mZnNldCArPSBwYXJzZUludChzbGlkZXNUb1Nob3cgLyAyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNsaWRlQ291bnQgJSBzbGlkZXNUb1Njcm9sbCAhPT0gMCAmJiBzbGlkZUluZGV4ICsgc2xpZGVzVG9TY3JvbGwgPiBzbGlkZUNvdW50KSB7XG4gICAgICBzbGlkZXNUb09mZnNldCA9IHNsaWRlc1RvU2hvdyAtIHNsaWRlQ291bnQgJSBzbGlkZXNUb1Njcm9sbDtcbiAgICB9XG5cbiAgICBpZiAoY2VudGVyTW9kZSkge1xuICAgICAgc2xpZGVzVG9PZmZzZXQgPSBwYXJzZUludChzbGlkZXNUb1Nob3cgLyAyKTtcbiAgICB9XG4gIH1cblxuICBzbGlkZU9mZnNldCA9IHNsaWRlc1RvT2Zmc2V0ICogc2xpZGVXaWR0aDtcbiAgdmVydGljYWxPZmZzZXQgPSBzbGlkZXNUb09mZnNldCAqIHNsaWRlSGVpZ2h0O1xuXG4gIGlmICghdmVydGljYWwpIHtcbiAgICB0YXJnZXRMZWZ0ID0gc2xpZGVJbmRleCAqIHNsaWRlV2lkdGggKiAtMSArIHNsaWRlT2Zmc2V0O1xuICB9IGVsc2Uge1xuICAgIHRhcmdldExlZnQgPSBzbGlkZUluZGV4ICogc2xpZGVIZWlnaHQgKiAtMSArIHZlcnRpY2FsT2Zmc2V0O1xuICB9XG5cbiAgaWYgKHZhcmlhYmxlV2lkdGggPT09IHRydWUpIHtcbiAgICB2YXIgdGFyZ2V0U2xpZGVJbmRleDtcbiAgICB2YXIgdHJhY2tFbGVtID0gdHJhY2tSZWYgJiYgdHJhY2tSZWYubm9kZTtcbiAgICB0YXJnZXRTbGlkZUluZGV4ID0gc2xpZGVJbmRleCArIGdldFByZUNsb25lcyhzcGVjKTtcbiAgICB0YXJnZXRTbGlkZSA9IHRyYWNrRWxlbSAmJiB0cmFja0VsZW0uY2hpbGROb2Rlc1t0YXJnZXRTbGlkZUluZGV4XTtcbiAgICB0YXJnZXRMZWZ0ID0gdGFyZ2V0U2xpZGUgPyB0YXJnZXRTbGlkZS5vZmZzZXRMZWZ0ICogLTEgOiAwO1xuXG4gICAgaWYgKGNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgIHRhcmdldFNsaWRlSW5kZXggPSBpbmZpbml0ZSA/IHNsaWRlSW5kZXggKyBnZXRQcmVDbG9uZXMoc3BlYykgOiBzbGlkZUluZGV4O1xuICAgICAgdGFyZ2V0U2xpZGUgPSB0cmFja0VsZW0gJiYgdHJhY2tFbGVtLmNoaWxkcmVuW3RhcmdldFNsaWRlSW5kZXhdO1xuICAgICAgdGFyZ2V0TGVmdCA9IDA7XG5cbiAgICAgIGZvciAodmFyIHNsaWRlID0gMDsgc2xpZGUgPCB0YXJnZXRTbGlkZUluZGV4OyBzbGlkZSsrKSB7XG4gICAgICAgIHRhcmdldExlZnQgLT0gdHJhY2tFbGVtICYmIHRyYWNrRWxlbS5jaGlsZHJlbltzbGlkZV0gJiYgdHJhY2tFbGVtLmNoaWxkcmVuW3NsaWRlXS5vZmZzZXRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0TGVmdCAtPSBwYXJzZUludChzcGVjLmNlbnRlclBhZGRpbmcpO1xuICAgICAgdGFyZ2V0TGVmdCArPSB0YXJnZXRTbGlkZSAmJiAobGlzdFdpZHRoIC0gdGFyZ2V0U2xpZGUub2Zmc2V0V2lkdGgpIC8gMjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0TGVmdDtcbn07XG5cbmV4cG9ydHMuZ2V0VHJhY2tMZWZ0ID0gZ2V0VHJhY2tMZWZ0O1xuXG52YXIgZ2V0UHJlQ2xvbmVzID0gZnVuY3Rpb24gZ2V0UHJlQ2xvbmVzKHNwZWMpIHtcbiAgaWYgKHNwZWMudW5zbGljayB8fCAhc3BlYy5pbmZpbml0ZSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKHNwZWMudmFyaWFibGVXaWR0aCkge1xuICAgIHJldHVybiBzcGVjLnNsaWRlQ291bnQ7XG4gIH1cblxuICByZXR1cm4gc3BlYy5zbGlkZXNUb1Nob3cgKyAoc3BlYy5jZW50ZXJNb2RlID8gMSA6IDApO1xufTtcblxuZXhwb3J0cy5nZXRQcmVDbG9uZXMgPSBnZXRQcmVDbG9uZXM7XG5cbnZhciBnZXRQb3N0Q2xvbmVzID0gZnVuY3Rpb24gZ2V0UG9zdENsb25lcyhzcGVjKSB7XG4gIGlmIChzcGVjLnVuc2xpY2sgfHwgIXNwZWMuaW5maW5pdGUpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBzcGVjLnNsaWRlQ291bnQ7XG59O1xuXG5leHBvcnRzLmdldFBvc3RDbG9uZXMgPSBnZXRQb3N0Q2xvbmVzO1xuXG52YXIgZ2V0VG90YWxTbGlkZXMgPSBmdW5jdGlvbiBnZXRUb3RhbFNsaWRlcyhzcGVjKSB7XG4gIHJldHVybiBzcGVjLnNsaWRlQ291bnQgPT09IDEgPyAxIDogZ2V0UHJlQ2xvbmVzKHNwZWMpICsgc3BlYy5zbGlkZUNvdW50ICsgZ2V0UG9zdENsb25lcyhzcGVjKTtcbn07XG5cbmV4cG9ydHMuZ2V0VG90YWxTbGlkZXMgPSBnZXRUb3RhbFNsaWRlcztcblxudmFyIHNpYmxpbmdEaXJlY3Rpb24gPSBmdW5jdGlvbiBzaWJsaW5nRGlyZWN0aW9uKHNwZWMpIHtcbiAgaWYgKHNwZWMudGFyZ2V0U2xpZGUgPiBzcGVjLmN1cnJlbnRTbGlkZSkge1xuICAgIGlmIChzcGVjLnRhcmdldFNsaWRlID4gc3BlYy5jdXJyZW50U2xpZGUgKyBzbGlkZXNPblJpZ2h0KHNwZWMpKSB7XG4gICAgICByZXR1cm4gXCJsZWZ0XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwicmlnaHRcIjtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3BlYy50YXJnZXRTbGlkZSA8IHNwZWMuY3VycmVudFNsaWRlIC0gc2xpZGVzT25MZWZ0KHNwZWMpKSB7XG4gICAgICByZXR1cm4gXCJyaWdodFwiO1xuICAgIH1cblxuICAgIHJldHVybiBcImxlZnRcIjtcbiAgfVxufTtcblxuZXhwb3J0cy5zaWJsaW5nRGlyZWN0aW9uID0gc2libGluZ0RpcmVjdGlvbjtcblxudmFyIHNsaWRlc09uUmlnaHQgPSBmdW5jdGlvbiBzbGlkZXNPblJpZ2h0KF9yZWYpIHtcbiAgdmFyIHNsaWRlc1RvU2hvdyA9IF9yZWYuc2xpZGVzVG9TaG93LFxuICAgICAgY2VudGVyTW9kZSA9IF9yZWYuY2VudGVyTW9kZSxcbiAgICAgIHJ0bCA9IF9yZWYucnRsLFxuICAgICAgY2VudGVyUGFkZGluZyA9IF9yZWYuY2VudGVyUGFkZGluZztcblxuICAvLyByZXR1cm5zIG5vIG9mIHNsaWRlcyBvbiB0aGUgcmlnaHQgb2YgYWN0aXZlIHNsaWRlXG4gIGlmIChjZW50ZXJNb2RlKSB7XG4gICAgdmFyIHJpZ2h0ID0gKHNsaWRlc1RvU2hvdyAtIDEpIC8gMiArIDE7XG4gICAgaWYgKHBhcnNlSW50KGNlbnRlclBhZGRpbmcpID4gMCkgcmlnaHQgKz0gMTtcbiAgICBpZiAocnRsICYmIHNsaWRlc1RvU2hvdyAlIDIgPT09IDApIHJpZ2h0ICs9IDE7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9XG5cbiAgaWYgKHJ0bCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHNsaWRlc1RvU2hvdyAtIDE7XG59O1xuXG5leHBvcnRzLnNsaWRlc09uUmlnaHQgPSBzbGlkZXNPblJpZ2h0O1xuXG52YXIgc2xpZGVzT25MZWZ0ID0gZnVuY3Rpb24gc2xpZGVzT25MZWZ0KF9yZWYyKSB7XG4gIHZhciBzbGlkZXNUb1Nob3cgPSBfcmVmMi5zbGlkZXNUb1Nob3csXG4gICAgICBjZW50ZXJNb2RlID0gX3JlZjIuY2VudGVyTW9kZSxcbiAgICAgIHJ0bCA9IF9yZWYyLnJ0bCxcbiAgICAgIGNlbnRlclBhZGRpbmcgPSBfcmVmMi5jZW50ZXJQYWRkaW5nO1xuXG4gIC8vIHJldHVybnMgbm8gb2Ygc2xpZGVzIG9uIHRoZSBsZWZ0IG9mIGFjdGl2ZSBzbGlkZVxuICBpZiAoY2VudGVyTW9kZSkge1xuICAgIHZhciBsZWZ0ID0gKHNsaWRlc1RvU2hvdyAtIDEpIC8gMiArIDE7XG4gICAgaWYgKHBhcnNlSW50KGNlbnRlclBhZGRpbmcpID4gMCkgbGVmdCArPSAxO1xuICAgIGlmICghcnRsICYmIHNsaWRlc1RvU2hvdyAlIDIgPT09IDApIGxlZnQgKz0gMTtcbiAgICByZXR1cm4gbGVmdDtcbiAgfVxuXG4gIGlmIChydGwpIHtcbiAgICByZXR1cm4gc2xpZGVzVG9TaG93IC0gMTtcbiAgfVxuXG4gIHJldHVybiAwO1xufTtcblxuZXhwb3J0cy5zbGlkZXNPbkxlZnQgPSBzbGlkZXNPbkxlZnQ7XG5cbnZhciBjYW5Vc2VET00gPSBmdW5jdGlvbiBjYW5Vc2VET00oKSB7XG4gIHJldHVybiAhISh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG59O1xuXG5leHBvcnRzLmNhblVzZURPTSA9IGNhblVzZURPTTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjaGVja1NwZWNLZXlzIiwiY2hlY2tOYXZpZ2FibGUiLCJjaGFuZ2VTbGlkZSIsImNhblVzZURPTSIsImNhbkdvTmV4dCIsImNsYW1wIiwic3dpcGVTdGFydCIsInN3aXBlTW92ZSIsInN3aXBlRW5kIiwic2xpZGVzT25SaWdodCIsInNsaWRlc09uTGVmdCIsInNsaWRlSGFuZGxlciIsInNpYmxpbmdEaXJlY3Rpb24iLCJzYWZlUHJldmVudERlZmF1bHQiLCJsYXp5U3RhcnRJbmRleCIsImxhenlTbGlkZXNPblJpZ2h0IiwibGF6eVNsaWRlc09uTGVmdCIsImxhenlFbmRJbmRleCIsImtleUhhbmRsZXIiLCJpbml0aWFsaXplZFN0YXRlIiwiZ2V0V2lkdGgiLCJnZXRUcmFja0xlZnQiLCJnZXRUcmFja0NTUyIsImdldFRyYWNrQW5pbWF0ZUNTUyIsImdldFRvdGFsU2xpZGVzIiwiZ2V0U3dpcGVEaXJlY3Rpb24iLCJnZXRTbGlkZUNvdW50IiwiZ2V0UmVxdWlyZWRMYXp5U2xpZGVzIiwiZ2V0UHJlQ2xvbmVzIiwiZ2V0UG9zdENsb25lcyIsImdldE9uRGVtYW5kTGF6eVNsaWRlcyIsImdldE5hdmlnYWJsZUluZGV4ZXMiLCJnZXRIZWlnaHQiLCJleHRyYWN0T2JqZWN0IiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJvYmoiLCJfX2VzTW9kdWxlIiwib3duS2V5cyIsIm9iamVjdCIsImVudW1lcmFibGVPbmx5Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJmb3JFYWNoIiwia2V5IiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm51bWJlciIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwiTWF0aCIsIm1heCIsIm1pbiIsImV2ZW50IiwicGFzc2l2ZUV2ZW50cyIsImluY2x1ZGVzIiwiX3JlYWN0TmFtZSIsInByZXZlbnREZWZhdWx0Iiwic3BlYyIsIm9uRGVtYW5kU2xpZGVzIiwic3RhcnRJbmRleCIsImVuZEluZGV4Iiwic2xpZGVJbmRleCIsImxhenlMb2FkZWRMaXN0IiwiaW5kZXhPZiIsInJlcXVpcmVkU2xpZGVzIiwiY3VycmVudFNsaWRlIiwiY2VudGVyTW9kZSIsImZsb29yIiwic2xpZGVzVG9TaG93IiwicGFyc2VJbnQiLCJjZW50ZXJQYWRkaW5nIiwiZWxlbSIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwidG91Y2hPYmplY3QiLCJ2ZXJ0aWNhbFN3aXBpbmciLCJ1bmRlZmluZWQiLCJ4RGlzdCIsInlEaXN0IiwiciIsInN3aXBlQW5nbGUiLCJzdGFydFgiLCJjdXJYIiwic3RhcnRZIiwiY3VyWSIsImF0YW4yIiwicm91bmQiLCJQSSIsImFicyIsImNhbkdvIiwiaW5maW5pdGUiLCJzbGlkZUNvdW50IiwibmV3T2JqZWN0IiwiQ2hpbGRyZW4iLCJjb3VudCIsImNoaWxkcmVuIiwibGlzdE5vZGUiLCJsaXN0UmVmIiwibGlzdFdpZHRoIiwiY2VpbCIsInRyYWNrTm9kZSIsInRyYWNrUmVmIiwibm9kZSIsInRyYWNrV2lkdGgiLCJzbGlkZVdpZHRoIiwidmVydGljYWwiLCJjZW50ZXJQYWRkaW5nQWRqIiwic2xpY2UiLCJzbGlkZUhlaWdodCIsInF1ZXJ5U2VsZWN0b3IiLCJsaXN0SGVpZ2h0IiwiaW5pdGlhbFNsaWRlIiwicnRsIiwic2xpZGVzVG9Mb2FkIiwiY29uY2F0Iiwic3RhdGUiLCJhdXRvcGxheWluZyIsImF1dG9wbGF5Iiwid2FpdEZvckFuaW1hdGUiLCJhbmltYXRpbmciLCJmYWRlIiwiaW5kZXgiLCJsYXp5TG9hZCIsInNsaWRlc1RvU2Nyb2xsIiwidXNlQ1NTIiwiYW5pbWF0aW9uU2xpZGUiLCJmaW5hbFNsaWRlIiwiYW5pbWF0aW9uTGVmdCIsImZpbmFsTGVmdCIsIm5leHRTdGF0ZSIsInRhcmdldFNsaWRlIiwidHJhY2tTdHlsZSIsImxlZnQiLCJzd2lwZUxlZnQiLCJvcHRpb25zIiwiaW5kZXhPZmZzZXQiLCJwcmV2aW91c0ludCIsInNsaWRlT2Zmc2V0IiwidW5ldmVuT2Zmc2V0IiwicHJldmlvdXNUYXJnZXRTbGlkZSIsIm1lc3NhZ2UiLCJkaXJlY3Rpb24iLCJOdW1iZXIiLCJlIiwiYWNjZXNzaWJpbGl0eSIsInRhZ05hbWUiLCJtYXRjaCIsImtleUNvZGUiLCJzd2lwZSIsImRyYWdnYWJsZSIsInR5cGUiLCJkcmFnZ2luZyIsInRvdWNoZXMiLCJwYWdlWCIsImNsaWVudFgiLCJwYWdlWSIsImNsaWVudFkiLCJzY3JvbGxpbmciLCJzd2lwZVRvU2xpZGUiLCJlZGdlRnJpY3Rpb24iLCJlZGdlRHJhZ2dlZCIsIm9uRWRnZSIsInN3aXBlZCIsInN3aXBpbmciLCJzd2lwZUV2ZW50IiwiY3VyTGVmdCIsInN3aXBlTGVuZ3RoIiwic3FydCIsInBvdyIsInZlcnRpY2FsU3dpcGVMZW5ndGgiLCJwb3NpdGlvbk9mZnNldCIsImRvdENvdW50Iiwic3dpcGVEaXJlY3Rpb24iLCJ0b3VjaFN3aXBlTGVuZ3RoIiwidG91Y2hUaHJlc2hvbGQiLCJvblN3aXBlIiwibWluU3dpcGUiLCJuZXdTbGlkZSIsImFjdGl2ZVNsaWRlIiwiY3VycmVudExlZnQiLCJicmVha3BvaW50IiwiY291bnRlciIsImluZGV4ZXMiLCJuYXZpZ2FibGVzIiwicHJldk5hdmlnYWJsZSIsIm4iLCJjZW50ZXJPZmZzZXQiLCJzd2lwZWRTbGlkZSIsInNsaWNrTGlzdCIsInNsaWRlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJBcnJheSIsImZyb20iLCJldmVyeSIsInNsaWRlIiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsImN1cnJlbnRJbmRleCIsInNsaWRlc1RyYXZlcnNlZCIsImRhdGFzZXQiLCJrZXlzQXJyYXkiLCJyZWR1Y2UiLCJoYXNPd25Qcm9wZXJ0eSIsImNvbnNvbGUiLCJlcnJvciIsInRyYWNrSGVpZ2h0IiwidHJhY2tDaGlsZHJlbiIsInN0eWxlIiwib3BhY2l0eSIsInRyYW5zaXRpb24iLCJXZWJraXRUcmFuc2l0aW9uIiwidXNlVHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNmb3JtIiwibXNUcmFuc2Zvcm0iLCJ3aWR0aCIsImhlaWdodCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsIm1hcmdpbkxlZnQiLCJtYXJnaW5Ub3AiLCJzcGVlZCIsImNzc0Vhc2UiLCJ1bnNsaWNrIiwidmFyaWFibGVXaWR0aCIsInRhcmdldExlZnQiLCJ2ZXJ0aWNhbE9mZnNldCIsInNsaWRlc1RvT2Zmc2V0IiwidGFyZ2V0U2xpZGVJbmRleCIsInRyYWNrRWxlbSIsImNoaWxkTm9kZXMiLCJfcmVmIiwicmlnaHQiLCJfcmVmMiIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-slick/lib/utils/innerSliderUtils.js\n");

/***/ })

};
;